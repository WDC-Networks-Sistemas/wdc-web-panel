"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/approvals/page",{

/***/ "(app-pages-browser)/./node_modules/recharts/es6/cartesian/ErrorBar.js":
/*!*********************************************************!*\
  !*** ./node_modules/recharts/es6/cartesian/ErrorBar.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorBar: () => (/* binding */ ErrorBar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _container_Layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../container/Layer */ \"(app-pages-browser)/./node_modules/recharts/es6/container/Layer.js\");\n/* harmony import */ var _util_ReactUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/ReactUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/ReactUtils.js\");\nvar _excluded = [\n    \"offset\",\n    \"layout\",\n    \"width\",\n    \"dataKey\",\n    \"data\",\n    \"dataPointFormatter\",\n    \"xAxis\",\n    \"yAxis\"\n];\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @fileOverview Render a group of error bar\n */ \n\n\n\n// eslint-disable-next-line react/prefer-stateless-function -- requires static defaultProps\nvar ErrorBar = /*#__PURE__*/ function(_React$Component) {\n    function ErrorBar() {\n        _classCallCheck(this, ErrorBar);\n        return _callSuper(this, ErrorBar, arguments);\n    }\n    _inherits(ErrorBar, _React$Component);\n    return _createClass(ErrorBar, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, offset = _this$props.offset, layout = _this$props.layout, width = _this$props.width, dataKey = _this$props.dataKey, data = _this$props.data, dataPointFormatter = _this$props.dataPointFormatter, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, others = _objectWithoutProperties(_this$props, _excluded);\n                var svgProps = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_2__.filterProps)(others, false);\n                !!(this.props.direction === 'x' && xAxis.type !== 'number') ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ErrorBar requires Axis type property to be \"number\".') : 0 : void 0;\n                var errorBars = data.map(function(entry) {\n                    var _dataPointFormatter = dataPointFormatter(entry, dataKey), x = _dataPointFormatter.x, y = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;\n                    if (!errorVal) {\n                        return null;\n                    }\n                    var lineCoordinates = [];\n                    var lowBound, highBound;\n                    if (Array.isArray(errorVal)) {\n                        var _errorVal = _slicedToArray(errorVal, 2);\n                        lowBound = _errorVal[0];\n                        highBound = _errorVal[1];\n                    } else {\n                        lowBound = highBound = errorVal;\n                    }\n                    if (layout === 'vertical') {\n                        // error bar for horizontal charts, the y is fixed, x is a range value\n                        var scale = xAxis.scale;\n                        var yMid = y + offset;\n                        var yMin = yMid + width;\n                        var yMax = yMid - width;\n                        var xMin = scale(value - lowBound);\n                        var xMax = scale(value + highBound);\n                        // the right line of |--|\n                        lineCoordinates.push({\n                            x1: xMax,\n                            y1: yMin,\n                            x2: xMax,\n                            y2: yMax\n                        });\n                        // the middle line of |--|\n                        lineCoordinates.push({\n                            x1: xMin,\n                            y1: yMid,\n                            x2: xMax,\n                            y2: yMid\n                        });\n                        // the left line of |--|\n                        lineCoordinates.push({\n                            x1: xMin,\n                            y1: yMin,\n                            x2: xMin,\n                            y2: yMax\n                        });\n                    } else if (layout === 'horizontal') {\n                        // error bar for horizontal charts, the x is fixed, y is a range value\n                        var _scale = yAxis.scale;\n                        var xMid = x + offset;\n                        var _xMin = xMid - width;\n                        var _xMax = xMid + width;\n                        var _yMin = _scale(value - lowBound);\n                        var _yMax = _scale(value + highBound);\n                        // the top line\n                        lineCoordinates.push({\n                            x1: _xMin,\n                            y1: _yMax,\n                            x2: _xMax,\n                            y2: _yMax\n                        });\n                        // the middle line\n                        lineCoordinates.push({\n                            x1: xMid,\n                            y1: _yMin,\n                            x2: xMid,\n                            y2: _yMax\n                        });\n                        // the bottom line\n                        lineCoordinates.push({\n                            x1: _xMin,\n                            y1: _yMin,\n                            x2: _xMax,\n                            y2: _yMin\n                        });\n                    }\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer, _extends({\n                        className: \"recharts-errorBar\",\n                        key: \"bar-\".concat(lineCoordinates.map(function(c) {\n                            return \"\".concat(c.x1, \"-\").concat(c.x2, \"-\").concat(c.y1, \"-\").concat(c.y2);\n                        }))\n                    }, svgProps), lineCoordinates.map(function(coordinates) {\n                        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", _extends({}, coordinates, {\n                            key: \"line-\".concat(coordinates.x1, \"-\").concat(coordinates.x2, \"-\").concat(coordinates.y1, \"-\").concat(coordinates.y2)\n                        }));\n                    }));\n                });\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer, {\n                    className: \"recharts-errorBars\"\n                }, errorBars);\n            }\n        }\n    ]);\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\n_defineProperty(ErrorBar, \"defaultProps\", {\n    stroke: 'black',\n    strokeWidth: 1.5,\n    width: 5,\n    offset: 0,\n    layout: 'horizontal'\n});\n_defineProperty(ErrorBar, \"displayName\", 'ErrorBar');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvY2FydGVzaWFuL0Vycm9yQmFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVk7SUFBQztJQUFVO0lBQVU7SUFBUztJQUFXO0lBQVE7SUFBc0I7SUFBUztDQUFRO0FBQ3hHLFNBQVNDLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSztJQUFhQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlQLE9BQU9GLFNBQVMsQ0FBQ1csY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0w7SUFBUTtJQUFHLE9BQU9KLFNBQVNZLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQVk7QUFDbFYsU0FBU08sZUFBZUMsR0FBRyxFQUFFVCxDQUFDO0lBQUksT0FBT1UsZ0JBQWdCRCxRQUFRRSxzQkFBc0JGLEtBQUtULE1BQU1ZLDRCQUE0QkgsS0FBS1QsTUFBTWE7QUFB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d0JBQ1hsSSxLQUFLLE9BQU9tSSxNQUFNLENBQUN0QixnQkFBZ0JOLEdBQUcsQ0FBQyxTQUFVNkIsQ0FBQzs0QkFDaEQsT0FBTyxHQUFHRCxNQUFNLENBQUNDLEVBQUViLEVBQUUsRUFBRSxLQUFLWSxNQUFNLENBQUNDLEVBQUVYLEVBQUUsRUFBRSxLQUFLVSxNQUFNLENBQUNDLEVBQUVaLEVBQUUsRUFBRSxLQUFLVyxNQUFNLENBQUNDLEVBQUVWLEVBQUU7d0JBQzdFO29CQUNGLEdBQUd4QixXQUFXVyxnQkFBZ0JOLEdBQUcsQ0FBQyxTQUFVOEIsV0FBVzt3QkFDckQsT0FBTyxXQUFXLEdBQUVwRCwwREFBbUIsQ0FBQyxRQUFRMUYsU0FBUyxDQUFDLEdBQUc4SSxhQUFhOzRCQUN4RXJJLEtBQUssUUFBUW1JLE1BQU0sQ0FBQ0UsWUFBWWQsRUFBRSxFQUFFLEtBQUtZLE1BQU0sQ0FBQ0UsWUFBWVosRUFBRSxFQUFFLEtBQUtVLE1BQU0sQ0FBQ0UsWUFBWWIsRUFBRSxFQUFFLEtBQUtXLE1BQU0sQ0FBQ0UsWUFBWVgsRUFBRTt3QkFDeEg7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTyxXQUFXLEdBQUV6QywwREFBbUIsQ0FBQ0UsbURBQUtBLEVBQUU7b0JBQzdDK0MsV0FBVztnQkFDYixHQUFHNUI7WUFDTDtRQUNGO0tBQUU7QUFDSixFQUFFckIsd0RBQWUsRUFBRTtBQUNuQk4sZ0JBQWdCVSxVQUFVLGdCQUFnQjtJQUN4Q2tELFFBQVE7SUFDUkMsYUFBYTtJQUNiN0MsT0FBTztJQUNQRixRQUFRO0lBQ1JDLFFBQVE7QUFDVjtBQUNBZixnQkFBZ0JVLFVBQVUsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvYW9zYW50b3MvV2Vic3Rvcm1Qcm9qZWN0cy93ZGMtd2ViLXBhbmVsL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvY2FydGVzaWFuL0Vycm9yQmFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXhjbHVkZWQgPSBbXCJvZmZzZXRcIiwgXCJsYXlvdXRcIiwgXCJ3aWR0aFwiLCBcImRhdGFLZXlcIiwgXCJkYXRhXCIsIFwiZGF0YVBvaW50Rm9ybWF0dGVyXCIsIFwieEF4aXNcIiwgXCJ5QXhpc1wiXTtcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFJlbmRlciBhIGdyb3VwIG9mIGVycm9yIGJhclxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvbnRhaW5lci9MYXllcic7XG5pbXBvcnQgeyBmaWx0ZXJQcm9wcyB9IGZyb20gJy4uL3V0aWwvUmVhY3RVdGlscyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvbiAtLSByZXF1aXJlcyBzdGF0aWMgZGVmYXVsdFByb3BzXG5leHBvcnQgdmFyIEVycm9yQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIEVycm9yQmFyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcnJvckJhcik7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRXJyb3JCYXIsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEVycm9yQmFyLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFcnJvckJhciwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG9mZnNldCA9IF90aGlzJHByb3BzLm9mZnNldCxcbiAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHMubGF5b3V0LFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzLndpZHRoLFxuICAgICAgICBkYXRhS2V5ID0gX3RoaXMkcHJvcHMuZGF0YUtleSxcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzLmRhdGEsXG4gICAgICAgIGRhdGFQb2ludEZvcm1hdHRlciA9IF90aGlzJHByb3BzLmRhdGFQb2ludEZvcm1hdHRlcixcbiAgICAgICAgeEF4aXMgPSBfdGhpcyRwcm9wcy54QXhpcyxcbiAgICAgICAgeUF4aXMgPSBfdGhpcyRwcm9wcy55QXhpcyxcbiAgICAgICAgb3RoZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBfZXhjbHVkZWQpO1xuICAgICAgdmFyIHN2Z1Byb3BzID0gZmlsdGVyUHJvcHMob3RoZXJzLCBmYWxzZSk7XG4gICAgICAhISh0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gJ3gnICYmIHhBeGlzLnR5cGUgIT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Vycm9yQmFyIHJlcXVpcmVzIEF4aXMgdHlwZSBwcm9wZXJ0eSB0byBiZSBcIm51bWJlclwiLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvckJhcnMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgdmFyIF9kYXRhUG9pbnRGb3JtYXR0ZXIgPSBkYXRhUG9pbnRGb3JtYXR0ZXIoZW50cnksIGRhdGFLZXkpLFxuICAgICAgICAgIHggPSBfZGF0YVBvaW50Rm9ybWF0dGVyLngsXG4gICAgICAgICAgeSA9IF9kYXRhUG9pbnRGb3JtYXR0ZXIueSxcbiAgICAgICAgICB2YWx1ZSA9IF9kYXRhUG9pbnRGb3JtYXR0ZXIudmFsdWUsXG4gICAgICAgICAgZXJyb3JWYWwgPSBfZGF0YVBvaW50Rm9ybWF0dGVyLmVycm9yVmFsO1xuICAgICAgICBpZiAoIWVycm9yVmFsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVDb29yZGluYXRlcyA9IFtdO1xuICAgICAgICB2YXIgbG93Qm91bmQsIGhpZ2hCb3VuZDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3JWYWwpKSB7XG4gICAgICAgICAgdmFyIF9lcnJvclZhbCA9IF9zbGljZWRUb0FycmF5KGVycm9yVmFsLCAyKTtcbiAgICAgICAgICBsb3dCb3VuZCA9IF9lcnJvclZhbFswXTtcbiAgICAgICAgICBoaWdoQm91bmQgPSBfZXJyb3JWYWxbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG93Qm91bmQgPSBoaWdoQm91bmQgPSBlcnJvclZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgLy8gZXJyb3IgYmFyIGZvciBob3Jpem9udGFsIGNoYXJ0cywgdGhlIHkgaXMgZml4ZWQsIHggaXMgYSByYW5nZSB2YWx1ZVxuICAgICAgICAgIHZhciBzY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgICAgICAgIHZhciB5TWlkID0geSArIG9mZnNldDtcbiAgICAgICAgICB2YXIgeU1pbiA9IHlNaWQgKyB3aWR0aDtcbiAgICAgICAgICB2YXIgeU1heCA9IHlNaWQgLSB3aWR0aDtcbiAgICAgICAgICB2YXIgeE1pbiA9IHNjYWxlKHZhbHVlIC0gbG93Qm91bmQpO1xuICAgICAgICAgIHZhciB4TWF4ID0gc2NhbGUodmFsdWUgKyBoaWdoQm91bmQpO1xuXG4gICAgICAgICAgLy8gdGhlIHJpZ2h0IGxpbmUgb2YgfC0tfFxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHgxOiB4TWF4LFxuICAgICAgICAgICAgeTE6IHlNaW4sXG4gICAgICAgICAgICB4MjogeE1heCxcbiAgICAgICAgICAgIHkyOiB5TWF4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gdGhlIG1pZGRsZSBsaW5lIG9mIHwtLXxcbiAgICAgICAgICBsaW5lQ29vcmRpbmF0ZXMucHVzaCh7XG4gICAgICAgICAgICB4MTogeE1pbixcbiAgICAgICAgICAgIHkxOiB5TWlkLFxuICAgICAgICAgICAgeDI6IHhNYXgsXG4gICAgICAgICAgICB5MjogeU1pZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIHRoZSBsZWZ0IGxpbmUgb2YgfC0tfFxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHgxOiB4TWluLFxuICAgICAgICAgICAgeTE6IHlNaW4sXG4gICAgICAgICAgICB4MjogeE1pbixcbiAgICAgICAgICAgIHkyOiB5TWF4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAvLyBlcnJvciBiYXIgZm9yIGhvcml6b250YWwgY2hhcnRzLCB0aGUgeCBpcyBmaXhlZCwgeSBpcyBhIHJhbmdlIHZhbHVlXG4gICAgICAgICAgdmFyIF9zY2FsZSA9IHlBeGlzLnNjYWxlO1xuICAgICAgICAgIHZhciB4TWlkID0geCArIG9mZnNldDtcbiAgICAgICAgICB2YXIgX3hNaW4gPSB4TWlkIC0gd2lkdGg7XG4gICAgICAgICAgdmFyIF94TWF4ID0geE1pZCArIHdpZHRoO1xuICAgICAgICAgIHZhciBfeU1pbiA9IF9zY2FsZSh2YWx1ZSAtIGxvd0JvdW5kKTtcbiAgICAgICAgICB2YXIgX3lNYXggPSBfc2NhbGUodmFsdWUgKyBoaWdoQm91bmQpO1xuXG4gICAgICAgICAgLy8gdGhlIHRvcCBsaW5lXG4gICAgICAgICAgbGluZUNvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgICAgeDE6IF94TWluLFxuICAgICAgICAgICAgeTE6IF95TWF4LFxuICAgICAgICAgICAgeDI6IF94TWF4LFxuICAgICAgICAgICAgeTI6IF95TWF4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gdGhlIG1pZGRsZSBsaW5lXG4gICAgICAgICAgbGluZUNvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgICAgeDE6IHhNaWQsXG4gICAgICAgICAgICB5MTogX3lNaW4sXG4gICAgICAgICAgICB4MjogeE1pZCxcbiAgICAgICAgICAgIHkyOiBfeU1heFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIHRoZSBib3R0b20gbGluZVxuICAgICAgICAgIGxpbmVDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHgxOiBfeE1pbixcbiAgICAgICAgICAgIHkxOiBfeU1pbixcbiAgICAgICAgICAgIHgyOiBfeE1heCxcbiAgICAgICAgICAgIHkyOiBfeU1pblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMYXllciwgX2V4dGVuZHMoe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy1lcnJvckJhclwiLFxuICAgICAgICAgIGtleTogXCJiYXItXCIuY29uY2F0KGxpbmVDb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjLngxLCBcIi1cIikuY29uY2F0KGMueDIsIFwiLVwiKS5jb25jYXQoYy55MSwgXCItXCIpLmNvbmNhdChjLnkyKTtcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSwgc3ZnUHJvcHMpLCBsaW5lQ29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgX2V4dGVuZHMoe30sIGNvb3JkaW5hdGVzLCB7XG4gICAgICAgICAgICBrZXk6IFwibGluZS1cIi5jb25jYXQoY29vcmRpbmF0ZXMueDEsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueDIsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueTEsIFwiLVwiKS5jb25jYXQoY29vcmRpbmF0ZXMueTIpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMYXllciwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtZXJyb3JCYXJzXCJcbiAgICAgIH0sIGVycm9yQmFycyk7XG4gICAgfVxuICB9XSk7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5fZGVmaW5lUHJvcGVydHkoRXJyb3JCYXIsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgc3Ryb2tlOiAnYmxhY2snLFxuICBzdHJva2VXaWR0aDogMS41LFxuICB3aWR0aDogNSxcbiAgb2Zmc2V0OiAwLFxuICBsYXlvdXQ6ICdob3Jpem9udGFsJ1xufSk7XG5fZGVmaW5lUHJvcGVydHkoRXJyb3JCYXIsIFwiZGlzcGxheU5hbWVcIiwgJ0Vycm9yQmFyJyk7Il0sIm5hbWVzIjpbIl9leGNsdWRlZCIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJyIiwibCIsInQiLCJlIiwidSIsImEiLCJmIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJpc0FycmF5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiUmVhY3QiLCJpbnZhcmlhbnQiLCJMYXllciIsImZpbHRlclByb3BzIiwiRXJyb3JCYXIiLCJfUmVhY3QkQ29tcG9uZW50IiwicmVuZGVyIiwiX3RoaXMkcHJvcHMiLCJvZmZzZXQiLCJsYXlvdXQiLCJ3aWR0aCIsImRhdGFLZXkiLCJkYXRhIiwiZGF0YVBvaW50Rm9ybWF0dGVyIiwieEF4aXMiLCJ5QXhpcyIsIm90aGVycyIsInN2Z1Byb3BzIiwiZGlyZWN0aW9uIiwidHlwZSIsInByb2Nlc3MiLCJlcnJvckJhcnMiLCJtYXAiLCJlbnRyeSIsIl9kYXRhUG9pbnRGb3JtYXR0ZXIiLCJ4IiwieSIsImVycm9yVmFsIiwibGluZUNvb3JkaW5hdGVzIiwibG93Qm91bmQiLCJoaWdoQm91bmQiLCJfZXJyb3JWYWwiLCJzY2FsZSIsInlNaWQiLCJ5TWluIiwieU1heCIsInhNaW4iLCJ4TWF4IiwieDEiLCJ5MSIsIngyIiwieTIiLCJfc2NhbGUiLCJ4TWlkIiwiX3hNaW4iLCJfeE1heCIsIl95TWluIiwiX3lNYXgiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiY29uY2F0IiwiYyIsImNvb3JkaW5hdGVzIiwiQ29tcG9uZW50Iiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/recharts/es6/cartesian/ErrorBar.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/recharts/es6/chart/generateCategoricalChart.js":
/*!*********************************************************************!*\
  !*** ./node_modules/recharts/es6/chart/generateCategoricalChart.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDefaultState: () => (/* binding */ createDefaultState),\n/* harmony export */   generateCategoricalChart: () => (/* binding */ generateCategoricalChart),\n/* harmony export */   getAxisMapByAxes: () => (/* binding */ getAxisMapByAxes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isNil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isNil */ \"(app-pages-browser)/./node_modules/lodash/isNil.js\");\n/* harmony import */ var lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isNil__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isFunction */ \"(app-pages-browser)/./node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/range */ \"(app-pages-browser)/./node_modules/lodash/range.js\");\n/* harmony import */ var lodash_range__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_range__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/get */ \"(app-pages-browser)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/sortBy */ \"(app-pages-browser)/./node_modules/lodash/sortBy.js\");\n/* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_sortBy__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/throttle */ \"(app-pages-browser)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _container_Surface__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../container/Surface */ \"(app-pages-browser)/./node_modules/recharts/es6/container/Surface.js\");\n/* harmony import */ var _container_Layer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../container/Layer */ \"(app-pages-browser)/./node_modules/recharts/es6/container/Layer.js\");\n/* harmony import */ var _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../component/Tooltip */ \"(app-pages-browser)/./node_modules/recharts/es6/component/Tooltip.js\");\n/* harmony import */ var _component_Legend__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/Legend */ \"(app-pages-browser)/./node_modules/recharts/es6/component/Legend.js\");\n/* harmony import */ var _shape_Dot__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../shape/Dot */ \"(app-pages-browser)/./node_modules/recharts/es6/shape/Dot.js\");\n/* harmony import */ var _shape_Rectangle__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../shape/Rectangle */ \"(app-pages-browser)/./node_modules/recharts/es6/shape/Rectangle.js\");\n/* harmony import */ var _util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../util/ReactUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/ReactUtils.js\");\n/* harmony import */ var _cartesian_Brush__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../cartesian/Brush */ \"(app-pages-browser)/./node_modules/recharts/es6/cartesian/Brush.js\");\n/* harmony import */ var _util_DOMUtils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../util/DOMUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/DOMUtils.js\");\n/* harmony import */ var _util_DataUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/DataUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/DataUtils.js\");\n/* harmony import */ var _util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/ChartUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/ChartUtils.js\");\n/* harmony import */ var _util_ChartUtils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../util/ChartUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/getLegendProps.js\");\n/* harmony import */ var _util_DetectReferenceElementsDomain__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../util/DetectReferenceElementsDomain */ \"(app-pages-browser)/./node_modules/recharts/es6/util/DetectReferenceElementsDomain.js\");\n/* harmony import */ var _util_PolarUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/PolarUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/PolarUtils.js\");\n/* harmony import */ var _util_ShallowEqual__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../util/ShallowEqual */ \"(app-pages-browser)/./node_modules/recharts/es6/util/ShallowEqual.js\");\n/* harmony import */ var _util_Events__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../util/Events */ \"(app-pages-browser)/./node_modules/recharts/es6/util/Events.js\");\n/* harmony import */ var _util_types__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../util/types */ \"(app-pages-browser)/./node_modules/recharts/es6/util/types.js\");\n/* harmony import */ var _AccessibilityManager__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./AccessibilityManager */ \"(app-pages-browser)/./node_modules/recharts/es6/chart/AccessibilityManager.js\");\n/* harmony import */ var _util_isDomainSpecifiedByUser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/isDomainSpecifiedByUser */ \"(app-pages-browser)/./node_modules/recharts/es6/util/isDomainSpecifiedByUser.js\");\n/* harmony import */ var _util_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../util/ActiveShapeUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/ActiveShapeUtils.js\");\n/* harmony import */ var _component_Cursor__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/Cursor */ \"(app-pages-browser)/./node_modules/recharts/es6/component/Cursor.js\");\n/* harmony import */ var _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../context/chartLayoutContext */ \"(app-pages-browser)/./node_modules/recharts/es6/context/chartLayoutContext.js\");\nvar _excluded = [\n    \"item\"\n], _excluded2 = [\n    \"children\",\n    \"className\",\n    \"width\",\n    \"height\",\n    \"style\",\n    \"compact\",\n    \"title\",\n    \"desc\"\n];\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n        return !!t;\n    })();\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n\n\n\n\n\n\n\n\n// eslint-disable-next-line no-restricted-imports\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ORIENT_MAP = {\n    xAxis: [\n        'bottom',\n        'top'\n    ],\n    yAxis: [\n        'left',\n        'right'\n    ]\n};\nvar FULL_WIDTH_AND_HEIGHT = {\n    width: '100%',\n    height: '100%'\n};\nvar originCoordinate = {\n    x: 0,\n    y: 0\n};\n/**\n * This function exists as a temporary workaround.\n *\n * Why? generateCategoricalChart does not render `{children}` directly;\n * instead it passes them through `renderByOrder` function which reads their handlers.\n *\n * So, this is a handler that does nothing.\n * Once we get rid of `renderByOrder` and switch to JSX only, we can get rid of this handler too.\n *\n * @param {JSX} element as is in JSX\n * @returns {JSX} the same element\n */ function renderAsIs(element) {\n    return element;\n}\nvar calculateTooltipPos = function calculateTooltipPos(rangeObj, layout) {\n    if (layout === 'horizontal') {\n        return rangeObj.x;\n    }\n    if (layout === 'vertical') {\n        return rangeObj.y;\n    }\n    if (layout === 'centric') {\n        return rangeObj.angle;\n    }\n    return rangeObj.radius;\n};\nvar getActiveCoordinate = function getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj) {\n    var entry = tooltipTicks.find(function(tick) {\n        return tick && tick.index === activeIndex;\n    });\n    if (entry) {\n        if (layout === 'horizontal') {\n            return {\n                x: entry.coordinate,\n                y: rangeObj.y\n            };\n        }\n        if (layout === 'vertical') {\n            return {\n                x: rangeObj.x,\n                y: entry.coordinate\n            };\n        }\n        if (layout === 'centric') {\n            var _angle = entry.coordinate;\n            var _radius = rangeObj.radius;\n            return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), (0,_util_PolarUtils__WEBPACK_IMPORTED_MODULE_9__.polarToCartesian)(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {\n                angle: _angle,\n                radius: _radius\n            });\n        }\n        var radius = entry.coordinate;\n        var angle = rangeObj.angle;\n        return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), (0,_util_PolarUtils__WEBPACK_IMPORTED_MODULE_9__.polarToCartesian)(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {\n            angle: angle,\n            radius: radius\n        });\n    }\n    return originCoordinate;\n};\nvar getDisplayedData = function getDisplayedData(data, _ref) {\n    var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;\n    var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function(result, child) {\n        var itemData = child.props.data;\n        if (itemData && itemData.length) {\n            return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));\n        }\n        return result;\n    }, []);\n    if (itemsData.length > 0) {\n        return itemsData;\n    }\n    if (data && data.length && (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.isNumber)(dataStartIndex) && (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.isNumber)(dataEndIndex)) {\n        return data.slice(dataStartIndex, dataEndIndex + 1);\n    }\n    return [];\n};\nfunction getDefaultDomainByAxisType(axisType) {\n    return axisType === 'number' ? [\n        0,\n        'auto'\n    ] : undefined;\n}\n/**\n * Get the content to be displayed in the tooltip\n * @param  {Object} state          Current state\n * @param  {Array}  chartData      The data defined in chart\n * @param  {Number} activeIndex    Active index of data\n * @param  {String} activeLabel    Active label of data\n * @return {Array}                 The content of tooltip\n */ var getTooltipContent = function getTooltipContent(state, chartData, activeIndex, activeLabel) {\n    var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;\n    var displayedData = getDisplayedData(chartData, state);\n    if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {\n        return null;\n    }\n    // get data by activeIndex when the axis don't allow duplicated category\n    return graphicalItems.reduce(function(result, child) {\n        var _child$props$data;\n        /**\n     * Fixes: https://github.com/recharts/recharts/issues/3669\n     * Defaulting to chartData below to fix an edge case where the tooltip does not include data from all charts\n     * when a separate dataset is passed to chart prop data and specified on Line/Area/etc prop data\n     */ var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;\n        if (data && state.dataStartIndex + state.dataEndIndex !== 0 && // https://github.com/recharts/recharts/issues/4717\n        // The data is sliced only when the active index is within the start/end index range.\n        state.dataEndIndex - state.dataStartIndex >= activeIndex) {\n            data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);\n        }\n        var payload;\n        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {\n            // graphic child has data props\n            var entries = data === undefined ? displayedData : data;\n            payload = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.findEntryInArray)(entries, tooltipAxis.dataKey, activeLabel);\n        } else {\n            payload = data && data[activeIndex] || displayedData[activeIndex];\n        }\n        if (!payload) {\n            return result;\n        }\n        return [].concat(_toConsumableArray(result), [\n            (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getTooltipItem)(child, payload)\n        ]);\n    }, []);\n};\n/**\n * Returns tooltip data based on a mouse position (as a parameter or in state)\n * @param  {Object} state     current state\n * @param  {Array}  chartData the data defined in chart\n * @param  {String} layout     The layout type of chart\n * @param  {Object} rangeObj  { x, y } coordinates\n * @return {Object}           Tooltip data data\n */ var getTooltipData = function getTooltipData(state, chartData, layout, rangeObj) {\n    var rangeData = rangeObj || {\n        x: state.chartX,\n        y: state.chartY\n    };\n    var pos = calculateTooltipPos(rangeData, layout);\n    var ticks = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;\n    var activeIndex = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.calculateActiveTickIndex)(pos, ticks, tooltipTicks, axis);\n    if (activeIndex >= 0 && tooltipTicks) {\n        var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;\n        var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);\n        var activeCoordinate = getActiveCoordinate(layout, ticks, activeIndex, rangeData);\n        return {\n            activeTooltipIndex: activeIndex,\n            activeLabel: activeLabel,\n            activePayload: activePayload,\n            activeCoordinate: activeCoordinate\n        };\n    }\n    return null;\n};\n/**\n * Get the configuration of axis by the options of axis instance\n * @param  {Object} props         Latest props\n * @param {Array}  axes           The instance of axes\n * @param  {Array} graphicalItems The instances of item\n * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\n * @param  {String} axisIdKey     The unique id of an axis\n * @param  {Object} stackGroups   The items grouped by axisId and stackId\n * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\n * @return {Object}      Configuration\n */ var getAxisMapByAxes = function getAxisMapByAxes(props, _ref2) {\n    var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;\n    var layout = props.layout, children = props.children, stackOffset = props.stackOffset;\n    var isCategorical = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.isCategoricalAxis)(layout, axisType);\n    // Eliminate duplicated axes\n    return axes.reduce(function(result, child) {\n        var _childProps$domain2;\n        var childProps = child.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;\n        var type = childProps.type, dataKey = childProps.dataKey, allowDataOverflow = childProps.allowDataOverflow, allowDuplicatedCategory = childProps.allowDuplicatedCategory, scale = childProps.scale, ticks = childProps.ticks, includeHidden = childProps.includeHidden;\n        var axisId = childProps[axisIdKey];\n        if (result[axisId]) {\n            return result;\n        }\n        var displayedData = getDisplayedData(props.data, {\n            graphicalItems: graphicalItems.filter(function(item) {\n                var _defaultProps;\n                var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps = item.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps[axisIdKey];\n                return itemAxisId === axisId;\n            }),\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n        var len = displayedData.length;\n        var domain, duplicateDomain, categoricalDomain;\n        /*\n     * This is a hack to short-circuit the domain creation here to enhance performance.\n     * Usually, the data is used to determine the domain, but when the user specifies\n     * a domain upfront (via props), there is no need to calculate the domain start and end,\n     * which is very expensive for a larger amount of data.\n     * The only thing that would prohibit short-circuiting is when the user doesn't allow data overflow,\n     * because the axis is supposed to ignore the specified domain that way.\n     */ if ((0,_util_isDomainSpecifiedByUser__WEBPACK_IMPORTED_MODULE_12__.isDomainSpecifiedByUser)(childProps.domain, allowDataOverflow, type)) {\n            domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.parseSpecifiedDomain)(childProps.domain, null, allowDataOverflow);\n            /* The chart can be categorical and have the domain specified in numbers\n       * we still need to calculate the categorical domain\n       * TODO: refactor this more\n       */ if (isCategorical && (type === 'number' || scale !== 'auto')) {\n                categoricalDomain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfDataByKey)(displayedData, dataKey, 'category');\n            }\n        }\n        // if the domain is defaulted we need this for `originalDomain` as well\n        var defaultDomain = getDefaultDomainByAxisType(type);\n        // we didn't create the domain from user's props above, so we need to calculate it\n        if (!domain || domain.length === 0) {\n            var _childProps$domain;\n            var childDomain = (_childProps$domain = childProps.domain) !== null && _childProps$domain !== void 0 ? _childProps$domain : defaultDomain;\n            if (dataKey) {\n                // has dataKey in <Axis />\n                domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfDataByKey)(displayedData, dataKey, type);\n                if (type === 'category' && isCategorical) {\n                    // the field type is category data and this axis is categorical axis\n                    var duplicate = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.hasDuplicate)(domain);\n                    if (allowDuplicatedCategory && duplicate) {\n                        duplicateDomain = domain;\n                        // When category axis has duplicated text, serial numbers are used to generate scale\n                        domain = lodash_range__WEBPACK_IMPORTED_MODULE_3___default()(0, len);\n                    } else if (!allowDuplicatedCategory) {\n                        // remove duplicated category\n                        domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.parseDomainOfCategoryAxis)(childDomain, domain, child).reduce(function(finalDomain, entry) {\n                            return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [\n                                entry\n                            ]);\n                        }, []);\n                    }\n                } else if (type === 'category') {\n                    // the field type is category data and this axis is numerical axis\n                    if (!allowDuplicatedCategory) {\n                        domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.parseDomainOfCategoryAxis)(childDomain, domain, child).reduce(function(finalDomain, entry) {\n                            return finalDomain.indexOf(entry) >= 0 || entry === '' || lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default()(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [\n                                entry\n                            ]);\n                        }, []);\n                    } else {\n                        // eliminate undefined or null or empty string\n                        domain = domain.filter(function(entry) {\n                            return entry !== '' && !lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default()(entry);\n                        });\n                    }\n                } else if (type === 'number') {\n                    // the field type is numerical\n                    var errorBarsDomain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.parseErrorBarsOfAxis)(displayedData, graphicalItems.filter(function(item) {\n                        var _defaultProps2, _defaultProps3;\n                        var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps2 = item.type.defaultProps) === null || _defaultProps2 === void 0 ? void 0 : _defaultProps2[axisIdKey];\n                        var itemHide = 'hide' in item.props ? item.props.hide : (_defaultProps3 = item.type.defaultProps) === null || _defaultProps3 === void 0 ? void 0 : _defaultProps3.hide;\n                        return itemAxisId === axisId && (includeHidden || !itemHide);\n                    }), dataKey, axisType, layout);\n                    if (errorBarsDomain) {\n                        domain = errorBarsDomain;\n                    }\n                }\n                if (isCategorical && (type === 'number' || scale !== 'auto')) {\n                    categoricalDomain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfDataByKey)(displayedData, dataKey, 'category');\n                }\n            } else if (isCategorical) {\n                // the axis is a categorical axis\n                domain = lodash_range__WEBPACK_IMPORTED_MODULE_3___default()(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === 'number') {\n                // when stackOffset is 'expand', the domain may be calculated as [0, 1.000000000002]\n                domain = stackOffset === 'expand' ? [\n                    0,\n                    1\n                ] : (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n            } else {\n                domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {\n                    var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : item.type.defaultProps[axisIdKey];\n                    var itemHide = 'hide' in item.props ? item.props.hide : item.type.defaultProps.hide;\n                    return itemAxisId === axisId && (includeHidden || !itemHide);\n                }), type, layout, true);\n            }\n            if (type === 'number') {\n                // To detect wether there is any reference lines whose props alwaysShow is true\n                domain = (0,_util_DetectReferenceElementsDomain__WEBPACK_IMPORTED_MODULE_13__.detectReferenceElementsDomain)(children, domain, axisId, axisType, ticks);\n                if (childDomain) {\n                    domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.parseSpecifiedDomain)(childDomain, domain, allowDataOverflow);\n                }\n            } else if (type === 'category' && childDomain) {\n                var axisDomain = childDomain;\n                var isDomainValid = domain.every(function(entry) {\n                    return axisDomain.indexOf(entry) >= 0;\n                });\n                if (isDomainValid) {\n                    domain = axisDomain;\n                }\n            }\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, childProps), {}, {\n            axisType: axisType,\n            domain: domain,\n            categoricalDomain: categoricalDomain,\n            duplicateDomain: duplicateDomain,\n            originalDomain: (_childProps$domain2 = childProps.domain) !== null && _childProps$domain2 !== void 0 ? _childProps$domain2 : defaultDomain,\n            isCategorical: isCategorical,\n            layout: layout\n        })));\n    }, {});\n};\n/**\n * Get the configuration of axis by the options of item,\n * this kind of axis does not display in chart\n * @param  {Object} props         Latest props\n * @param  {Array} graphicalItems The instances of item\n * @param  {ReactElement} Axis    Axis Component\n * @param  {String} axisType      The type of axis, xAxis - x-axis, yAxis - y-axis\n * @param  {String} axisIdKey     The unique id of an axis\n * @param  {Object} stackGroups   The items grouped by axisId and stackId\n * @param {Number} dataStartIndex The start index of the data series when a brush is applied\n * @param {Number} dataEndIndex   The end index of the data series when a brush is applied\n * @return {Object}               Configuration\n */ var getAxisMapByItems = function getAxisMapByItems(props, _ref3) {\n    var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;\n    var layout = props.layout, children = props.children;\n    var displayedData = getDisplayedData(props.data, {\n        graphicalItems: graphicalItems,\n        dataStartIndex: dataStartIndex,\n        dataEndIndex: dataEndIndex\n    });\n    var len = displayedData.length;\n    var isCategorical = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.isCategoricalAxis)(layout, axisType);\n    var index = -1;\n    // The default type of x-axis is category axis,\n    // The default contents of x-axis is the serial numbers of data\n    // The default type of y-axis is number axis\n    // The default contents of y-axis is the domain of data\n    return graphicalItems.reduce(function(result, child) {\n        var childProps = child.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;\n        var axisId = childProps[axisIdKey];\n        var originalDomain = getDefaultDomainByAxisType('number');\n        if (!result[axisId]) {\n            index++;\n            var domain;\n            if (isCategorical) {\n                domain = lodash_range__WEBPACK_IMPORTED_MODULE_3___default()(0, len);\n            } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {\n                domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);\n                domain = (0,_util_DetectReferenceElementsDomain__WEBPACK_IMPORTED_MODULE_13__.detectReferenceElementsDomain)(children, domain, axisId, axisType);\n            } else {\n                domain = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.parseSpecifiedDomain)(originalDomain, (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {\n                    var _defaultProps4, _defaultProps5;\n                    var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps4 = item.type.defaultProps) === null || _defaultProps4 === void 0 ? void 0 : _defaultProps4[axisIdKey];\n                    var itemHide = 'hide' in item.props ? item.props.hide : (_defaultProps5 = item.type.defaultProps) === null || _defaultProps5 === void 0 ? void 0 : _defaultProps5.hide;\n                    return itemAxisId === axisId && !itemHide;\n                }), 'number', layout), Axis.defaultProps.allowDataOverflow);\n                domain = (0,_util_DetectReferenceElementsDomain__WEBPACK_IMPORTED_MODULE_13__.detectReferenceElementsDomain)(children, domain, axisId, axisType);\n            }\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({\n                axisType: axisType\n            }, Axis.defaultProps), {}, {\n                hide: true,\n                orientation: lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(ORIENT_MAP, \"\".concat(axisType, \".\").concat(index % 2), null),\n                domain: domain,\n                originalDomain: originalDomain,\n                isCategorical: isCategorical,\n                layout: layout\n            })));\n        }\n        return result;\n    }, {});\n};\n/**\n * Get the configuration of all x-axis or y-axis\n * @param  {Object} props          Latest props\n * @param  {String} axisType       The type of axis\n * @param  {React.ComponentType}  [AxisComp]      Axis Component\n * @param  {Array}  graphicalItems The instances of item\n * @param  {Object} stackGroups    The items grouped by axisId and stackId\n * @param {Number} dataStartIndex  The start index of the data series when a brush is applied\n * @param {Number} dataEndIndex    The end index of the data series when a brush is applied\n * @return {Object}          Configuration\n */ var getAxisMap = function getAxisMap(props, _ref4) {\n    var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? 'xAxis' : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;\n    var children = props.children;\n    var axisIdKey = \"\".concat(axisType, \"Id\");\n    // Get all the instance of Axis\n    var axes = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findAllByType)(children, AxisComp);\n    var axisMap = {};\n    if (axes && axes.length) {\n        axisMap = getAxisMapByAxes(props, {\n            axes: axes,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n    } else if (graphicalItems && graphicalItems.length) {\n        axisMap = getAxisMapByItems(props, {\n            Axis: AxisComp,\n            graphicalItems: graphicalItems,\n            axisType: axisType,\n            axisIdKey: axisIdKey,\n            stackGroups: stackGroups,\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex\n        });\n    }\n    return axisMap;\n};\nvar tooltipTicksGenerator = function tooltipTicksGenerator(axisMap) {\n    var axis = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.getAnyElementOfObject)(axisMap);\n    var tooltipTicks = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getTicksOfAxis)(axis, false, true);\n    return {\n        tooltipTicks: tooltipTicks,\n        orderedTooltipTicks: lodash_sortBy__WEBPACK_IMPORTED_MODULE_5___default()(tooltipTicks, function(o) {\n            return o.coordinate;\n        }),\n        tooltipAxis: axis,\n        tooltipAxisBandSize: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getBandSizeOfAxis)(axis, tooltipTicks)\n    };\n};\n/**\n * Returns default, reset state for the categorical chart.\n * @param {Object} props Props object to use when creating the default state\n * @return {Object} Whole new state\n */ var createDefaultState = function createDefaultState(props) {\n    var children = props.children, defaultShowTooltip = props.defaultShowTooltip;\n    var brushItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _cartesian_Brush__WEBPACK_IMPORTED_MODULE_15__.Brush);\n    var startIndex = 0;\n    var endIndex = 0;\n    if (props.data && props.data.length !== 0) {\n        endIndex = props.data.length - 1;\n    }\n    if (brushItem && brushItem.props) {\n        if (brushItem.props.startIndex >= 0) {\n            startIndex = brushItem.props.startIndex;\n        }\n        if (brushItem.props.endIndex >= 0) {\n            endIndex = brushItem.props.endIndex;\n        }\n    }\n    return {\n        chartX: 0,\n        chartY: 0,\n        dataStartIndex: startIndex,\n        dataEndIndex: endIndex,\n        activeTooltipIndex: -1,\n        isTooltipActive: Boolean(defaultShowTooltip)\n    };\n};\nvar hasGraphicalBarItem = function hasGraphicalBarItem(graphicalItems) {\n    if (!graphicalItems || !graphicalItems.length) {\n        return false;\n    }\n    return graphicalItems.some(function(item) {\n        var name = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.getDisplayName)(item && item.type);\n        return name && name.indexOf('Bar') >= 0;\n    });\n};\nvar getAxisNameByLayout = function getAxisNameByLayout(layout) {\n    if (layout === 'horizontal') {\n        return {\n            numericAxisName: 'yAxis',\n            cateAxisName: 'xAxis'\n        };\n    }\n    if (layout === 'vertical') {\n        return {\n            numericAxisName: 'xAxis',\n            cateAxisName: 'yAxis'\n        };\n    }\n    if (layout === 'centric') {\n        return {\n            numericAxisName: 'radiusAxis',\n            cateAxisName: 'angleAxis'\n        };\n    }\n    return {\n        numericAxisName: 'angleAxis',\n        cateAxisName: 'radiusAxis'\n    };\n};\n/**\n * Calculate the offset of main part in the svg element\n * @param  {Object} params.props          Latest props\n * @param  {Array}  params.graphicalItems The instances of item\n * @param  {Object} params.xAxisMap       The configuration of x-axis\n * @param  {Object} params.yAxisMap       The configuration of y-axis\n * @param  {Object} prevLegendBBox        The boundary box of legend\n * @return {Object} The offset of main part in the svg element\n */ var calculateOffset = function calculateOffset(_ref5, prevLegendBBox) {\n    var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;\n    var width = props.width, height = props.height, children = props.children;\n    var margin = props.margin || {};\n    var brushItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _cartesian_Brush__WEBPACK_IMPORTED_MODULE_15__.Brush);\n    var legendItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _component_Legend__WEBPACK_IMPORTED_MODULE_16__.Legend);\n    var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {\n        var entry = yAxisMap[id];\n        var orientation = entry.orientation;\n        if (!entry.mirror && !entry.hide) {\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));\n        }\n        return result;\n    }, {\n        left: margin.left || 0,\n        right: margin.right || 0\n    });\n    var offsetV = Object.keys(xAxisMap).reduce(function(result, id) {\n        var entry = xAxisMap[id];\n        var orientation = entry.orientation;\n        if (!entry.mirror && !entry.hide) {\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(result, \"\".concat(orientation)) + entry.height));\n        }\n        return result;\n    }, {\n        top: margin.top || 0,\n        bottom: margin.bottom || 0\n    });\n    var offset = _objectSpread(_objectSpread({}, offsetV), offsetH);\n    var brushBottom = offset.bottom;\n    if (brushItem) {\n        offset.bottom += brushItem.props.height || _cartesian_Brush__WEBPACK_IMPORTED_MODULE_15__.Brush.defaultProps.height;\n    }\n    if (legendItem && prevLegendBBox) {\n        // @ts-expect-error margin is optional in props but required in appendOffsetOfLegend\n        offset = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.appendOffsetOfLegend)(offset, graphicalItems, props, prevLegendBBox);\n    }\n    var offsetWidth = width - offset.left - offset.right;\n    var offsetHeight = height - offset.top - offset.bottom;\n    return _objectSpread(_objectSpread({\n        brushBottom: brushBottom\n    }, offset), {}, {\n        // never return negative values for height and width\n        width: Math.max(offsetWidth, 0),\n        height: Math.max(offsetHeight, 0)\n    });\n};\n// Determine the size of the axis, used for calculation of relative bar sizes\nvar getCartesianAxisSize = function getCartesianAxisSize(axisObj, axisName) {\n    if (axisName === 'xAxis') {\n        return axisObj[axisName].width;\n    }\n    if (axisName === 'yAxis') {\n        return axisObj[axisName].height;\n    }\n    // This is only supported for Bar charts (i.e. charts with cartesian axes), so we should never get here\n    return undefined;\n};\nvar generateCategoricalChart = function generateCategoricalChart(_ref6) {\n    var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? 'axis' : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? [\n        'axis'\n    ] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap = _ref6.formatAxisMap, defaultProps = _ref6.defaultProps;\n    var getFormatItems = function getFormatItems(props, currentState) {\n        var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;\n        var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;\n        var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;\n        var hasBar = hasGraphicalBarItem(graphicalItems);\n        var formattedItems = [];\n        graphicalItems.forEach(function(item, index) {\n            var displayedData = getDisplayedData(props.data, {\n                graphicalItems: [\n                    item\n                ],\n                dataStartIndex: dataStartIndex,\n                dataEndIndex: dataEndIndex\n            });\n            var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n            var dataKey = itemProps.dataKey, childMaxBarSize = itemProps.maxBarSize;\n            // axisId of the numerical axis\n            var numericAxisId = itemProps[\"\".concat(numericAxisName, \"Id\")];\n            // axisId of the categorical axis\n            var cateAxisId = itemProps[\"\".concat(cateAxisName, \"Id\")];\n            var axisObjInitialValue = {};\n            var axisObj = axisComponents.reduce(function(result, entry) {\n                var _item$type$displayNam, _item$type;\n                // map of axisId to axis for a specific axis type\n                var axisMap = currentState[\"\".concat(entry.axisType, \"Map\")];\n                // axisId of axis we are currently computing\n                var id = itemProps[\"\".concat(entry.axisType, \"Id\")];\n                /**\n         * tell the user in dev mode that their configuration is incorrect if we cannot find a match between\n         * axisId on the chart and axisId on the axis. zAxis does not get passed in the map for ComposedChart,\n         * leave it out of the check for now.\n         */ !(axisMap && axisMap[id] || entry.axisType === 'zAxis') ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(false, \"Specifying a(n) \".concat(entry.axisType, \"Id requires a corresponding \").concat(entry.axisType, \"Id on the targeted graphical component \").concat((_item$type$displayNam = item === null || item === void 0 || (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) !== null && _item$type$displayNam !== void 0 ? _item$type$displayNam : '')) : 0 : void 0;\n                // the axis we are currently formatting\n                var axis = axisMap[id];\n                return _objectSpread(_objectSpread({}, result), {}, _defineProperty(_defineProperty({}, entry.axisType, axis), \"\".concat(entry.axisType, \"Ticks\"), (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getTicksOfAxis)(axis)));\n            }, axisObjInitialValue);\n            var cateAxis = axisObj[cateAxisName];\n            var cateTicks = axisObj[\"\".concat(cateAxisName, \"Ticks\")];\n            var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getStackedDataOfItem)(item, stackGroups[numericAxisId].stackGroups);\n            var itemIsBar = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.getDisplayName)(item.type).indexOf('Bar') >= 0;\n            var bandSize = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getBandSizeOfAxis)(cateAxis, cateTicks);\n            var barPosition = [];\n            var sizeList = hasBar && (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getBarSizeList)({\n                barSize: barSize,\n                stackGroups: stackGroups,\n                totalSize: getCartesianAxisSize(axisObj, cateAxisName)\n            });\n            if (itemIsBar) {\n                var _ref7, _getBandSizeOfAxis;\n                // If it is bar, calculate the position of bar\n                var maxBarSize = lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default()(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;\n                var barBandSize = (_ref7 = (_getBandSizeOfAxis = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getBandSizeOfAxis)(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;\n                barPosition = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getBarPosition)({\n                    barGap: barGap,\n                    barCategoryGap: barCategoryGap,\n                    bandSize: barBandSize !== bandSize ? barBandSize : bandSize,\n                    sizeList: sizeList[cateAxisId],\n                    maxBarSize: maxBarSize\n                });\n                if (barBandSize !== bandSize) {\n                    barPosition = barPosition.map(function(pos) {\n                        return _objectSpread(_objectSpread({}, pos), {}, {\n                            position: _objectSpread(_objectSpread({}, pos.position), {}, {\n                                offset: pos.position.offset - barBandSize / 2\n                            })\n                        });\n                    });\n                }\n            }\n            // @ts-expect-error we should stop reading data from ReactElements\n            var composedFn = item && item.type && item.type.getComposedData;\n            if (composedFn) {\n                formattedItems.push({\n                    props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {\n                        displayedData: displayedData,\n                        props: props,\n                        dataKey: dataKey,\n                        item: item,\n                        bandSize: bandSize,\n                        barPosition: barPosition,\n                        offset: offset,\n                        stackedData: stackedData,\n                        layout: layout,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex\n                    }))), {}, _defineProperty(_defineProperty(_defineProperty({\n                        key: item.key || \"item-\".concat(index)\n                    }, numericAxisName, axisObj[numericAxisName]), cateAxisName, axisObj[cateAxisName]), \"animationId\", updateId)),\n                    childIndex: (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.parseChildIndex)(item, props.children),\n                    item: item\n                });\n            }\n        });\n        return formattedItems;\n    };\n    /**\n   * The AxisMaps are expensive to render on large data sets\n   * so provide the ability to store them in state and only update them when necessary\n   * they are dependent upon the start and end index of\n   * the brush so it's important that this method is called _after_\n   * the state is updated with any new start/end indices\n   *\n   * @param {Object} props          The props object to be used for updating the axismaps\n   * dataStartIndex: The start index of the data series when a brush is applied\n   * dataEndIndex: The end index of the data series when a brush is applied\n   * updateId: The update id\n   * @param {Object} prevState      Prev state\n   * @return {Object} state New state to set\n   */ var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups(_ref8, prevState) {\n        var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;\n        if (!(0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.validateWidthHeight)({\n            props: props\n        })) {\n            return null;\n        }\n        var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;\n        var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;\n        var graphicalItems = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findAllByType)(children, GraphicalChild);\n        var stackGroups = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getStackGroupsByAxisId)(data, graphicalItems, \"\".concat(numericAxisName, \"Id\"), \"\".concat(cateAxisName, \"Id\"), stackOffset, reverseStackOrder);\n        var axisObj = axisComponents.reduce(function(result, entry) {\n            var name = \"\".concat(entry.axisType, \"Map\");\n            return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {\n                graphicalItems: graphicalItems,\n                stackGroups: entry.axisType === numericAxisName && stackGroups,\n                dataStartIndex: dataStartIndex,\n                dataEndIndex: dataEndIndex\n            }))));\n        }, {});\n        var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {\n            props: props,\n            graphicalItems: graphicalItems\n        }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);\n        Object.keys(axisObj).forEach(function(key) {\n            axisObj[key] = formatAxisMap(props, axisObj[key], offset, key.replace('Map', ''), chartName);\n        });\n        var cateAxisMap = axisObj[\"\".concat(cateAxisName, \"Map\")];\n        var ticksObj = tooltipTicksGenerator(cateAxisMap);\n        var formattedGraphicalItems = getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {\n            dataStartIndex: dataStartIndex,\n            dataEndIndex: dataEndIndex,\n            updateId: updateId,\n            graphicalItems: graphicalItems,\n            stackGroups: stackGroups,\n            offset: offset\n        }));\n        return _objectSpread(_objectSpread({\n            formattedGraphicalItems: formattedGraphicalItems,\n            graphicalItems: graphicalItems,\n            offset: offset,\n            stackGroups: stackGroups\n        }, ticksObj), axisObj);\n    };\n    var CategoricalChartWrapper = /*#__PURE__*/ function(_Component) {\n        function CategoricalChartWrapper(_props) {\n            var _props$id, _props$throttleDelay;\n            var _this;\n            _classCallCheck(this, CategoricalChartWrapper);\n            _this = _callSuper(this, CategoricalChartWrapper, [\n                _props\n            ]);\n            _defineProperty(_this, \"eventEmitterSymbol\", Symbol('rechartsEventEmitter'));\n            _defineProperty(_this, \"accessibilityManager\", new _AccessibilityManager__WEBPACK_IMPORTED_MODULE_17__.AccessibilityManager());\n            _defineProperty(_this, \"handleLegendBBoxUpdate\", function(box) {\n                if (box) {\n                    var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;\n                    _this.setState(_objectSpread({\n                        legendBBox: box\n                    }, updateStateOfAxisMapsOffsetAndStackGroups({\n                        props: _this.props,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex,\n                        updateId: updateId\n                    }, _objectSpread(_objectSpread({}, _this.state), {}, {\n                        legendBBox: box\n                    }))));\n                }\n            });\n            _defineProperty(_this, \"handleReceiveSyncEvent\", function(cId, data, emitter) {\n                if (_this.props.syncId === cId) {\n                    if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== 'function') {\n                        return;\n                    }\n                    _this.applySyncEvent(data);\n                }\n            });\n            _defineProperty(_this, \"handleBrushChange\", function(_ref9) {\n                var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;\n                // Only trigger changes if the extents of the brush have actually changed\n                if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {\n                    var updateId = _this.state.updateId;\n                    _this.setState(function() {\n                        return _objectSpread({\n                            dataStartIndex: startIndex,\n                            dataEndIndex: endIndex\n                        }, updateStateOfAxisMapsOffsetAndStackGroups({\n                            props: _this.props,\n                            dataStartIndex: startIndex,\n                            dataEndIndex: endIndex,\n                            updateId: updateId\n                        }, _this.state));\n                    });\n                    _this.triggerSyncEvent({\n                        dataStartIndex: startIndex,\n                        dataEndIndex: endIndex\n                    });\n                }\n            });\n            /**\n       * The handler of mouse entering chart\n       * @param  {Object} e              Event object\n       * @return {Null}                  null\n       */ _defineProperty(_this, \"handleMouseEnter\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                if (mouse) {\n                    var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {\n                        isTooltipActive: true\n                    });\n                    _this.setState(_nextState);\n                    _this.triggerSyncEvent(_nextState);\n                    var onMouseEnter = _this.props.onMouseEnter;\n                    if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(onMouseEnter)) {\n                        onMouseEnter(_nextState, e);\n                    }\n                }\n            });\n            _defineProperty(_this, \"triggeredAfterMouseMove\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {\n                    isTooltipActive: true\n                }) : {\n                    isTooltipActive: false\n                };\n                _this.setState(nextState);\n                _this.triggerSyncEvent(nextState);\n                var onMouseMove = _this.props.onMouseMove;\n                if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(onMouseMove)) {\n                    onMouseMove(nextState, e);\n                }\n            });\n            /**\n       * The handler of mouse entering a scatter\n       * @param {Object} el The active scatter\n       * @return {Object} no return\n       */ _defineProperty(_this, \"handleItemMouseEnter\", function(el) {\n                _this.setState(function() {\n                    return {\n                        isTooltipActive: true,\n                        activeItem: el,\n                        activePayload: el.tooltipPayload,\n                        activeCoordinate: el.tooltipPosition || {\n                            x: el.cx,\n                            y: el.cy\n                        }\n                    };\n                });\n            });\n            /**\n       * The handler of mouse leaving a scatter\n       * @return {Object} no return\n       */ _defineProperty(_this, \"handleItemMouseLeave\", function() {\n                _this.setState(function() {\n                    return {\n                        isTooltipActive: false\n                    };\n                });\n            });\n            /**\n       * The handler of mouse moving in chart\n       * @param  {React.MouseEvent} e        Event object\n       * @return {void} no return\n       */ _defineProperty(_this, \"handleMouseMove\", function(e) {\n                e.persist();\n                _this.throttleTriggeredAfterMouseMove(e);\n            });\n            /**\n       * The handler if mouse leaving chart\n       * @param {Object} e Event object\n       * @return {Null} no return\n       */ _defineProperty(_this, \"handleMouseLeave\", function(e) {\n                _this.throttleTriggeredAfterMouseMove.cancel();\n                var nextState = {\n                    isTooltipActive: false\n                };\n                _this.setState(nextState);\n                _this.triggerSyncEvent(nextState);\n                var onMouseLeave = _this.props.onMouseLeave;\n                if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(onMouseLeave)) {\n                    onMouseLeave(nextState, e);\n                }\n            });\n            _defineProperty(_this, \"handleOuterEvent\", function(e) {\n                var eventName = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.getReactEventByType)(e);\n                var event = lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(_this.props, \"\".concat(eventName));\n                if (eventName && lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(event)) {\n                    var _mouse;\n                    var mouse;\n                    if (/.*touch.*/i.test(eventName)) {\n                        mouse = _this.getMouseInfo(e.changedTouches[0]);\n                    } else {\n                        mouse = _this.getMouseInfo(e);\n                    }\n                    event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);\n                }\n            });\n            _defineProperty(_this, \"handleClick\", function(e) {\n                var mouse = _this.getMouseInfo(e);\n                if (mouse) {\n                    var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {\n                        isTooltipActive: true\n                    });\n                    _this.setState(_nextState2);\n                    _this.triggerSyncEvent(_nextState2);\n                    var onClick = _this.props.onClick;\n                    if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(onClick)) {\n                        onClick(_nextState2, e);\n                    }\n                }\n            });\n            _defineProperty(_this, \"handleMouseDown\", function(e) {\n                var onMouseDown = _this.props.onMouseDown;\n                if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(onMouseDown)) {\n                    var _nextState3 = _this.getMouseInfo(e);\n                    onMouseDown(_nextState3, e);\n                }\n            });\n            _defineProperty(_this, \"handleMouseUp\", function(e) {\n                var onMouseUp = _this.props.onMouseUp;\n                if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(onMouseUp)) {\n                    var _nextState4 = _this.getMouseInfo(e);\n                    onMouseUp(_nextState4, e);\n                }\n            });\n            _defineProperty(_this, \"handleTouchMove\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleTouchStart\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.handleMouseDown(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"handleTouchEnd\", function(e) {\n                if (e.changedTouches != null && e.changedTouches.length > 0) {\n                    _this.handleMouseUp(e.changedTouches[0]);\n                }\n            });\n            _defineProperty(_this, \"triggerSyncEvent\", function(data) {\n                if (_this.props.syncId !== undefined) {\n                    _util_Events__WEBPACK_IMPORTED_MODULE_18__.eventCenter.emit(_util_Events__WEBPACK_IMPORTED_MODULE_18__.SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);\n                }\n            });\n            _defineProperty(_this, \"applySyncEvent\", function(data) {\n                var _this$props = _this.props, layout = _this$props.layout, syncMethod = _this$props.syncMethod;\n                var updateId = _this.state.updateId;\n                var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;\n                if (data.dataStartIndex !== undefined || data.dataEndIndex !== undefined) {\n                    _this.setState(_objectSpread({\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex\n                    }, updateStateOfAxisMapsOffsetAndStackGroups({\n                        props: _this.props,\n                        dataStartIndex: dataStartIndex,\n                        dataEndIndex: dataEndIndex,\n                        updateId: updateId\n                    }, _this.state)));\n                } else if (data.activeTooltipIndex !== undefined) {\n                    var chartX = data.chartX, chartY = data.chartY;\n                    var activeTooltipIndex = data.activeTooltipIndex;\n                    var _this$state2 = _this.state, offset = _this$state2.offset, tooltipTicks = _this$state2.tooltipTicks;\n                    if (!offset) {\n                        return;\n                    }\n                    if (typeof syncMethod === 'function') {\n                        // Call a callback function. If there is an application specific algorithm\n                        activeTooltipIndex = syncMethod(tooltipTicks, data);\n                    } else if (syncMethod === 'value') {\n                        // Set activeTooltipIndex to the index with the same value as data.activeLabel\n                        // For loop instead of findIndex because the latter is very slow in some browsers\n                        activeTooltipIndex = -1; // in case we cannot find the element\n                        for(var i = 0; i < tooltipTicks.length; i++){\n                            if (tooltipTicks[i].value === data.activeLabel) {\n                                activeTooltipIndex = i;\n                                break;\n                            }\n                        }\n                    }\n                    var viewBox = _objectSpread(_objectSpread({}, offset), {}, {\n                        x: offset.left,\n                        y: offset.top\n                    });\n                    // When a categorical chart is combined with another chart, the value of chartX\n                    // and chartY may beyond the boundaries.\n                    var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);\n                    var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);\n                    var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;\n                    var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);\n                    var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {\n                        x: layout === 'horizontal' ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,\n                        y: layout === 'horizontal' ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate\n                    } : originCoordinate;\n                    _this.setState(_objectSpread(_objectSpread({}, data), {}, {\n                        activeLabel: activeLabel,\n                        activeCoordinate: activeCoordinate,\n                        activePayload: activePayload,\n                        activeTooltipIndex: activeTooltipIndex\n                    }));\n                } else {\n                    _this.setState(data);\n                }\n            });\n            _defineProperty(_this, \"renderCursor\", function(element) {\n                var _element$props$active;\n                var _this$state3 = _this.state, isTooltipActive = _this$state3.isTooltipActive, activeCoordinate = _this$state3.activeCoordinate, activePayload = _this$state3.activePayload, offset = _this$state3.offset, activeTooltipIndex = _this$state3.activeTooltipIndex, tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;\n                var tooltipEventType = _this.getTooltipEventType();\n                // The cursor is a part of the Tooltip, and it should be shown (by default) when the Tooltip is active.\n                var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;\n                var layout = _this.props.layout;\n                var key = element.key || '_recharts-cursor';\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_component_Cursor__WEBPACK_IMPORTED_MODULE_19__.Cursor, {\n                    key: key,\n                    activeCoordinate: activeCoordinate,\n                    activePayload: activePayload,\n                    activeTooltipIndex: activeTooltipIndex,\n                    chartName: chartName,\n                    element: element,\n                    isActive: isActive,\n                    layout: layout,\n                    offset: offset,\n                    tooltipAxisBandSize: tooltipAxisBandSize,\n                    tooltipEventType: tooltipEventType\n                });\n            });\n            _defineProperty(_this, \"renderPolarAxis\", function(element, displayName, index) {\n                var axisType = lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(element, 'type.axisType');\n                var axisMap = lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(_this.state, \"\".concat(axisType, \"Map\"));\n                var elementDefaultProps = element.type.defaultProps;\n                var elementProps = elementDefaultProps !== undefined ? _objectSpread(_objectSpread({}, elementDefaultProps), element.props) : element.props;\n                var axisOption = axisMap && axisMap[elementProps[\"\".concat(axisType, \"Id\")]];\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, _objectSpread(_objectSpread({}, axisOption), {}, {\n                    className: (0,clsx__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(axisType, axisOption.className),\n                    key: element.key || \"\".concat(displayName, \"-\").concat(index),\n                    ticks: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getTicksOfAxis)(axisOption, true)\n                }));\n            });\n            _defineProperty(_this, \"renderPolarGrid\", function(element) {\n                var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;\n                var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;\n                var radiusAxis = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.getAnyElementOfObject)(radiusAxisMap);\n                var angleAxis = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.getAnyElementOfObject)(angleAxisMap);\n                var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, {\n                    polarAngles: Array.isArray(polarAngles) ? polarAngles : (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getTicksOfAxis)(angleAxis, true).map(function(entry) {\n                        return entry.coordinate;\n                    }),\n                    polarRadius: Array.isArray(polarRadius) ? polarRadius : (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getTicksOfAxis)(radiusAxis, true).map(function(entry) {\n                        return entry.coordinate;\n                    }),\n                    cx: cx,\n                    cy: cy,\n                    innerRadius: innerRadius,\n                    outerRadius: outerRadius,\n                    key: element.key || 'polar-grid',\n                    radialLines: radialLines\n                });\n            });\n            /**\n       * Draw legend\n       * @return {ReactElement}            The instance of Legend\n       */ _defineProperty(_this, \"renderLegend\", function() {\n                var formattedGraphicalItems = _this.state.formattedGraphicalItems;\n                var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;\n                var margin = _this.props.margin || {};\n                var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n                var props = (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_20__.getLegendProps)({\n                    children: children,\n                    formattedGraphicalItems: formattedGraphicalItems,\n                    legendWidth: legendWidth,\n                    legendContent: legendContent\n                });\n                if (!props) {\n                    return null;\n                }\n                var item = props.item, otherProps = _objectWithoutProperties(props, _excluded);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(item, _objectSpread(_objectSpread({}, otherProps), {}, {\n                    chartWidth: width,\n                    chartHeight: height,\n                    margin: margin,\n                    onBBoxUpdate: _this.handleLegendBBoxUpdate\n                }));\n            });\n            /**\n       * Draw Tooltip\n       * @return {ReactElement}  The instance of Tooltip\n       */ _defineProperty(_this, \"renderTooltip\", function() {\n                var _tooltipItem$props$ac;\n                var _this$props3 = _this.props, children = _this$props3.children, accessibilityLayer = _this$props3.accessibilityLayer;\n                var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip);\n                if (!tooltipItem) {\n                    return null;\n                }\n                var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;\n                // The user can set isActive on the Tooltip,\n                // and we respect the user to enable customisation.\n                // The Tooltip is active if the user has set isActive, or if the tooltip is active due to a mouse event.\n                var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(tooltipItem, {\n                    viewBox: _objectSpread(_objectSpread({}, offset), {}, {\n                        x: offset.left,\n                        y: offset.top\n                    }),\n                    active: isActive,\n                    label: activeLabel,\n                    payload: isActive ? activePayload : [],\n                    coordinate: activeCoordinate,\n                    accessibilityLayer: accessibilityLayer\n                });\n            });\n            _defineProperty(_this, \"renderBrush\", function(element) {\n                var _this$props4 = _this.props, margin = _this$props4.margin, data = _this$props4.data;\n                var _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;\n                // TODO: update brush when children update\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, {\n                    key: element.key || '_recharts-brush',\n                    onChange: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.combineEventHandlers)(_this.handleBrushChange, element.props.onChange),\n                    data: data,\n                    x: (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.isNumber)(element.props.x) ? element.props.x : offset.left,\n                    y: (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.isNumber)(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),\n                    width: (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.isNumber)(element.props.width) ? element.props.width : offset.width,\n                    startIndex: dataStartIndex,\n                    endIndex: dataEndIndex,\n                    updateId: \"brush-\".concat(updateId)\n                });\n            });\n            _defineProperty(_this, \"renderReferenceElement\", function(element, displayName, index) {\n                if (!element) {\n                    return null;\n                }\n                var _this2 = _this, clipPathId = _this2.clipPathId;\n                var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset;\n                var elementDefaultProps = element.type.defaultProps || {};\n                var _element$props2 = element.props, _element$props2$xAxis = _element$props2.xAxisId, xAxisId = _element$props2$xAxis === void 0 ? elementDefaultProps.xAxisId : _element$props2$xAxis, _element$props2$yAxis = _element$props2.yAxisId, yAxisId = _element$props2$yAxis === void 0 ? elementDefaultProps.yAxisId : _element$props2$yAxis;\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, {\n                    key: element.key || \"\".concat(displayName, \"-\").concat(index),\n                    xAxis: xAxisMap[xAxisId],\n                    yAxis: yAxisMap[yAxisId],\n                    viewBox: {\n                        x: offset.left,\n                        y: offset.top,\n                        width: offset.width,\n                        height: offset.height\n                    },\n                    clipPathId: clipPathId\n                });\n            });\n            _defineProperty(_this, \"renderActivePoints\", function(_ref10) {\n                var item = _ref10.item, activePoint = _ref10.activePoint, basePoint = _ref10.basePoint, childIndex = _ref10.childIndex, isRange = _ref10.isRange;\n                var result = [];\n                // item is not a React Element so we don't need to resolve defaultProps.\n                var key = item.props.key;\n                var itemItemProps = item.item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;\n                var activeDot = itemItemProps.activeDot, dataKey = itemItemProps.dataKey;\n                var dotProps = _objectSpread(_objectSpread({\n                    index: childIndex,\n                    dataKey: dataKey,\n                    cx: activePoint.x,\n                    cy: activePoint.y,\n                    r: 4,\n                    fill: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.getMainColorOfGraphicItem)(item.item),\n                    strokeWidth: 2,\n                    stroke: '#fff',\n                    payload: activePoint.payload,\n                    value: activePoint.value\n                }, (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.filterProps)(activeDot, false)), (0,_util_types__WEBPACK_IMPORTED_MODULE_22__.adaptEventHandlers)(activeDot));\n                result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps, \"\".concat(key, \"-activePoint-\").concat(childIndex)));\n                if (basePoint) {\n                    result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {\n                        cx: basePoint.x,\n                        cy: basePoint.y\n                    }), \"\".concat(key, \"-basePoint-\").concat(childIndex)));\n                } else if (isRange) {\n                    result.push(null);\n                }\n                return result;\n            });\n            _defineProperty(_this, \"renderGraphicChild\", function(element, displayName, index) {\n                var item = _this.filterFormatItem(element, displayName, index);\n                if (!item) {\n                    return null;\n                }\n                var tooltipEventType = _this.getTooltipEventType();\n                var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;\n                var children = _this.props.children;\n                var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip);\n                // item is not a React Element so we don't need to resolve defaultProps\n                var _item$props = item.props, points = _item$props.points, isRange = _item$props.isRange, baseLine = _item$props.baseLine;\n                var itemItemProps = item.item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;\n                var activeDot = itemItemProps.activeDot, hide = itemItemProps.hide, activeBar = itemItemProps.activeBar, activeShape = itemItemProps.activeShape;\n                var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));\n                var itemEvents = {};\n                if (tooltipEventType !== 'axis' && tooltipItem && tooltipItem.props.trigger === 'click') {\n                    itemEvents = {\n                        onClick: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.combineEventHandlers)(_this.handleItemMouseEnter, element.props.onClick)\n                    };\n                } else if (tooltipEventType !== 'axis') {\n                    itemEvents = {\n                        onMouseLeave: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.combineEventHandlers)(_this.handleItemMouseLeave, element.props.onMouseLeave),\n                        onMouseEnter: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_11__.combineEventHandlers)(_this.handleItemMouseEnter, element.props.onMouseEnter)\n                    };\n                }\n                var graphicalItem = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, _objectSpread(_objectSpread({}, item.props), itemEvents));\n                function findWithPayload(entry) {\n                    // TODO needs to verify dataKey is Function\n                    return typeof tooltipAxis.dataKey === 'function' ? tooltipAxis.dataKey(entry.payload) : null;\n                }\n                if (hasActive) {\n                    if (activeTooltipIndex >= 0) {\n                        var activePoint, basePoint;\n                        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {\n                            // number transform to string\n                            var specifiedKey = typeof tooltipAxis.dataKey === 'function' ? findWithPayload : 'payload.'.concat(tooltipAxis.dataKey.toString());\n                            activePoint = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.findEntryInArray)(points, specifiedKey, activeLabel);\n                            basePoint = isRange && baseLine && (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.findEntryInArray)(baseLine, specifiedKey, activeLabel);\n                        } else {\n                            activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];\n                            basePoint = isRange && baseLine && baseLine[activeTooltipIndex];\n                        }\n                        if (activeShape || activeBar) {\n                            var activeIndex = element.props.activeIndex !== undefined ? element.props.activeIndex : activeTooltipIndex;\n                            return [\n                                /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {\n                                    activeIndex: activeIndex\n                                })),\n                                null,\n                                null\n                            ];\n                        }\n                        if (!lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default()(activePoint)) {\n                            return [\n                                graphicalItem\n                            ].concat(_toConsumableArray(_this.renderActivePoints({\n                                item: item,\n                                activePoint: activePoint,\n                                basePoint: basePoint,\n                                childIndex: activeTooltipIndex,\n                                isRange: isRange\n                            })));\n                        }\n                    } else {\n                        var _this$getItemByXY;\n                        /**\n             * We hit this block if consumer uses a Tooltip without XAxis and/or YAxis.\n             * In which case, this.state.activeTooltipIndex never gets set\n             * because the mouse events that trigger that value getting set never get trigged without the axis components.\n             *\n             * An example usage case is a FunnelChart\n             */ var _ref11 = (_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : {\n                            graphicalItem: graphicalItem\n                        }, _ref11$graphicalItem = _ref11.graphicalItem, _ref11$graphicalItem$ = _ref11$graphicalItem.item, xyItem = _ref11$graphicalItem$ === void 0 ? element : _ref11$graphicalItem$, childIndex = _ref11$graphicalItem.childIndex;\n                        var elementProps = _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, {\n                            activeIndex: childIndex\n                        });\n                        return [\n                            /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(xyItem, elementProps),\n                            null,\n                            null\n                        ];\n                    }\n                }\n                if (isRange) {\n                    return [\n                        graphicalItem,\n                        null,\n                        null\n                    ];\n                }\n                return [\n                    graphicalItem,\n                    null\n                ];\n            });\n            _defineProperty(_this, \"renderCustomized\", function(element, displayName, index) {\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(element, _objectSpread(_objectSpread({\n                    key: \"recharts-customized-\".concat(index)\n                }, _this.props), _this.state));\n            });\n            _defineProperty(_this, \"renderMap\", {\n                CartesianGrid: {\n                    handler: renderAsIs,\n                    once: true\n                },\n                ReferenceArea: {\n                    handler: _this.renderReferenceElement\n                },\n                ReferenceLine: {\n                    handler: renderAsIs\n                },\n                ReferenceDot: {\n                    handler: _this.renderReferenceElement\n                },\n                XAxis: {\n                    handler: renderAsIs\n                },\n                YAxis: {\n                    handler: renderAsIs\n                },\n                Brush: {\n                    handler: _this.renderBrush,\n                    once: true\n                },\n                Bar: {\n                    handler: _this.renderGraphicChild\n                },\n                Line: {\n                    handler: _this.renderGraphicChild\n                },\n                Area: {\n                    handler: _this.renderGraphicChild\n                },\n                Radar: {\n                    handler: _this.renderGraphicChild\n                },\n                RadialBar: {\n                    handler: _this.renderGraphicChild\n                },\n                Scatter: {\n                    handler: _this.renderGraphicChild\n                },\n                Pie: {\n                    handler: _this.renderGraphicChild\n                },\n                Funnel: {\n                    handler: _this.renderGraphicChild\n                },\n                Tooltip: {\n                    handler: _this.renderCursor,\n                    once: true\n                },\n                PolarGrid: {\n                    handler: _this.renderPolarGrid,\n                    once: true\n                },\n                PolarAngleAxis: {\n                    handler: _this.renderPolarAxis\n                },\n                PolarRadiusAxis: {\n                    handler: _this.renderPolarAxis\n                },\n                Customized: {\n                    handler: _this.renderCustomized\n                }\n            });\n            _this.clipPathId = \"\".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.uniqueId)('recharts'), \"-clip\");\n            // trigger 60fps\n            _this.throttleTriggeredAfterMouseMove = lodash_throttle__WEBPACK_IMPORTED_MODULE_6___default()(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1000 / 60);\n            _this.state = {};\n            return _this;\n        }\n        _inherits(CategoricalChartWrapper, _Component);\n        return _createClass(CategoricalChartWrapper, [\n            {\n                key: \"componentDidMount\",\n                value: function componentDidMount() {\n                    var _this$props$margin$le, _this$props$margin$to;\n                    this.addListener();\n                    this.accessibilityManager.setDetails({\n                        container: this.container,\n                        offset: {\n                            left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,\n                            top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0\n                        },\n                        coordinateList: this.state.tooltipTicks,\n                        mouseHandlerCallback: this.triggeredAfterMouseMove,\n                        layout: this.props.layout\n                    });\n                    this.displayDefaultTooltip();\n                }\n            },\n            {\n                key: \"displayDefaultTooltip\",\n                value: function displayDefaultTooltip() {\n                    var _this$props5 = this.props, children = _this$props5.children, data = _this$props5.data, height = _this$props5.height, layout = _this$props5.layout;\n                    var tooltipElem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip);\n                    // If the chart doesn't include a <Tooltip /> element, there's no tooltip to display\n                    if (!tooltipElem) {\n                        return;\n                    }\n                    var defaultIndex = tooltipElem.props.defaultIndex;\n                    // Protect against runtime errors\n                    if (typeof defaultIndex !== 'number' || defaultIndex < 0 || defaultIndex > this.state.tooltipTicks.length - 1) {\n                        return;\n                    }\n                    var activeLabel = this.state.tooltipTicks[defaultIndex] && this.state.tooltipTicks[defaultIndex].value;\n                    var activePayload = getTooltipContent(this.state, data, defaultIndex, activeLabel);\n                    var independentAxisCoord = this.state.tooltipTicks[defaultIndex].coordinate;\n                    var dependentAxisCoord = (this.state.offset.top + height) / 2;\n                    var isHorizontal = layout === 'horizontal';\n                    var activeCoordinate = isHorizontal ? {\n                        x: independentAxisCoord,\n                        y: dependentAxisCoord\n                    } : {\n                        y: independentAxisCoord,\n                        x: dependentAxisCoord\n                    };\n                    // Unlike other chart types, scatter plot's tooltip positions rely on both X and Y coordinates. Only the scatter plot\n                    // element knows its own Y coordinates.\n                    // If there's a scatter plot, we'll want to grab that element for an interrogation.\n                    var scatterPlotElement = this.state.formattedGraphicalItems.find(function(_ref12) {\n                        var item = _ref12.item;\n                        return item.type.name === 'Scatter';\n                    });\n                    if (scatterPlotElement) {\n                        activeCoordinate = _objectSpread(_objectSpread({}, activeCoordinate), scatterPlotElement.props.points[defaultIndex].tooltipPosition);\n                        activePayload = scatterPlotElement.props.points[defaultIndex].tooltipPayload;\n                    }\n                    var nextState = {\n                        activeTooltipIndex: defaultIndex,\n                        isTooltipActive: true,\n                        activeLabel: activeLabel,\n                        activePayload: activePayload,\n                        activeCoordinate: activeCoordinate\n                    };\n                    this.setState(nextState);\n                    this.renderCursor(tooltipElem);\n                    // Make sure that anyone who keyboard-only users who tab to the chart will start their\n                    // cursors at defaultIndex\n                    this.accessibilityManager.setIndex(defaultIndex);\n                }\n            },\n            {\n                key: \"getSnapshotBeforeUpdate\",\n                value: function getSnapshotBeforeUpdate(prevProps, prevState) {\n                    if (!this.props.accessibilityLayer) {\n                        return null;\n                    }\n                    if (this.state.tooltipTicks !== prevState.tooltipTicks) {\n                        this.accessibilityManager.setDetails({\n                            coordinateList: this.state.tooltipTicks\n                        });\n                    }\n                    if (this.props.layout !== prevProps.layout) {\n                        this.accessibilityManager.setDetails({\n                            layout: this.props.layout\n                        });\n                    }\n                    if (this.props.margin !== prevProps.margin) {\n                        var _this$props$margin$le2, _this$props$margin$to2;\n                        this.accessibilityManager.setDetails({\n                            offset: {\n                                left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,\n                                top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0\n                            }\n                        });\n                    }\n                    // Something has to be returned for getSnapshotBeforeUpdate\n                    return null;\n                }\n            },\n            {\n                key: \"componentDidUpdate\",\n                value: function componentDidUpdate(prevProps) {\n                    // Check to see if the Tooltip updated. If so, re-check default tooltip position\n                    if (!(0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.isChildrenEqual)([\n                        (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(prevProps.children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip)\n                    ], [\n                        (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(this.props.children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip)\n                    ])) {\n                        this.displayDefaultTooltip();\n                    }\n                }\n            },\n            {\n                key: \"componentWillUnmount\",\n                value: function componentWillUnmount() {\n                    this.removeListener();\n                    this.throttleTriggeredAfterMouseMove.cancel();\n                }\n            },\n            {\n                key: \"getTooltipEventType\",\n                value: function getTooltipEventType() {\n                    var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(this.props.children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip);\n                    if (tooltipItem && typeof tooltipItem.props.shared === 'boolean') {\n                        var eventType = tooltipItem.props.shared ? 'axis' : 'item';\n                        return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;\n                    }\n                    return defaultTooltipEventType;\n                }\n            },\n            {\n                key: \"getMouseInfo\",\n                value: function getMouseInfo(event) {\n                    if (!this.container) {\n                        return null;\n                    }\n                    var element = this.container;\n                    var boundingRect = element.getBoundingClientRect();\n                    var containerOffset = (0,_util_DOMUtils__WEBPACK_IMPORTED_MODULE_23__.getOffset)(boundingRect);\n                    var e = {\n                        chartX: Math.round(event.pageX - containerOffset.left),\n                        chartY: Math.round(event.pageY - containerOffset.top)\n                    };\n                    var scale = boundingRect.width / element.offsetWidth || 1;\n                    var rangeObj = this.inRange(e.chartX, e.chartY, scale);\n                    if (!rangeObj) {\n                        return null;\n                    }\n                    var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;\n                    var tooltipEventType = this.getTooltipEventType();\n                    if (tooltipEventType !== 'axis' && xAxisMap && yAxisMap) {\n                        var xScale = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.getAnyElementOfObject)(xAxisMap).scale;\n                        var yScale = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.getAnyElementOfObject)(yAxisMap).scale;\n                        var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;\n                        var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;\n                        return _objectSpread(_objectSpread({}, e), {}, {\n                            xValue: xValue,\n                            yValue: yValue\n                        });\n                    }\n                    var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);\n                    if (toolTipData) {\n                        return _objectSpread(_objectSpread({}, e), toolTipData);\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"inRange\",\n                value: function inRange(x, y) {\n                    var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var layout = this.props.layout;\n                    var scaledX = x / scale, scaledY = y / scale;\n                    if (layout === 'horizontal' || layout === 'vertical') {\n                        var offset = this.state.offset;\n                        var isInRange = scaledX >= offset.left && scaledX <= offset.left + offset.width && scaledY >= offset.top && scaledY <= offset.top + offset.height;\n                        return isInRange ? {\n                            x: scaledX,\n                            y: scaledY\n                        } : null;\n                    }\n                    var _this$state10 = this.state, angleAxisMap = _this$state10.angleAxisMap, radiusAxisMap = _this$state10.radiusAxisMap;\n                    if (angleAxisMap && radiusAxisMap) {\n                        var angleAxis = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__.getAnyElementOfObject)(angleAxisMap);\n                        return (0,_util_PolarUtils__WEBPACK_IMPORTED_MODULE_9__.inRangeOfSector)({\n                            x: scaledX,\n                            y: scaledY\n                        }, angleAxis);\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"parseEventsOfWrapper\",\n                value: function parseEventsOfWrapper() {\n                    var children = this.props.children;\n                    var tooltipEventType = this.getTooltipEventType();\n                    var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_21__.Tooltip);\n                    var tooltipEvents = {};\n                    if (tooltipItem && tooltipEventType === 'axis') {\n                        if (tooltipItem.props.trigger === 'click') {\n                            tooltipEvents = {\n                                onClick: this.handleClick\n                            };\n                        } else {\n                            tooltipEvents = {\n                                onMouseEnter: this.handleMouseEnter,\n                                onMouseMove: this.handleMouseMove,\n                                onMouseLeave: this.handleMouseLeave,\n                                onTouchMove: this.handleTouchMove,\n                                onTouchStart: this.handleTouchStart,\n                                onTouchEnd: this.handleTouchEnd\n                            };\n                        }\n                    }\n                    // @ts-expect-error adaptEventHandlers expects DOM Event but generateCategoricalChart works with React UIEvents\n                    var outerEvents = (0,_util_types__WEBPACK_IMPORTED_MODULE_22__.adaptEventHandlers)(this.props, this.handleOuterEvent);\n                    return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);\n                }\n            },\n            {\n                key: \"addListener\",\n                value: function addListener() {\n                    _util_Events__WEBPACK_IMPORTED_MODULE_18__.eventCenter.on(_util_Events__WEBPACK_IMPORTED_MODULE_18__.SYNC_EVENT, this.handleReceiveSyncEvent);\n                }\n            },\n            {\n                key: \"removeListener\",\n                value: function removeListener() {\n                    _util_Events__WEBPACK_IMPORTED_MODULE_18__.eventCenter.removeListener(_util_Events__WEBPACK_IMPORTED_MODULE_18__.SYNC_EVENT, this.handleReceiveSyncEvent);\n                }\n            },\n            {\n                key: \"filterFormatItem\",\n                value: function filterFormatItem(item, displayName, childIndex) {\n                    var formattedGraphicalItems = this.state.formattedGraphicalItems;\n                    for(var i = 0, len = formattedGraphicalItems.length; i < len; i++){\n                        var entry = formattedGraphicalItems[i];\n                        if (entry.item === item || entry.props.key === item.key || displayName === (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.getDisplayName)(entry.item.type) && childIndex === entry.childIndex) {\n                            return entry;\n                        }\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"renderClipPath\",\n                value: function renderClipPath() {\n                    var clipPathId = this.clipPathId;\n                    var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"defs\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"clipPath\", {\n                        id: clipPathId\n                    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"rect\", {\n                        x: left,\n                        y: top,\n                        height: height,\n                        width: width\n                    })));\n                }\n            },\n            {\n                key: \"getXScales\",\n                value: function getXScales() {\n                    var xAxisMap = this.state.xAxisMap;\n                    return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {\n                        var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];\n                        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));\n                    }, {}) : null;\n                }\n            },\n            {\n                key: \"getYScales\",\n                value: function getYScales() {\n                    var yAxisMap = this.state.yAxisMap;\n                    return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {\n                        var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];\n                        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));\n                    }, {}) : null;\n                }\n            },\n            {\n                key: \"getXScaleByAxisId\",\n                value: function getXScaleByAxisId(axisId) {\n                    var _this$state$xAxisMap;\n                    return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;\n                }\n            },\n            {\n                key: \"getYScaleByAxisId\",\n                value: function getYScaleByAxisId(axisId) {\n                    var _this$state$yAxisMap;\n                    return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;\n                }\n            },\n            {\n                key: \"getItemByXY\",\n                value: function getItemByXY(chartXY) {\n                    var _this$state11 = this.state, formattedGraphicalItems = _this$state11.formattedGraphicalItems, activeItem = _this$state11.activeItem;\n                    if (formattedGraphicalItems && formattedGraphicalItems.length) {\n                        for(var i = 0, len = formattedGraphicalItems.length; i < len; i++){\n                            var graphicalItem = formattedGraphicalItems[i];\n                            // graphicalItem is not a React Element so we don't need to resolve defaultProps\n                            var props = graphicalItem.props, item = graphicalItem.item;\n                            var itemProps = item.type.defaultProps !== undefined ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;\n                            var itemDisplayName = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.getDisplayName)(item.type);\n                            if (itemDisplayName === 'Bar') {\n                                var activeBarItem = (props.data || []).find(function(entry) {\n                                    return (0,_shape_Rectangle__WEBPACK_IMPORTED_MODULE_24__.isInRectangle)(chartXY, entry);\n                                });\n                                if (activeBarItem) {\n                                    return {\n                                        graphicalItem: graphicalItem,\n                                        payload: activeBarItem\n                                    };\n                                }\n                            } else if (itemDisplayName === 'RadialBar') {\n                                var _activeBarItem = (props.data || []).find(function(entry) {\n                                    return (0,_util_PolarUtils__WEBPACK_IMPORTED_MODULE_9__.inRangeOfSector)(chartXY, entry);\n                                });\n                                if (_activeBarItem) {\n                                    return {\n                                        graphicalItem: graphicalItem,\n                                        payload: _activeBarItem\n                                    };\n                                }\n                            } else if ((0,_util_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_25__.isFunnel)(graphicalItem, activeItem) || (0,_util_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_25__.isPie)(graphicalItem, activeItem) || (0,_util_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_25__.isScatter)(graphicalItem, activeItem)) {\n                                var activeIndex = (0,_util_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_25__.getActiveShapeIndexForTooltip)({\n                                    graphicalItem: graphicalItem,\n                                    activeTooltipItem: activeItem,\n                                    itemData: itemProps.data\n                                });\n                                var childIndex = itemProps.activeIndex === undefined ? activeIndex : itemProps.activeIndex;\n                                return {\n                                    graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, {\n                                        childIndex: childIndex\n                                    }),\n                                    payload: (0,_util_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_25__.isScatter)(graphicalItem, activeItem) ? itemProps.data[activeIndex] : graphicalItem.props.data[activeIndex]\n                                };\n                            }\n                        }\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"render\",\n                value: function render() {\n                    var _this3 = this;\n                    if (!(0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.validateWidthHeight)(this)) {\n                        return null;\n                    }\n                    var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties(_this$props6, _excluded2);\n                    var attrs = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.filterProps)(others, false);\n                    // The \"compact\" mode is mainly used as the panorama within Brush\n                    if (compact) {\n                        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_26__.ChartLayoutContextProvider, {\n                            state: this.state,\n                            width: this.props.width,\n                            height: this.props.height,\n                            clipPathId: this.clipPathId\n                        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_container_Surface__WEBPACK_IMPORTED_MODULE_27__.Surface, _extends({}, attrs, {\n                            width: width,\n                            height: height,\n                            title: title,\n                            desc: desc\n                        }), this.renderClipPath(), (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.renderByOrder)(children, this.renderMap)));\n                    }\n                    if (this.props.accessibilityLayer) {\n                        var _this$props$tabIndex, _this$props$role;\n                        // Set tabIndex to 0 by default (can be overwritten)\n                        attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;\n                        // Set role to img by default (can be overwritten)\n                        attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : 'application';\n                        attrs.onKeyDown = function(e) {\n                            _this3.accessibilityManager.keyboardEvent(e);\n                        // 'onKeyDown' is not currently a supported prop that can be passed through\n                        // if it's added, this should be added: this.props.onKeyDown(e);\n                        };\n                        attrs.onFocus = function() {\n                            _this3.accessibilityManager.focus();\n                        // 'onFocus' is not currently a supported prop that can be passed through\n                        // if it's added, the focus event should be forwarded to the prop\n                        };\n                    }\n                    var events = this.parseEventsOfWrapper();\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_26__.ChartLayoutContextProvider, {\n                        state: this.state,\n                        width: this.props.width,\n                        height: this.props.height,\n                        clipPathId: this.clipPathId\n                    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", _extends({\n                        className: (0,clsx__WEBPACK_IMPORTED_MODULE_7__[\"default\"])('recharts-wrapper', className),\n                        style: _objectSpread({\n                            position: 'relative',\n                            cursor: 'default',\n                            width: width,\n                            height: height\n                        }, style)\n                    }, events, {\n                        ref: function ref(node) {\n                            _this3.container = node;\n                        }\n                    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_container_Surface__WEBPACK_IMPORTED_MODULE_27__.Surface, _extends({}, attrs, {\n                        width: width,\n                        height: height,\n                        title: title,\n                        desc: desc,\n                        style: FULL_WIDTH_AND_HEIGHT\n                    }), this.renderClipPath(), (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.renderByOrder)(children, this.renderMap)), this.renderLegend(), this.renderTooltip()));\n                }\n            }\n        ]);\n    }(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n    _defineProperty(CategoricalChartWrapper, \"displayName\", chartName);\n    // todo join specific chart propTypes\n    _defineProperty(CategoricalChartWrapper, \"defaultProps\", _objectSpread({\n        layout: 'horizontal',\n        stackOffset: 'none',\n        barCategoryGap: '10%',\n        barGap: 4,\n        margin: {\n            top: 5,\n            right: 5,\n            bottom: 5,\n            left: 5\n        },\n        reverseStackOrder: false,\n        syncMethod: 'index'\n    }, defaultProps));\n    _defineProperty(CategoricalChartWrapper, \"getDerivedStateFromProps\", function(nextProps, prevState) {\n        var dataKey = nextProps.dataKey, data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;\n        var dataStartIndex = prevState.dataStartIndex, dataEndIndex = prevState.dataEndIndex;\n        if (prevState.updateId === undefined) {\n            var defaultState = createDefaultState(nextProps);\n            return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {\n                updateId: 0\n            }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({\n                props: nextProps\n            }, defaultState), {}, {\n                updateId: 0\n            }), prevState)), {}, {\n                prevDataKey: dataKey,\n                prevData: data,\n                prevWidth: width,\n                prevHeight: height,\n                prevLayout: layout,\n                prevStackOffset: stackOffset,\n                prevMargin: margin,\n                prevChildren: children\n            });\n        }\n        if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !(0,_util_ShallowEqual__WEBPACK_IMPORTED_MODULE_28__.shallowEqual)(margin, prevState.prevMargin)) {\n            var _defaultState = createDefaultState(nextProps);\n            // Fixes https://github.com/recharts/recharts/issues/2143\n            var keepFromPrevState = {\n                // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid\n                // any flickering\n                chartX: prevState.chartX,\n                chartY: prevState.chartY,\n                // The tooltip should stay active when it was active in the previous render. If this is not\n                // the case, the tooltip disappears and immediately re-appears, causing a flickering effect\n                isTooltipActive: prevState.isTooltipActive\n            };\n            var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, {\n                updateId: prevState.updateId + 1\n            });\n            var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);\n            return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({\n                props: nextProps\n            }, newState), prevState)), {}, {\n                prevDataKey: dataKey,\n                prevData: data,\n                prevWidth: width,\n                prevHeight: height,\n                prevLayout: layout,\n                prevStackOffset: stackOffset,\n                prevMargin: margin,\n                prevChildren: children\n            });\n        }\n        if (!(0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.isChildrenEqual)(children, prevState.prevChildren)) {\n            var _brush$props$startInd, _brush$props, _brush$props$endIndex, _brush$props2;\n            // specifically check for Brush - if it exists and the start and end indexes are different, re-render with the new ones\n            var brush = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_14__.findChildByType)(children, _cartesian_Brush__WEBPACK_IMPORTED_MODULE_15__.Brush);\n            var startIndex = brush ? (_brush$props$startInd = (_brush$props = brush.props) === null || _brush$props === void 0 ? void 0 : _brush$props.startIndex) !== null && _brush$props$startInd !== void 0 ? _brush$props$startInd : dataStartIndex : dataStartIndex;\n            var endIndex = brush ? (_brush$props$endIndex = (_brush$props2 = brush.props) === null || _brush$props2 === void 0 ? void 0 : _brush$props2.endIndex) !== null && _brush$props$endIndex !== void 0 ? _brush$props$endIndex : dataEndIndex : dataEndIndex;\n            var hasDifferentStartOrEndIndex = startIndex !== dataStartIndex || endIndex !== dataEndIndex;\n            // update configuration in children\n            var hasGlobalData = !lodash_isNil__WEBPACK_IMPORTED_MODULE_1___default()(data);\n            var newUpdateId = hasGlobalData && !hasDifferentStartOrEndIndex ? prevState.updateId : prevState.updateId + 1;\n            return _objectSpread(_objectSpread({\n                updateId: newUpdateId\n            }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({\n                props: nextProps\n            }, prevState), {}, {\n                updateId: newUpdateId,\n                dataStartIndex: startIndex,\n                dataEndIndex: endIndex\n            }), prevState)), {}, {\n                prevChildren: children,\n                dataStartIndex: startIndex,\n                dataEndIndex: endIndex\n            });\n        }\n        return null;\n    });\n    _defineProperty(CategoricalChartWrapper, \"renderActiveDot\", function(option, props, key) {\n        var dot;\n        if (/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(option)) {\n            dot = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(option, props);\n        } else if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(option)) {\n            dot = option(props);\n        } else {\n            dot = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_shape_Dot__WEBPACK_IMPORTED_MODULE_29__.Dot, props);\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_30__.Layer, {\n            className: \"recharts-active-dot\",\n            key: key\n        }, dot);\n    });\n    return function CategoricalChart(props) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CategoricalChartWrapper, props);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvY2hhcnQvZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWTtJQUFDO0NBQU8sRUFDdEJDLGFBQWE7SUFBQztJQUFZO0lBQWE7SUFBUztJQUFVO0lBQVM7SUFBVztJQUFTO0NBQU87QUFDaEcsU0FBU0MsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLO0lBQWFBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSVAsT0FBT0YsU0FBUyxDQUFDVyxjQUFjLENBQUNDLElBQUksQ0FBQ0gsUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPTDtJQUFRO0lBQUcsT0FBT0osU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRU47QUFBWTtBQUNsVixTQUFTTyxlQUFlQyxHQUFHLEVBQUVULENBQUM7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bXBCO0lBQ0w7SUFDQSxPQUFPLFNBQVNDLGlCQUFpQmhuQixLQUFLO1FBQ3BDLE9BQU8sV0FBVyxHQUFFMEQsMERBQW1CLENBQUNxUix5QkFBeUIvVTtJQUNuRTtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb2Fvc2FudG9zL1dlYnN0b3JtUHJvamVjdHMvd2RjLXdlYi1wYW5lbC9ub2RlX21vZHVsZXMvcmVjaGFydHMvZXM2L2NoYXJ0L2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2V4Y2x1ZGVkID0gW1wiaXRlbVwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJzdHlsZVwiLCBcImNvbXBhY3RcIiwgXCJ0aXRsZVwiLCBcImRlc2NcIl07XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNsb25lRWxlbWVudCwgaXNWYWxpZEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaXNOaWwgZnJvbSAnbG9kYXNoL2lzTmlsJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJ2xvZGFzaC9pc0Z1bmN0aW9uJztcbmltcG9ydCByYW5nZSBmcm9tICdsb2Rhc2gvcmFuZ2UnO1xuaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBzb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcbmltcG9ydCB7IFN1cmZhY2UgfSBmcm9tICcuLi9jb250YWluZXIvU3VyZmFjZSc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvbnRhaW5lci9MYXllcic7XG5pbXBvcnQgeyBUb29sdGlwIH0gZnJvbSAnLi4vY29tcG9uZW50L1Rvb2x0aXAnO1xuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vY29tcG9uZW50L0xlZ2VuZCc7XG5pbXBvcnQgeyBEb3QgfSBmcm9tICcuLi9zaGFwZS9Eb3QnO1xuaW1wb3J0IHsgaXNJblJlY3RhbmdsZSB9IGZyb20gJy4uL3NoYXBlL1JlY3RhbmdsZSc7XG5pbXBvcnQgeyBmaWx0ZXJQcm9wcywgZmluZEFsbEJ5VHlwZSwgZmluZENoaWxkQnlUeXBlLCBnZXREaXNwbGF5TmFtZSwgZ2V0UmVhY3RFdmVudEJ5VHlwZSwgaXNDaGlsZHJlbkVxdWFsLCBwYXJzZUNoaWxkSW5kZXgsIHJlbmRlckJ5T3JkZXIsIHZhbGlkYXRlV2lkdGhIZWlnaHQgfSBmcm9tICcuLi91dGlsL1JlYWN0VXRpbHMnO1xuaW1wb3J0IHsgQnJ1c2ggfSBmcm9tICcuLi9jYXJ0ZXNpYW4vQnJ1c2gnO1xuaW1wb3J0IHsgZ2V0T2Zmc2V0IH0gZnJvbSAnLi4vdXRpbC9ET01VdGlscyc7XG5pbXBvcnQgeyBmaW5kRW50cnlJbkFycmF5LCBnZXRBbnlFbGVtZW50T2ZPYmplY3QsIGhhc0R1cGxpY2F0ZSwgaXNOdW1iZXIsIHVuaXF1ZUlkIH0gZnJvbSAnLi4vdXRpbC9EYXRhVXRpbHMnO1xuaW1wb3J0IHsgYXBwZW5kT2Zmc2V0T2ZMZWdlbmQsIGNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCwgY29tYmluZUV2ZW50SGFuZGxlcnMsIGdldEJhbmRTaXplT2ZBeGlzLCBnZXRCYXJQb3NpdGlvbiwgZ2V0QmFyU2l6ZUxpc3QsIGdldERvbWFpbk9mRGF0YUJ5S2V5LCBnZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzLCBnZXREb21haW5PZlN0YWNrR3JvdXBzLCBnZXRMZWdlbmRQcm9wcywgZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbSwgZ2V0U3RhY2tlZERhdGFPZkl0ZW0sIGdldFN0YWNrR3JvdXBzQnlBeGlzSWQsIGdldFRpY2tzT2ZBeGlzLCBnZXRUb29sdGlwSXRlbSwgaXNDYXRlZ29yaWNhbEF4aXMsIHBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMsIHBhcnNlRXJyb3JCYXJzT2ZBeGlzLCBwYXJzZVNwZWNpZmllZERvbWFpbiB9IGZyb20gJy4uL3V0aWwvQ2hhcnRVdGlscyc7XG5pbXBvcnQgeyBkZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbiB9IGZyb20gJy4uL3V0aWwvRGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4nO1xuaW1wb3J0IHsgaW5SYW5nZU9mU2VjdG9yLCBwb2xhclRvQ2FydGVzaWFuIH0gZnJvbSAnLi4vdXRpbC9Qb2xhclV0aWxzJztcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCB9IGZyb20gJy4uL3V0aWwvU2hhbGxvd0VxdWFsJztcbmltcG9ydCB7IGV2ZW50Q2VudGVyLCBTWU5DX0VWRU5UIH0gZnJvbSAnLi4vdXRpbC9FdmVudHMnO1xuaW1wb3J0IHsgYWRhcHRFdmVudEhhbmRsZXJzIH0gZnJvbSAnLi4vdXRpbC90eXBlcyc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB9IGZyb20gJy4vQWNjZXNzaWJpbGl0eU1hbmFnZXInO1xuaW1wb3J0IHsgaXNEb21haW5TcGVjaWZpZWRCeVVzZXIgfSBmcm9tICcuLi91dGlsL2lzRG9tYWluU3BlY2lmaWVkQnlVc2VyJztcbmltcG9ydCB7IGdldEFjdGl2ZVNoYXBlSW5kZXhGb3JUb29sdGlwLCBpc0Z1bm5lbCwgaXNQaWUsIGlzU2NhdHRlciB9IGZyb20gJy4uL3V0aWwvQWN0aXZlU2hhcGVVdGlscyc7XG5pbXBvcnQgeyBDdXJzb3IgfSBmcm9tICcuLi9jb21wb25lbnQvQ3Vyc29yJztcbmltcG9ydCB7IENoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyIH0gZnJvbSAnLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHQnO1xudmFyIE9SSUVOVF9NQVAgPSB7XG4gIHhBeGlzOiBbJ2JvdHRvbScsICd0b3AnXSxcbiAgeUF4aXM6IFsnbGVmdCcsICdyaWdodCddXG59O1xudmFyIEZVTExfV0lEVEhfQU5EX0hFSUdIVCA9IHtcbiAgd2lkdGg6ICcxMDAlJyxcbiAgaGVpZ2h0OiAnMTAwJSdcbn07XG52YXIgb3JpZ2luQ29vcmRpbmF0ZSA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBhcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLlxuICpcbiAqIFdoeT8gZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IGRvZXMgbm90IHJlbmRlciBge2NoaWxkcmVufWAgZGlyZWN0bHk7XG4gKiBpbnN0ZWFkIGl0IHBhc3NlcyB0aGVtIHRocm91Z2ggYHJlbmRlckJ5T3JkZXJgIGZ1bmN0aW9uIHdoaWNoIHJlYWRzIHRoZWlyIGhhbmRsZXJzLlxuICpcbiAqIFNvLCB0aGlzIGlzIGEgaGFuZGxlciB0aGF0IGRvZXMgbm90aGluZy5cbiAqIE9uY2Ugd2UgZ2V0IHJpZCBvZiBgcmVuZGVyQnlPcmRlcmAgYW5kIHN3aXRjaCB0byBKU1ggb25seSwgd2UgY2FuIGdldCByaWQgb2YgdGhpcyBoYW5kbGVyIHRvby5cbiAqXG4gKiBAcGFyYW0ge0pTWH0gZWxlbWVudCBhcyBpcyBpbiBKU1hcbiAqIEByZXR1cm5zIHtKU1h9IHRoZSBzYW1lIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQXNJcyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGNhbGN1bGF0ZVRvb2x0aXBQb3MgPSBmdW5jdGlvbiBjYWxjdWxhdGVUb29sdGlwUG9zKHJhbmdlT2JqLCBsYXlvdXQpIHtcbiAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgcmV0dXJuIHJhbmdlT2JqLng7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgIHJldHVybiByYW5nZU9iai55O1xuICB9XG4gIGlmIChsYXlvdXQgPT09ICdjZW50cmljJykge1xuICAgIHJldHVybiByYW5nZU9iai5hbmdsZTtcbiAgfVxuICByZXR1cm4gcmFuZ2VPYmoucmFkaXVzO1xufTtcbnZhciBnZXRBY3RpdmVDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0QWN0aXZlQ29vcmRpbmF0ZShsYXlvdXQsIHRvb2x0aXBUaWNrcywgYWN0aXZlSW5kZXgsIHJhbmdlT2JqKSB7XG4gIHZhciBlbnRyeSA9IHRvb2x0aXBUaWNrcy5maW5kKGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgcmV0dXJuIHRpY2sgJiYgdGljay5pbmRleCA9PT0gYWN0aXZlSW5kZXg7XG4gIH0pO1xuICBpZiAoZW50cnkpIHtcbiAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVudHJ5LmNvb3JkaW5hdGUsXG4gICAgICAgIHk6IHJhbmdlT2JqLnlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJhbmdlT2JqLngsXG4gICAgICAgIHk6IGVudHJ5LmNvb3JkaW5hdGVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChsYXlvdXQgPT09ICdjZW50cmljJykge1xuICAgICAgdmFyIF9hbmdsZSA9IGVudHJ5LmNvb3JkaW5hdGU7XG4gICAgICB2YXIgX3JhZGl1cyA9IHJhbmdlT2JqLnJhZGl1cztcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmFuZ2VPYmopLCBwb2xhclRvQ2FydGVzaWFuKHJhbmdlT2JqLmN4LCByYW5nZU9iai5jeSwgX3JhZGl1cywgX2FuZ2xlKSksIHt9LCB7XG4gICAgICAgIGFuZ2xlOiBfYW5nbGUsXG4gICAgICAgIHJhZGl1czogX3JhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByYWRpdXMgPSBlbnRyeS5jb29yZGluYXRlO1xuICAgIHZhciBhbmdsZSA9IHJhbmdlT2JqLmFuZ2xlO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmFuZ2VPYmopLCBwb2xhclRvQ2FydGVzaWFuKHJhbmdlT2JqLmN4LCByYW5nZU9iai5jeSwgcmFkaXVzLCBhbmdsZSkpLCB7fSwge1xuICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3JpZ2luQ29vcmRpbmF0ZTtcbn07XG52YXIgZ2V0RGlzcGxheWVkRGF0YSA9IGZ1bmN0aW9uIGdldERpc3BsYXllZERhdGEoZGF0YSwgX3JlZikge1xuICB2YXIgZ3JhcGhpY2FsSXRlbXMgPSBfcmVmLmdyYXBoaWNhbEl0ZW1zLFxuICAgIGRhdGFTdGFydEluZGV4ID0gX3JlZi5kYXRhU3RhcnRJbmRleCxcbiAgICBkYXRhRW5kSW5kZXggPSBfcmVmLmRhdGFFbmRJbmRleDtcbiAgdmFyIGl0ZW1zRGF0YSA9IChncmFwaGljYWxJdGVtcyAhPT0gbnVsbCAmJiBncmFwaGljYWxJdGVtcyAhPT0gdm9pZCAwID8gZ3JhcGhpY2FsSXRlbXMgOiBbXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgdmFyIGl0ZW1EYXRhID0gY2hpbGQucHJvcHMuZGF0YTtcbiAgICBpZiAoaXRlbURhdGEgJiYgaXRlbURhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQpLCBfdG9Db25zdW1hYmxlQXJyYXkoaXRlbURhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW10pO1xuICBpZiAoaXRlbXNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gaXRlbXNEYXRhO1xuICB9XG4gIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoICYmIGlzTnVtYmVyKGRhdGFTdGFydEluZGV4KSAmJiBpc051bWJlcihkYXRhRW5kSW5kZXgpKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoZGF0YVN0YXJ0SW5kZXgsIGRhdGFFbmRJbmRleCArIDEpO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0RG9tYWluQnlBeGlzVHlwZShheGlzVHlwZSkge1xuICByZXR1cm4gYXhpc1R5cGUgPT09ICdudW1iZXInID8gWzAsICdhdXRvJ10gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcFxuICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZSAgICAgICAgICBDdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGNoYXJ0RGF0YSAgICAgIFRoZSBkYXRhIGRlZmluZWQgaW4gY2hhcnRcbiAqIEBwYXJhbSAge051bWJlcn0gYWN0aXZlSW5kZXggICAgQWN0aXZlIGluZGV4IG9mIGRhdGFcbiAqIEBwYXJhbSAge1N0cmluZ30gYWN0aXZlTGFiZWwgICAgQWN0aXZlIGxhYmVsIG9mIGRhdGFcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgVGhlIGNvbnRlbnQgb2YgdG9vbHRpcFxuICovXG52YXIgZ2V0VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiBnZXRUb29sdGlwQ29udGVudChzdGF0ZSwgY2hhcnREYXRhLCBhY3RpdmVJbmRleCwgYWN0aXZlTGFiZWwpIHtcbiAgdmFyIGdyYXBoaWNhbEl0ZW1zID0gc3RhdGUuZ3JhcGhpY2FsSXRlbXMsXG4gICAgdG9vbHRpcEF4aXMgPSBzdGF0ZS50b29sdGlwQXhpcztcbiAgdmFyIGRpc3BsYXllZERhdGEgPSBnZXREaXNwbGF5ZWREYXRhKGNoYXJ0RGF0YSwgc3RhdGUpO1xuICBpZiAoYWN0aXZlSW5kZXggPCAwIHx8ICFncmFwaGljYWxJdGVtcyB8fCAhZ3JhcGhpY2FsSXRlbXMubGVuZ3RoIHx8IGFjdGl2ZUluZGV4ID49IGRpc3BsYXllZERhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gZ2V0IGRhdGEgYnkgYWN0aXZlSW5kZXggd2hlbiB0aGUgYXhpcyBkb24ndCBhbGxvdyBkdXBsaWNhdGVkIGNhdGVnb3J5XG4gIHJldHVybiBncmFwaGljYWxJdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcbiAgICB2YXIgX2NoaWxkJHByb3BzJGRhdGE7XG4gICAgLyoqXG4gICAgICogRml4ZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWNoYXJ0cy9yZWNoYXJ0cy9pc3N1ZXMvMzY2OVxuICAgICAqIERlZmF1bHRpbmcgdG8gY2hhcnREYXRhIGJlbG93IHRvIGZpeCBhbiBlZGdlIGNhc2Ugd2hlcmUgdGhlIHRvb2x0aXAgZG9lcyBub3QgaW5jbHVkZSBkYXRhIGZyb20gYWxsIGNoYXJ0c1xuICAgICAqIHdoZW4gYSBzZXBhcmF0ZSBkYXRhc2V0IGlzIHBhc3NlZCB0byBjaGFydCBwcm9wIGRhdGEgYW5kIHNwZWNpZmllZCBvbiBMaW5lL0FyZWEvZXRjIHByb3AgZGF0YVxuICAgICAqL1xuICAgIHZhciBkYXRhID0gKF9jaGlsZCRwcm9wcyRkYXRhID0gY2hpbGQucHJvcHMuZGF0YSkgIT09IG51bGwgJiYgX2NoaWxkJHByb3BzJGRhdGEgIT09IHZvaWQgMCA/IF9jaGlsZCRwcm9wcyRkYXRhIDogY2hhcnREYXRhO1xuICAgIGlmIChkYXRhICYmIHN0YXRlLmRhdGFTdGFydEluZGV4ICsgc3RhdGUuZGF0YUVuZEluZGV4ICE9PSAwICYmXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlY2hhcnRzL3JlY2hhcnRzL2lzc3Vlcy80NzE3XG4gICAgLy8gVGhlIGRhdGEgaXMgc2xpY2VkIG9ubHkgd2hlbiB0aGUgYWN0aXZlIGluZGV4IGlzIHdpdGhpbiB0aGUgc3RhcnQvZW5kIGluZGV4IHJhbmdlLlxuICAgIHN0YXRlLmRhdGFFbmRJbmRleCAtIHN0YXRlLmRhdGFTdGFydEluZGV4ID49IGFjdGl2ZUluZGV4KSB7XG4gICAgICBkYXRhID0gZGF0YS5zbGljZShzdGF0ZS5kYXRhU3RhcnRJbmRleCwgc3RhdGUuZGF0YUVuZEluZGV4ICsgMSk7XG4gICAgfVxuICAgIHZhciBwYXlsb2FkO1xuICAgIGlmICh0b29sdGlwQXhpcy5kYXRhS2V5ICYmICF0b29sdGlwQXhpcy5hbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSkge1xuICAgICAgLy8gZ3JhcGhpYyBjaGlsZCBoYXMgZGF0YSBwcm9wc1xuICAgICAgdmFyIGVudHJpZXMgPSBkYXRhID09PSB1bmRlZmluZWQgPyBkaXNwbGF5ZWREYXRhIDogZGF0YTtcbiAgICAgIHBheWxvYWQgPSBmaW5kRW50cnlJbkFycmF5KGVudHJpZXMsIHRvb2x0aXBBeGlzLmRhdGFLZXksIGFjdGl2ZUxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF5bG9hZCA9IGRhdGEgJiYgZGF0YVthY3RpdmVJbmRleF0gfHwgZGlzcGxheWVkRGF0YVthY3RpdmVJbmRleF07XG4gICAgfVxuICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0KSwgW2dldFRvb2x0aXBJdGVtKGNoaWxkLCBwYXlsb2FkKV0pO1xuICB9LCBbXSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdG9vbHRpcCBkYXRhIGJhc2VkIG9uIGEgbW91c2UgcG9zaXRpb24gKGFzIGEgcGFyYW1ldGVyIG9yIGluIHN0YXRlKVxuICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZSAgICAgY3VycmVudCBzdGF0ZVxuICogQHBhcmFtICB7QXJyYXl9ICBjaGFydERhdGEgdGhlIGRhdGEgZGVmaW5lZCBpbiBjaGFydFxuICogQHBhcmFtICB7U3RyaW5nfSBsYXlvdXQgICAgIFRoZSBsYXlvdXQgdHlwZSBvZiBjaGFydFxuICogQHBhcmFtICB7T2JqZWN0fSByYW5nZU9iaiAgeyB4LCB5IH0gY29vcmRpbmF0ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIFRvb2x0aXAgZGF0YSBkYXRhXG4gKi9cbnZhciBnZXRUb29sdGlwRGF0YSA9IGZ1bmN0aW9uIGdldFRvb2x0aXBEYXRhKHN0YXRlLCBjaGFydERhdGEsIGxheW91dCwgcmFuZ2VPYmopIHtcbiAgdmFyIHJhbmdlRGF0YSA9IHJhbmdlT2JqIHx8IHtcbiAgICB4OiBzdGF0ZS5jaGFydFgsXG4gICAgeTogc3RhdGUuY2hhcnRZXG4gIH07XG4gIHZhciBwb3MgPSBjYWxjdWxhdGVUb29sdGlwUG9zKHJhbmdlRGF0YSwgbGF5b3V0KTtcbiAgdmFyIHRpY2tzID0gc3RhdGUub3JkZXJlZFRvb2x0aXBUaWNrcyxcbiAgICBheGlzID0gc3RhdGUudG9vbHRpcEF4aXMsXG4gICAgdG9vbHRpcFRpY2tzID0gc3RhdGUudG9vbHRpcFRpY2tzO1xuICB2YXIgYWN0aXZlSW5kZXggPSBjYWxjdWxhdGVBY3RpdmVUaWNrSW5kZXgocG9zLCB0aWNrcywgdG9vbHRpcFRpY2tzLCBheGlzKTtcbiAgaWYgKGFjdGl2ZUluZGV4ID49IDAgJiYgdG9vbHRpcFRpY2tzKSB7XG4gICAgdmFyIGFjdGl2ZUxhYmVsID0gdG9vbHRpcFRpY2tzW2FjdGl2ZUluZGV4XSAmJiB0b29sdGlwVGlja3NbYWN0aXZlSW5kZXhdLnZhbHVlO1xuICAgIHZhciBhY3RpdmVQYXlsb2FkID0gZ2V0VG9vbHRpcENvbnRlbnQoc3RhdGUsIGNoYXJ0RGF0YSwgYWN0aXZlSW5kZXgsIGFjdGl2ZUxhYmVsKTtcbiAgICB2YXIgYWN0aXZlQ29vcmRpbmF0ZSA9IGdldEFjdGl2ZUNvb3JkaW5hdGUobGF5b3V0LCB0aWNrcywgYWN0aXZlSW5kZXgsIHJhbmdlRGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleDogYWN0aXZlSW5kZXgsXG4gICAgICBhY3RpdmVMYWJlbDogYWN0aXZlTGFiZWwsXG4gICAgICBhY3RpdmVQYXlsb2FkOiBhY3RpdmVQYXlsb2FkLFxuICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogYWN0aXZlQ29vcmRpbmF0ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29uZmlndXJhdGlvbiBvZiBheGlzIGJ5IHRoZSBvcHRpb25zIG9mIGF4aXMgaW5zdGFuY2VcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICBMYXRlc3QgcHJvcHNcbiAqIEBwYXJhbSB7QXJyYXl9ICBheGVzICAgICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgYXhlc1xuICogQHBhcmFtICB7QXJyYXl9IGdyYXBoaWNhbEl0ZW1zIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxuICogQHBhcmFtICB7U3RyaW5nfSBheGlzVHlwZSAgICAgIFRoZSB0eXBlIG9mIGF4aXMsIHhBeGlzIC0geC1heGlzLCB5QXhpcyAtIHktYXhpc1xuICogQHBhcmFtICB7U3RyaW5nfSBheGlzSWRLZXkgICAgIFRoZSB1bmlxdWUgaWQgb2YgYW4gYXhpc1xuICogQHBhcmFtICB7T2JqZWN0fSBzdGFja0dyb3VwcyAgIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgZGF0YSBzZXJpZXMgd2hlbiBhIGJydXNoIGlzIGFwcGxpZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhRW5kSW5kZXggICBUaGUgZW5kIGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgIENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IHZhciBnZXRBeGlzTWFwQnlBeGVzID0gZnVuY3Rpb24gZ2V0QXhpc01hcEJ5QXhlcyhwcm9wcywgX3JlZjIpIHtcbiAgdmFyIGF4ZXMgPSBfcmVmMi5heGVzLFxuICAgIGdyYXBoaWNhbEl0ZW1zID0gX3JlZjIuZ3JhcGhpY2FsSXRlbXMsXG4gICAgYXhpc1R5cGUgPSBfcmVmMi5heGlzVHlwZSxcbiAgICBheGlzSWRLZXkgPSBfcmVmMi5heGlzSWRLZXksXG4gICAgc3RhY2tHcm91cHMgPSBfcmVmMi5zdGFja0dyb3VwcyxcbiAgICBkYXRhU3RhcnRJbmRleCA9IF9yZWYyLmRhdGFTdGFydEluZGV4LFxuICAgIGRhdGFFbmRJbmRleCA9IF9yZWYyLmRhdGFFbmRJbmRleDtcbiAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgIHN0YWNrT2Zmc2V0ID0gcHJvcHMuc3RhY2tPZmZzZXQ7XG4gIHZhciBpc0NhdGVnb3JpY2FsID0gaXNDYXRlZ29yaWNhbEF4aXMobGF5b3V0LCBheGlzVHlwZSk7XG5cbiAgLy8gRWxpbWluYXRlIGR1cGxpY2F0ZWQgYXhlc1xuICByZXR1cm4gYXhlcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcbiAgICB2YXIgX2NoaWxkUHJvcHMkZG9tYWluMjtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IGNoaWxkLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkLnR5cGUuZGVmYXVsdFByb3BzKSwgY2hpbGQucHJvcHMpIDogY2hpbGQucHJvcHM7XG4gICAgdmFyIHR5cGUgPSBjaGlsZFByb3BzLnR5cGUsXG4gICAgICBkYXRhS2V5ID0gY2hpbGRQcm9wcy5kYXRhS2V5LFxuICAgICAgYWxsb3dEYXRhT3ZlcmZsb3cgPSBjaGlsZFByb3BzLmFsbG93RGF0YU92ZXJmbG93LFxuICAgICAgYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkgPSBjaGlsZFByb3BzLmFsbG93RHVwbGljYXRlZENhdGVnb3J5LFxuICAgICAgc2NhbGUgPSBjaGlsZFByb3BzLnNjYWxlLFxuICAgICAgdGlja3MgPSBjaGlsZFByb3BzLnRpY2tzLFxuICAgICAgaW5jbHVkZUhpZGRlbiA9IGNoaWxkUHJvcHMuaW5jbHVkZUhpZGRlbjtcbiAgICB2YXIgYXhpc0lkID0gY2hpbGRQcm9wc1theGlzSWRLZXldO1xuICAgIGlmIChyZXN1bHRbYXhpc0lkXSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGRpc3BsYXllZERhdGEgPSBnZXREaXNwbGF5ZWREYXRhKHByb3BzLmRhdGEsIHtcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIF9kZWZhdWx0UHJvcHM7XG4gICAgICAgIHZhciBpdGVtQXhpc0lkID0gYXhpc0lkS2V5IGluIGl0ZW0ucHJvcHMgPyBpdGVtLnByb3BzW2F4aXNJZEtleV0gOiAoX2RlZmF1bHRQcm9wcyA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZhdWx0UHJvcHNbYXhpc0lkS2V5XTtcbiAgICAgICAgcmV0dXJuIGl0ZW1BeGlzSWQgPT09IGF4aXNJZDtcbiAgICAgIH0pLFxuICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICB9KTtcbiAgICB2YXIgbGVuID0gZGlzcGxheWVkRGF0YS5sZW5ndGg7XG4gICAgdmFyIGRvbWFpbiwgZHVwbGljYXRlRG9tYWluLCBjYXRlZ29yaWNhbERvbWFpbjtcblxuICAgIC8qXG4gICAgICogVGhpcyBpcyBhIGhhY2sgdG8gc2hvcnQtY2lyY3VpdCB0aGUgZG9tYWluIGNyZWF0aW9uIGhlcmUgdG8gZW5oYW5jZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBVc3VhbGx5LCB0aGUgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgZG9tYWluLCBidXQgd2hlbiB0aGUgdXNlciBzcGVjaWZpZXNcbiAgICAgKiBhIGRvbWFpbiB1cGZyb250ICh2aWEgcHJvcHMpLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgZG9tYWluIHN0YXJ0IGFuZCBlbmQsXG4gICAgICogd2hpY2ggaXMgdmVyeSBleHBlbnNpdmUgZm9yIGEgbGFyZ2VyIGFtb3VudCBvZiBkYXRhLlxuICAgICAqIFRoZSBvbmx5IHRoaW5nIHRoYXQgd291bGQgcHJvaGliaXQgc2hvcnQtY2lyY3VpdGluZyBpcyB3aGVuIHRoZSB1c2VyIGRvZXNuJ3QgYWxsb3cgZGF0YSBvdmVyZmxvdyxcbiAgICAgKiBiZWNhdXNlIHRoZSBheGlzIGlzIHN1cHBvc2VkIHRvIGlnbm9yZSB0aGUgc3BlY2lmaWVkIGRvbWFpbiB0aGF0IHdheS5cbiAgICAgKi9cbiAgICBpZiAoaXNEb21haW5TcGVjaWZpZWRCeVVzZXIoY2hpbGRQcm9wcy5kb21haW4sIGFsbG93RGF0YU92ZXJmbG93LCB0eXBlKSkge1xuICAgICAgZG9tYWluID0gcGFyc2VTcGVjaWZpZWREb21haW4oY2hpbGRQcm9wcy5kb21haW4sIG51bGwsIGFsbG93RGF0YU92ZXJmbG93KTtcbiAgICAgIC8qIFRoZSBjaGFydCBjYW4gYmUgY2F0ZWdvcmljYWwgYW5kIGhhdmUgdGhlIGRvbWFpbiBzcGVjaWZpZWQgaW4gbnVtYmVyc1xuICAgICAgICogd2Ugc3RpbGwgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGNhdGVnb3JpY2FsIGRvbWFpblxuICAgICAgICogVE9ETzogcmVmYWN0b3IgdGhpcyBtb3JlXG4gICAgICAgKi9cbiAgICAgIGlmIChpc0NhdGVnb3JpY2FsICYmICh0eXBlID09PSAnbnVtYmVyJyB8fCBzY2FsZSAhPT0gJ2F1dG8nKSkge1xuICAgICAgICBjYXRlZ29yaWNhbERvbWFpbiA9IGdldERvbWFpbk9mRGF0YUJ5S2V5KGRpc3BsYXllZERhdGEsIGRhdGFLZXksICdjYXRlZ29yeScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBkb21haW4gaXMgZGVmYXVsdGVkIHdlIG5lZWQgdGhpcyBmb3IgYG9yaWdpbmFsRG9tYWluYCBhcyB3ZWxsXG4gICAgdmFyIGRlZmF1bHREb21haW4gPSBnZXREZWZhdWx0RG9tYWluQnlBeGlzVHlwZSh0eXBlKTtcblxuICAgIC8vIHdlIGRpZG4ndCBjcmVhdGUgdGhlIGRvbWFpbiBmcm9tIHVzZXIncyBwcm9wcyBhYm92ZSwgc28gd2UgbmVlZCB0byBjYWxjdWxhdGUgaXRcbiAgICBpZiAoIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX2NoaWxkUHJvcHMkZG9tYWluO1xuICAgICAgdmFyIGNoaWxkRG9tYWluID0gKF9jaGlsZFByb3BzJGRvbWFpbiA9IGNoaWxkUHJvcHMuZG9tYWluKSAhPT0gbnVsbCAmJiBfY2hpbGRQcm9wcyRkb21haW4gIT09IHZvaWQgMCA/IF9jaGlsZFByb3BzJGRvbWFpbiA6IGRlZmF1bHREb21haW47XG4gICAgICBpZiAoZGF0YUtleSkge1xuICAgICAgICAvLyBoYXMgZGF0YUtleSBpbiA8QXhpcyAvPlxuICAgICAgICBkb21haW4gPSBnZXREb21haW5PZkRhdGFCeUtleShkaXNwbGF5ZWREYXRhLCBkYXRhS2V5LCB0eXBlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjYXRlZ29yeScgJiYgaXNDYXRlZ29yaWNhbCkge1xuICAgICAgICAgIC8vIHRoZSBmaWVsZCB0eXBlIGlzIGNhdGVnb3J5IGRhdGEgYW5kIHRoaXMgYXhpcyBpcyBjYXRlZ29yaWNhbCBheGlzXG4gICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IGhhc0R1cGxpY2F0ZShkb21haW4pO1xuICAgICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSAmJiBkdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIGR1cGxpY2F0ZURvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgICAgIC8vIFdoZW4gY2F0ZWdvcnkgYXhpcyBoYXMgZHVwbGljYXRlZCB0ZXh0LCBzZXJpYWwgbnVtYmVycyBhcmUgdXNlZCB0byBnZW5lcmF0ZSBzY2FsZVxuICAgICAgICAgICAgZG9tYWluID0gcmFuZ2UoMCwgbGVuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0R1cGxpY2F0ZWRDYXRlZ29yeSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZWQgY2F0ZWdvcnlcbiAgICAgICAgICAgIGRvbWFpbiA9IHBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMoY2hpbGREb21haW4sIGRvbWFpbiwgY2hpbGQpLnJlZHVjZShmdW5jdGlvbiAoZmluYWxEb21haW4sIGVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5hbERvbWFpbi5pbmRleE9mKGVudHJ5KSA+PSAwID8gZmluYWxEb21haW4gOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGZpbmFsRG9tYWluKSwgW2VudHJ5XSk7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICAvLyB0aGUgZmllbGQgdHlwZSBpcyBjYXRlZ29yeSBkYXRhIGFuZCB0aGlzIGF4aXMgaXMgbnVtZXJpY2FsIGF4aXNcbiAgICAgICAgICBpZiAoIWFsbG93RHVwbGljYXRlZENhdGVnb3J5KSB7XG4gICAgICAgICAgICBkb21haW4gPSBwYXJzZURvbWFpbk9mQ2F0ZWdvcnlBeGlzKGNoaWxkRG9tYWluLCBkb21haW4sIGNoaWxkKS5yZWR1Y2UoZnVuY3Rpb24gKGZpbmFsRG9tYWluLCBlbnRyeSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmluYWxEb21haW4uaW5kZXhPZihlbnRyeSkgPj0gMCB8fCBlbnRyeSA9PT0gJycgfHwgaXNOaWwoZW50cnkpID8gZmluYWxEb21haW4gOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGZpbmFsRG9tYWluKSwgW2VudHJ5XSk7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsaW1pbmF0ZSB1bmRlZmluZWQgb3IgbnVsbCBvciBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGRvbWFpbiA9IGRvbWFpbi5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbnRyeSAhPT0gJycgJiYgIWlzTmlsKGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIHRoZSBmaWVsZCB0eXBlIGlzIG51bWVyaWNhbFxuICAgICAgICAgIHZhciBlcnJvckJhcnNEb21haW4gPSBwYXJzZUVycm9yQmFyc09mQXhpcyhkaXNwbGF5ZWREYXRhLCBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBfZGVmYXVsdFByb3BzMiwgX2RlZmF1bHRQcm9wczM7XG4gICAgICAgICAgICB2YXIgaXRlbUF4aXNJZCA9IGF4aXNJZEtleSBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wc1theGlzSWRLZXldIDogKF9kZWZhdWx0UHJvcHMyID0gaXRlbS50eXBlLmRlZmF1bHRQcm9wcykgPT09IG51bGwgfHwgX2RlZmF1bHRQcm9wczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZWZhdWx0UHJvcHMyW2F4aXNJZEtleV07XG4gICAgICAgICAgICB2YXIgaXRlbUhpZGUgPSAnaGlkZScgaW4gaXRlbS5wcm9wcyA/IGl0ZW0ucHJvcHMuaGlkZSA6IChfZGVmYXVsdFByb3BzMyA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHMzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzMy5oaWRlO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1BeGlzSWQgPT09IGF4aXNJZCAmJiAoaW5jbHVkZUhpZGRlbiB8fCAhaXRlbUhpZGUpO1xuICAgICAgICAgIH0pLCBkYXRhS2V5LCBheGlzVHlwZSwgbGF5b3V0KTtcbiAgICAgICAgICBpZiAoZXJyb3JCYXJzRG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4gPSBlcnJvckJhcnNEb21haW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhdGVnb3JpY2FsICYmICh0eXBlID09PSAnbnVtYmVyJyB8fCBzY2FsZSAhPT0gJ2F1dG8nKSkge1xuICAgICAgICAgIGNhdGVnb3JpY2FsRG9tYWluID0gZ2V0RG9tYWluT2ZEYXRhQnlLZXkoZGlzcGxheWVkRGF0YSwgZGF0YUtleSwgJ2NhdGVnb3J5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDYXRlZ29yaWNhbCkge1xuICAgICAgICAvLyB0aGUgYXhpcyBpcyBhIGNhdGVnb3JpY2FsIGF4aXNcbiAgICAgICAgZG9tYWluID0gcmFuZ2UoMCwgbGVuKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhY2tHcm91cHMgJiYgc3RhY2tHcm91cHNbYXhpc0lkXSAmJiBzdGFja0dyb3Vwc1theGlzSWRdLmhhc1N0YWNrICYmIHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIHdoZW4gc3RhY2tPZmZzZXQgaXMgJ2V4cGFuZCcsIHRoZSBkb21haW4gbWF5IGJlIGNhbGN1bGF0ZWQgYXMgWzAsIDEuMDAwMDAwMDAwMDAyXVxuICAgICAgICBkb21haW4gPSBzdGFja09mZnNldCA9PT0gJ2V4cGFuZCcgPyBbMCwgMV0gOiBnZXREb21haW5PZlN0YWNrR3JvdXBzKHN0YWNrR3JvdXBzW2F4aXNJZF0uc3RhY2tHcm91cHMsIGRhdGFTdGFydEluZGV4LCBkYXRhRW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluID0gZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyhkaXNwbGF5ZWREYXRhLCBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgaXRlbUF4aXNJZCA9IGF4aXNJZEtleSBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wc1theGlzSWRLZXldIDogaXRlbS50eXBlLmRlZmF1bHRQcm9wc1theGlzSWRLZXldO1xuICAgICAgICAgIHZhciBpdGVtSGlkZSA9ICdoaWRlJyBpbiBpdGVtLnByb3BzID8gaXRlbS5wcm9wcy5oaWRlIDogaXRlbS50eXBlLmRlZmF1bHRQcm9wcy5oaWRlO1xuICAgICAgICAgIHJldHVybiBpdGVtQXhpc0lkID09PSBheGlzSWQgJiYgKGluY2x1ZGVIaWRkZW4gfHwgIWl0ZW1IaWRlKTtcbiAgICAgICAgfSksIHR5cGUsIGxheW91dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gVG8gZGV0ZWN0IHdldGhlciB0aGVyZSBpcyBhbnkgcmVmZXJlbmNlIGxpbmVzIHdob3NlIHByb3BzIGFsd2F5c1Nob3cgaXMgdHJ1ZVxuICAgICAgICBkb21haW4gPSBkZXRlY3RSZWZlcmVuY2VFbGVtZW50c0RvbWFpbihjaGlsZHJlbiwgZG9tYWluLCBheGlzSWQsIGF4aXNUeXBlLCB0aWNrcyk7XG4gICAgICAgIGlmIChjaGlsZERvbWFpbikge1xuICAgICAgICAgIGRvbWFpbiA9IHBhcnNlU3BlY2lmaWVkRG9tYWluKGNoaWxkRG9tYWluLCBkb21haW4sIGFsbG93RGF0YU92ZXJmbG93KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcnknICYmIGNoaWxkRG9tYWluKSB7XG4gICAgICAgIHZhciBheGlzRG9tYWluID0gY2hpbGREb21haW47XG4gICAgICAgIHZhciBpc0RvbWFpblZhbGlkID0gZG9tYWluLmV2ZXJ5KGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBheGlzRG9tYWluLmluZGV4T2YoZW50cnkpID49IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNEb21haW5WYWxpZCkge1xuICAgICAgICAgIGRvbWFpbiA9IGF4aXNEb21haW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgYXhpc0lkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkUHJvcHMpLCB7fSwge1xuICAgICAgYXhpc1R5cGU6IGF4aXNUeXBlLFxuICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICBjYXRlZ29yaWNhbERvbWFpbjogY2F0ZWdvcmljYWxEb21haW4sXG4gICAgICBkdXBsaWNhdGVEb21haW46IGR1cGxpY2F0ZURvbWFpbixcbiAgICAgIG9yaWdpbmFsRG9tYWluOiAoX2NoaWxkUHJvcHMkZG9tYWluMiA9IGNoaWxkUHJvcHMuZG9tYWluKSAhPT0gbnVsbCAmJiBfY2hpbGRQcm9wcyRkb21haW4yICE9PSB2b2lkIDAgPyBfY2hpbGRQcm9wcyRkb21haW4yIDogZGVmYXVsdERvbWFpbixcbiAgICAgIGlzQ2F0ZWdvcmljYWw6IGlzQ2F0ZWdvcmljYWwsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pKSk7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb25maWd1cmF0aW9uIG9mIGF4aXMgYnkgdGhlIG9wdGlvbnMgb2YgaXRlbSxcbiAqIHRoaXMga2luZCBvZiBheGlzIGRvZXMgbm90IGRpc3BsYXkgaW4gY2hhcnRcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICBMYXRlc3QgcHJvcHNcbiAqIEBwYXJhbSAge0FycmF5fSBncmFwaGljYWxJdGVtcyBUaGUgaW5zdGFuY2VzIG9mIGl0ZW1cbiAqIEBwYXJhbSAge1JlYWN0RWxlbWVudH0gQXhpcyAgICBBeGlzIENvbXBvbmVudFxuICogQHBhcmFtICB7U3RyaW5nfSBheGlzVHlwZSAgICAgIFRoZSB0eXBlIG9mIGF4aXMsIHhBeGlzIC0geC1heGlzLCB5QXhpcyAtIHktYXhpc1xuICogQHBhcmFtICB7U3RyaW5nfSBheGlzSWRLZXkgICAgIFRoZSB1bmlxdWUgaWQgb2YgYW4gYXhpc1xuICogQHBhcmFtICB7T2JqZWN0fSBzdGFja0dyb3VwcyAgIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgZGF0YSBzZXJpZXMgd2hlbiBhIGJydXNoIGlzIGFwcGxpZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhRW5kSW5kZXggICBUaGUgZW5kIGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgIENvbmZpZ3VyYXRpb25cbiAqL1xudmFyIGdldEF4aXNNYXBCeUl0ZW1zID0gZnVuY3Rpb24gZ2V0QXhpc01hcEJ5SXRlbXMocHJvcHMsIF9yZWYzKSB7XG4gIHZhciBncmFwaGljYWxJdGVtcyA9IF9yZWYzLmdyYXBoaWNhbEl0ZW1zLFxuICAgIEF4aXMgPSBfcmVmMy5BeGlzLFxuICAgIGF4aXNUeXBlID0gX3JlZjMuYXhpc1R5cGUsXG4gICAgYXhpc0lkS2V5ID0gX3JlZjMuYXhpc0lkS2V5LFxuICAgIHN0YWNrR3JvdXBzID0gX3JlZjMuc3RhY2tHcm91cHMsXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmMy5kYXRhU3RhcnRJbmRleCxcbiAgICBkYXRhRW5kSW5kZXggPSBfcmVmMy5kYXRhRW5kSW5kZXg7XG4gIHZhciBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXG4gICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGRpc3BsYXllZERhdGEgPSBnZXREaXNwbGF5ZWREYXRhKHByb3BzLmRhdGEsIHtcbiAgICBncmFwaGljYWxJdGVtczogZ3JhcGhpY2FsSXRlbXMsXG4gICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4XG4gIH0pO1xuICB2YXIgbGVuID0gZGlzcGxheWVkRGF0YS5sZW5ndGg7XG4gIHZhciBpc0NhdGVnb3JpY2FsID0gaXNDYXRlZ29yaWNhbEF4aXMobGF5b3V0LCBheGlzVHlwZSk7XG4gIHZhciBpbmRleCA9IC0xO1xuXG4gIC8vIFRoZSBkZWZhdWx0IHR5cGUgb2YgeC1heGlzIGlzIGNhdGVnb3J5IGF4aXMsXG4gIC8vIFRoZSBkZWZhdWx0IGNvbnRlbnRzIG9mIHgtYXhpcyBpcyB0aGUgc2VyaWFsIG51bWJlcnMgb2YgZGF0YVxuICAvLyBUaGUgZGVmYXVsdCB0eXBlIG9mIHktYXhpcyBpcyBudW1iZXIgYXhpc1xuICAvLyBUaGUgZGVmYXVsdCBjb250ZW50cyBvZiB5LWF4aXMgaXMgdGhlIGRvbWFpbiBvZiBkYXRhXG4gIHJldHVybiBncmFwaGljYWxJdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY2hpbGQpIHtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IGNoaWxkLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkLnR5cGUuZGVmYXVsdFByb3BzKSwgY2hpbGQucHJvcHMpIDogY2hpbGQucHJvcHM7XG4gICAgdmFyIGF4aXNJZCA9IGNoaWxkUHJvcHNbYXhpc0lkS2V5XTtcbiAgICB2YXIgb3JpZ2luYWxEb21haW4gPSBnZXREZWZhdWx0RG9tYWluQnlBeGlzVHlwZSgnbnVtYmVyJyk7XG4gICAgaWYgKCFyZXN1bHRbYXhpc0lkXSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBkb21haW47XG4gICAgICBpZiAoaXNDYXRlZ29yaWNhbCkge1xuICAgICAgICBkb21haW4gPSByYW5nZSgwLCBsZW4pO1xuICAgICAgfSBlbHNlIGlmIChzdGFja0dyb3VwcyAmJiBzdGFja0dyb3Vwc1theGlzSWRdICYmIHN0YWNrR3JvdXBzW2F4aXNJZF0uaGFzU3RhY2spIHtcbiAgICAgICAgZG9tYWluID0gZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyhzdGFja0dyb3Vwc1theGlzSWRdLnN0YWNrR3JvdXBzLCBkYXRhU3RhcnRJbmRleCwgZGF0YUVuZEluZGV4KTtcbiAgICAgICAgZG9tYWluID0gZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4oY2hpbGRyZW4sIGRvbWFpbiwgYXhpc0lkLCBheGlzVHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW4gPSBwYXJzZVNwZWNpZmllZERvbWFpbihvcmlnaW5hbERvbWFpbiwgZ2V0RG9tYWluT2ZJdGVtc1dpdGhTYW1lQXhpcyhkaXNwbGF5ZWREYXRhLCBncmFwaGljYWxJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgX2RlZmF1bHRQcm9wczQsIF9kZWZhdWx0UHJvcHM1O1xuICAgICAgICAgIHZhciBpdGVtQXhpc0lkID0gYXhpc0lkS2V5IGluIGl0ZW0ucHJvcHMgPyBpdGVtLnByb3BzW2F4aXNJZEtleV0gOiAoX2RlZmF1bHRQcm9wczQgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzKSA9PT0gbnVsbCB8fCBfZGVmYXVsdFByb3BzNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlZmF1bHRQcm9wczRbYXhpc0lkS2V5XTtcbiAgICAgICAgICB2YXIgaXRlbUhpZGUgPSAnaGlkZScgaW4gaXRlbS5wcm9wcyA/IGl0ZW0ucHJvcHMuaGlkZSA6IChfZGVmYXVsdFByb3BzNSA9IGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpID09PSBudWxsIHx8IF9kZWZhdWx0UHJvcHM1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVmYXVsdFByb3BzNS5oaWRlO1xuICAgICAgICAgIHJldHVybiBpdGVtQXhpc0lkID09PSBheGlzSWQgJiYgIWl0ZW1IaWRlO1xuICAgICAgICB9KSwgJ251bWJlcicsIGxheW91dCksIEF4aXMuZGVmYXVsdFByb3BzLmFsbG93RGF0YU92ZXJmbG93KTtcbiAgICAgICAgZG9tYWluID0gZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4oY2hpbGRyZW4sIGRvbWFpbiwgYXhpc0lkLCBheGlzVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGF4aXNUeXBlOiBheGlzVHlwZVxuICAgICAgfSwgQXhpcy5kZWZhdWx0UHJvcHMpLCB7fSwge1xuICAgICAgICBoaWRlOiB0cnVlLFxuICAgICAgICBvcmllbnRhdGlvbjogZ2V0KE9SSUVOVF9NQVAsIFwiXCIuY29uY2F0KGF4aXNUeXBlLCBcIi5cIikuY29uY2F0KGluZGV4ICUgMiksIG51bGwpLFxuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgb3JpZ2luYWxEb21haW46IG9yaWdpbmFsRG9tYWluLFxuICAgICAgICBpc0NhdGVnb3JpY2FsOiBpc0NhdGVnb3JpY2FsLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICAvLyBzcGVjaWZ5IHNjYWxlIHdoZW4gbm8gQXhpc1xuICAgICAgICAvLyBzY2FsZTogaXNDYXRlZ29yaWNhbCA/ICdiYW5kJyA6ICdsaW5lYXInLFxuICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYWxsIHgtYXhpcyBvciB5LWF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMgICAgICAgICAgTGF0ZXN0IHByb3BzXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF4aXNUeXBlICAgICAgIFRoZSB0eXBlIG9mIGF4aXNcbiAqIEBwYXJhbSAge1JlYWN0LkNvbXBvbmVudFR5cGV9ICBbQXhpc0NvbXBdICAgICAgQXhpcyBDb21wb25lbnRcbiAqIEBwYXJhbSAge0FycmF5fSAgZ3JhcGhpY2FsSXRlbXMgVGhlIGluc3RhbmNlcyBvZiBpdGVtXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YWNrR3JvdXBzICAgIFRoZSBpdGVtcyBncm91cGVkIGJ5IGF4aXNJZCBhbmQgc3RhY2tJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTdGFydEluZGV4ICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0YUVuZEluZGV4ICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIENvbmZpZ3VyYXRpb25cbiAqL1xudmFyIGdldEF4aXNNYXAgPSBmdW5jdGlvbiBnZXRBeGlzTWFwKHByb3BzLCBfcmVmNCkge1xuICB2YXIgX3JlZjQkYXhpc1R5cGUgPSBfcmVmNC5heGlzVHlwZSxcbiAgICBheGlzVHlwZSA9IF9yZWY0JGF4aXNUeXBlID09PSB2b2lkIDAgPyAneEF4aXMnIDogX3JlZjQkYXhpc1R5cGUsXG4gICAgQXhpc0NvbXAgPSBfcmVmNC5BeGlzQ29tcCxcbiAgICBncmFwaGljYWxJdGVtcyA9IF9yZWY0LmdyYXBoaWNhbEl0ZW1zLFxuICAgIHN0YWNrR3JvdXBzID0gX3JlZjQuc3RhY2tHcm91cHMsXG4gICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmNC5kYXRhU3RhcnRJbmRleCxcbiAgICBkYXRhRW5kSW5kZXggPSBfcmVmNC5kYXRhRW5kSW5kZXg7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgYXhpc0lkS2V5ID0gXCJcIi5jb25jYXQoYXhpc1R5cGUsIFwiSWRcIik7XG4gIC8vIEdldCBhbGwgdGhlIGluc3RhbmNlIG9mIEF4aXNcbiAgdmFyIGF4ZXMgPSBmaW5kQWxsQnlUeXBlKGNoaWxkcmVuLCBBeGlzQ29tcCk7XG4gIHZhciBheGlzTWFwID0ge307XG4gIGlmIChheGVzICYmIGF4ZXMubGVuZ3RoKSB7XG4gICAgYXhpc01hcCA9IGdldEF4aXNNYXBCeUF4ZXMocHJvcHMsIHtcbiAgICAgIGF4ZXM6IGF4ZXMsXG4gICAgICBncmFwaGljYWxJdGVtczogZ3JhcGhpY2FsSXRlbXMsXG4gICAgICBheGlzVHlwZTogYXhpc1R5cGUsXG4gICAgICBheGlzSWRLZXk6IGF4aXNJZEtleSxcbiAgICAgIHN0YWNrR3JvdXBzOiBzdGFja0dyb3VwcyxcbiAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcbiAgICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZ3JhcGhpY2FsSXRlbXMgJiYgZ3JhcGhpY2FsSXRlbXMubGVuZ3RoKSB7XG4gICAgYXhpc01hcCA9IGdldEF4aXNNYXBCeUl0ZW1zKHByb3BzLCB7XG4gICAgICBBeGlzOiBBeGlzQ29tcCxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcbiAgICAgIGF4aXNUeXBlOiBheGlzVHlwZSxcbiAgICAgIGF4aXNJZEtleTogYXhpc0lkS2V5LFxuICAgICAgc3RhY2tHcm91cHM6IHN0YWNrR3JvdXBzLFxuICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXhpc01hcDtcbn07XG52YXIgdG9vbHRpcFRpY2tzR2VuZXJhdG9yID0gZnVuY3Rpb24gdG9vbHRpcFRpY2tzR2VuZXJhdG9yKGF4aXNNYXApIHtcbiAgdmFyIGF4aXMgPSBnZXRBbnlFbGVtZW50T2ZPYmplY3QoYXhpc01hcCk7XG4gIHZhciB0b29sdGlwVGlja3MgPSBnZXRUaWNrc09mQXhpcyhheGlzLCBmYWxzZSwgdHJ1ZSk7XG4gIHJldHVybiB7XG4gICAgdG9vbHRpcFRpY2tzOiB0b29sdGlwVGlja3MsXG4gICAgb3JkZXJlZFRvb2x0aXBUaWNrczogc29ydEJ5KHRvb2x0aXBUaWNrcywgZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLmNvb3JkaW5hdGU7XG4gICAgfSksXG4gICAgdG9vbHRpcEF4aXM6IGF4aXMsXG4gICAgdG9vbHRpcEF4aXNCYW5kU2l6ZTogZ2V0QmFuZFNpemVPZkF4aXMoYXhpcywgdG9vbHRpcFRpY2tzKVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGRlZmF1bHQsIHJlc2V0IHN0YXRlIGZvciB0aGUgY2F0ZWdvcmljYWwgY2hhcnQuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcHMgb2JqZWN0IHRvIHVzZSB3aGVuIGNyZWF0aW5nIHRoZSBkZWZhdWx0IHN0YXRlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFdob2xlIG5ldyBzdGF0ZVxuICovXG5leHBvcnQgdmFyIGNyZWF0ZURlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdGF0ZShwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICBkZWZhdWx0U2hvd1Rvb2x0aXAgPSBwcm9wcy5kZWZhdWx0U2hvd1Rvb2x0aXA7XG4gIHZhciBicnVzaEl0ZW0gPSBmaW5kQ2hpbGRCeVR5cGUoY2hpbGRyZW4sIEJydXNoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICB2YXIgZW5kSW5kZXggPSAwO1xuICBpZiAocHJvcHMuZGF0YSAmJiBwcm9wcy5kYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgIGVuZEluZGV4ID0gcHJvcHMuZGF0YS5sZW5ndGggLSAxO1xuICB9XG4gIGlmIChicnVzaEl0ZW0gJiYgYnJ1c2hJdGVtLnByb3BzKSB7XG4gICAgaWYgKGJydXNoSXRlbS5wcm9wcy5zdGFydEluZGV4ID49IDApIHtcbiAgICAgIHN0YXJ0SW5kZXggPSBicnVzaEl0ZW0ucHJvcHMuc3RhcnRJbmRleDtcbiAgICB9XG4gICAgaWYgKGJydXNoSXRlbS5wcm9wcy5lbmRJbmRleCA+PSAwKSB7XG4gICAgICBlbmRJbmRleCA9IGJydXNoSXRlbS5wcm9wcy5lbmRJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaGFydFg6IDAsXG4gICAgY2hhcnRZOiAwLFxuICAgIGRhdGFTdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXgsXG4gICAgYWN0aXZlVG9vbHRpcEluZGV4OiAtMSxcbiAgICBpc1Rvb2x0aXBBY3RpdmU6IEJvb2xlYW4oZGVmYXVsdFNob3dUb29sdGlwKVxuICB9O1xufTtcbnZhciBoYXNHcmFwaGljYWxCYXJJdGVtID0gZnVuY3Rpb24gaGFzR3JhcGhpY2FsQmFySXRlbShncmFwaGljYWxJdGVtcykge1xuICBpZiAoIWdyYXBoaWNhbEl0ZW1zIHx8ICFncmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdyYXBoaWNhbEl0ZW1zLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGl0ZW0gJiYgaXRlbS50eXBlKTtcbiAgICByZXR1cm4gbmFtZSAmJiBuYW1lLmluZGV4T2YoJ0JhcicpID49IDA7XG4gIH0pO1xufTtcbnZhciBnZXRBeGlzTmFtZUJ5TGF5b3V0ID0gZnVuY3Rpb24gZ2V0QXhpc05hbWVCeUxheW91dChsYXlvdXQpIHtcbiAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWVyaWNBeGlzTmFtZTogJ3lBeGlzJyxcbiAgICAgIGNhdGVBeGlzTmFtZTogJ3hBeGlzJ1xuICAgIH07XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgIHJldHVybiB7XG4gICAgICBudW1lcmljQXhpc05hbWU6ICd4QXhpcycsXG4gICAgICBjYXRlQXhpc05hbWU6ICd5QXhpcydcbiAgICB9O1xuICB9XG4gIGlmIChsYXlvdXQgPT09ICdjZW50cmljJykge1xuICAgIHJldHVybiB7XG4gICAgICBudW1lcmljQXhpc05hbWU6ICdyYWRpdXNBeGlzJyxcbiAgICAgIGNhdGVBeGlzTmFtZTogJ2FuZ2xlQXhpcydcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbnVtZXJpY0F4aXNOYW1lOiAnYW5nbGVBeGlzJyxcbiAgICBjYXRlQXhpc05hbWU6ICdyYWRpdXNBeGlzJ1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG9mZnNldCBvZiBtYWluIHBhcnQgaW4gdGhlIHN2ZyBlbGVtZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtcy5wcm9wcyAgICAgICAgICBMYXRlc3QgcHJvcHNcbiAqIEBwYXJhbSAge0FycmF5fSAgcGFyYW1zLmdyYXBoaWNhbEl0ZW1zIFRoZSBpbnN0YW5jZXMgb2YgaXRlbVxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXMueEF4aXNNYXAgICAgICAgVGhlIGNvbmZpZ3VyYXRpb24gb2YgeC1heGlzXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtcy55QXhpc01hcCAgICAgICBUaGUgY29uZmlndXJhdGlvbiBvZiB5LWF4aXNcbiAqIEBwYXJhbSAge09iamVjdH0gcHJldkxlZ2VuZEJCb3ggICAgICAgIFRoZSBib3VuZGFyeSBib3ggb2YgbGVnZW5kXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvZmZzZXQgb2YgbWFpbiBwYXJ0IGluIHRoZSBzdmcgZWxlbWVudFxuICovXG52YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KF9yZWY1LCBwcmV2TGVnZW5kQkJveCkge1xuICB2YXIgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICBncmFwaGljYWxJdGVtcyA9IF9yZWY1LmdyYXBoaWNhbEl0ZW1zLFxuICAgIF9yZWY1JHhBeGlzTWFwID0gX3JlZjUueEF4aXNNYXAsXG4gICAgeEF4aXNNYXAgPSBfcmVmNSR4QXhpc01hcCA9PT0gdm9pZCAwID8ge30gOiBfcmVmNSR4QXhpc01hcCxcbiAgICBfcmVmNSR5QXhpc01hcCA9IF9yZWY1LnlBeGlzTWFwLFxuICAgIHlBeGlzTWFwID0gX3JlZjUkeUF4aXNNYXAgPT09IHZvaWQgMCA/IHt9IDogX3JlZjUkeUF4aXNNYXA7XG4gIHZhciB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgbWFyZ2luID0gcHJvcHMubWFyZ2luIHx8IHt9O1xuICB2YXIgYnJ1c2hJdGVtID0gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCBCcnVzaCk7XG4gIHZhciBsZWdlbmRJdGVtID0gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCBMZWdlbmQpO1xuICB2YXIgb2Zmc2V0SCA9IE9iamVjdC5rZXlzKHlBeGlzTWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaWQpIHtcbiAgICB2YXIgZW50cnkgPSB5QXhpc01hcFtpZF07XG4gICAgdmFyIG9yaWVudGF0aW9uID0gZW50cnkub3JpZW50YXRpb247XG4gICAgaWYgKCFlbnRyeS5taXJyb3IgJiYgIWVudHJ5LmhpZGUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG9yaWVudGF0aW9uLCByZXN1bHRbb3JpZW50YXRpb25dICsgZW50cnkud2lkdGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge1xuICAgIGxlZnQ6IG1hcmdpbi5sZWZ0IHx8IDAsXG4gICAgcmlnaHQ6IG1hcmdpbi5yaWdodCB8fCAwXG4gIH0pO1xuICB2YXIgb2Zmc2V0ViA9IE9iamVjdC5rZXlzKHhBeGlzTWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaWQpIHtcbiAgICB2YXIgZW50cnkgPSB4QXhpc01hcFtpZF07XG4gICAgdmFyIG9yaWVudGF0aW9uID0gZW50cnkub3JpZW50YXRpb247XG4gICAgaWYgKCFlbnRyeS5taXJyb3IgJiYgIWVudHJ5LmhpZGUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG9yaWVudGF0aW9uLCBnZXQocmVzdWx0LCBcIlwiLmNvbmNhdChvcmllbnRhdGlvbikpICsgZW50cnkuaGVpZ2h0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHtcbiAgICB0b3A6IG1hcmdpbi50b3AgfHwgMCxcbiAgICBib3R0b206IG1hcmdpbi5ib3R0b20gfHwgMFxuICB9KTtcbiAgdmFyIG9mZnNldCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb2Zmc2V0ViksIG9mZnNldEgpO1xuICB2YXIgYnJ1c2hCb3R0b20gPSBvZmZzZXQuYm90dG9tO1xuICBpZiAoYnJ1c2hJdGVtKSB7XG4gICAgb2Zmc2V0LmJvdHRvbSArPSBicnVzaEl0ZW0ucHJvcHMuaGVpZ2h0IHx8IEJydXNoLmRlZmF1bHRQcm9wcy5oZWlnaHQ7XG4gIH1cbiAgaWYgKGxlZ2VuZEl0ZW0gJiYgcHJldkxlZ2VuZEJCb3gpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1hcmdpbiBpcyBvcHRpb25hbCBpbiBwcm9wcyBidXQgcmVxdWlyZWQgaW4gYXBwZW5kT2Zmc2V0T2ZMZWdlbmRcbiAgICBvZmZzZXQgPSBhcHBlbmRPZmZzZXRPZkxlZ2VuZChvZmZzZXQsIGdyYXBoaWNhbEl0ZW1zLCBwcm9wcywgcHJldkxlZ2VuZEJCb3gpO1xuICB9XG4gIHZhciBvZmZzZXRXaWR0aCA9IHdpZHRoIC0gb2Zmc2V0LmxlZnQgLSBvZmZzZXQucmlnaHQ7XG4gIHZhciBvZmZzZXRIZWlnaHQgPSBoZWlnaHQgLSBvZmZzZXQudG9wIC0gb2Zmc2V0LmJvdHRvbTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgYnJ1c2hCb3R0b206IGJydXNoQm90dG9tXG4gIH0sIG9mZnNldCksIHt9LCB7XG4gICAgLy8gbmV2ZXIgcmV0dXJuIG5lZ2F0aXZlIHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aFxuICAgIHdpZHRoOiBNYXRoLm1heChvZmZzZXRXaWR0aCwgMCksXG4gICAgaGVpZ2h0OiBNYXRoLm1heChvZmZzZXRIZWlnaHQsIDApXG4gIH0pO1xufTtcbi8vIERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYXhpcywgdXNlZCBmb3IgY2FsY3VsYXRpb24gb2YgcmVsYXRpdmUgYmFyIHNpemVzXG52YXIgZ2V0Q2FydGVzaWFuQXhpc1NpemUgPSBmdW5jdGlvbiBnZXRDYXJ0ZXNpYW5BeGlzU2l6ZShheGlzT2JqLCBheGlzTmFtZSkge1xuICBpZiAoYXhpc05hbWUgPT09ICd4QXhpcycpIHtcbiAgICByZXR1cm4gYXhpc09ialtheGlzTmFtZV0ud2lkdGg7XG4gIH1cbiAgaWYgKGF4aXNOYW1lID09PSAneUF4aXMnKSB7XG4gICAgcmV0dXJuIGF4aXNPYmpbYXhpc05hbWVdLmhlaWdodDtcbiAgfVxuICAvLyBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBCYXIgY2hhcnRzIChpLmUuIGNoYXJ0cyB3aXRoIGNhcnRlc2lhbiBheGVzKSwgc28gd2Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IHZhciBnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgPSBmdW5jdGlvbiBnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQoX3JlZjYpIHtcbiAgdmFyIGNoYXJ0TmFtZSA9IF9yZWY2LmNoYXJ0TmFtZSxcbiAgICBHcmFwaGljYWxDaGlsZCA9IF9yZWY2LkdyYXBoaWNhbENoaWxkLFxuICAgIF9yZWY2JGRlZmF1bHRUb29sdGlwRSA9IF9yZWY2LmRlZmF1bHRUb29sdGlwRXZlbnRUeXBlLFxuICAgIGRlZmF1bHRUb29sdGlwRXZlbnRUeXBlID0gX3JlZjYkZGVmYXVsdFRvb2x0aXBFID09PSB2b2lkIDAgPyAnYXhpcycgOiBfcmVmNiRkZWZhdWx0VG9vbHRpcEUsXG4gICAgX3JlZjYkdmFsaWRhdGVUb29sdGlwID0gX3JlZjYudmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcyxcbiAgICB2YWxpZGF0ZVRvb2x0aXBFdmVudFR5cGVzID0gX3JlZjYkdmFsaWRhdGVUb29sdGlwID09PSB2b2lkIDAgPyBbJ2F4aXMnXSA6IF9yZWY2JHZhbGlkYXRlVG9vbHRpcCxcbiAgICBheGlzQ29tcG9uZW50cyA9IF9yZWY2LmF4aXNDb21wb25lbnRzLFxuICAgIGxlZ2VuZENvbnRlbnQgPSBfcmVmNi5sZWdlbmRDb250ZW50LFxuICAgIGZvcm1hdEF4aXNNYXAgPSBfcmVmNi5mb3JtYXRBeGlzTWFwLFxuICAgIGRlZmF1bHRQcm9wcyA9IF9yZWY2LmRlZmF1bHRQcm9wcztcbiAgdmFyIGdldEZvcm1hdEl0ZW1zID0gZnVuY3Rpb24gZ2V0Rm9ybWF0SXRlbXMocHJvcHMsIGN1cnJlbnRTdGF0ZSkge1xuICAgIHZhciBncmFwaGljYWxJdGVtcyA9IGN1cnJlbnRTdGF0ZS5ncmFwaGljYWxJdGVtcyxcbiAgICAgIHN0YWNrR3JvdXBzID0gY3VycmVudFN0YXRlLnN0YWNrR3JvdXBzLFxuICAgICAgb2Zmc2V0ID0gY3VycmVudFN0YXRlLm9mZnNldCxcbiAgICAgIHVwZGF0ZUlkID0gY3VycmVudFN0YXRlLnVwZGF0ZUlkLFxuICAgICAgZGF0YVN0YXJ0SW5kZXggPSBjdXJyZW50U3RhdGUuZGF0YVN0YXJ0SW5kZXgsXG4gICAgICBkYXRhRW5kSW5kZXggPSBjdXJyZW50U3RhdGUuZGF0YUVuZEluZGV4O1xuICAgIHZhciBiYXJTaXplID0gcHJvcHMuYmFyU2l6ZSxcbiAgICAgIGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICAgIGJhckdhcCA9IHByb3BzLmJhckdhcCxcbiAgICAgIGJhckNhdGVnb3J5R2FwID0gcHJvcHMuYmFyQ2F0ZWdvcnlHYXAsXG4gICAgICBnbG9iYWxNYXhCYXJTaXplID0gcHJvcHMubWF4QmFyU2l6ZTtcbiAgICB2YXIgX2dldEF4aXNOYW1lQnlMYXlvdXQgPSBnZXRBeGlzTmFtZUJ5TGF5b3V0KGxheW91dCksXG4gICAgICBudW1lcmljQXhpc05hbWUgPSBfZ2V0QXhpc05hbWVCeUxheW91dC5udW1lcmljQXhpc05hbWUsXG4gICAgICBjYXRlQXhpc05hbWUgPSBfZ2V0QXhpc05hbWVCeUxheW91dC5jYXRlQXhpc05hbWU7XG4gICAgdmFyIGhhc0JhciA9IGhhc0dyYXBoaWNhbEJhckl0ZW0oZ3JhcGhpY2FsSXRlbXMpO1xuICAgIHZhciBmb3JtYXR0ZWRJdGVtcyA9IFtdO1xuICAgIGdyYXBoaWNhbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICB2YXIgZGlzcGxheWVkRGF0YSA9IGdldERpc3BsYXllZERhdGEocHJvcHMuZGF0YSwge1xuICAgICAgICBncmFwaGljYWxJdGVtczogW2l0ZW1dLFxuICAgICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXG4gICAgICAgIGRhdGFFbmRJbmRleDogZGF0YUVuZEluZGV4XG4gICAgICB9KTtcbiAgICAgIHZhciBpdGVtUHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IGl0ZW0ucHJvcHM7XG4gICAgICB2YXIgZGF0YUtleSA9IGl0ZW1Qcm9wcy5kYXRhS2V5LFxuICAgICAgICBjaGlsZE1heEJhclNpemUgPSBpdGVtUHJvcHMubWF4QmFyU2l6ZTtcbiAgICAgIC8vIGF4aXNJZCBvZiB0aGUgbnVtZXJpY2FsIGF4aXNcbiAgICAgIHZhciBudW1lcmljQXhpc0lkID0gaXRlbVByb3BzW1wiXCIuY29uY2F0KG51bWVyaWNBeGlzTmFtZSwgXCJJZFwiKV07XG4gICAgICAvLyBheGlzSWQgb2YgdGhlIGNhdGVnb3JpY2FsIGF4aXNcbiAgICAgIHZhciBjYXRlQXhpc0lkID0gaXRlbVByb3BzW1wiXCIuY29uY2F0KGNhdGVBeGlzTmFtZSwgXCJJZFwiKV07XG4gICAgICB2YXIgYXhpc09iakluaXRpYWxWYWx1ZSA9IHt9O1xuICAgICAgdmFyIGF4aXNPYmogPSBheGlzQ29tcG9uZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcbiAgICAgICAgdmFyIF9pdGVtJHR5cGUkZGlzcGxheU5hbSwgX2l0ZW0kdHlwZTtcbiAgICAgICAgLy8gbWFwIG9mIGF4aXNJZCB0byBheGlzIGZvciBhIHNwZWNpZmljIGF4aXMgdHlwZVxuICAgICAgICB2YXIgYXhpc01hcCA9IGN1cnJlbnRTdGF0ZVtcIlwiLmNvbmNhdChlbnRyeS5heGlzVHlwZSwgXCJNYXBcIildO1xuICAgICAgICAvLyBheGlzSWQgb2YgYXhpcyB3ZSBhcmUgY3VycmVudGx5IGNvbXB1dGluZ1xuICAgICAgICB2YXIgaWQgPSBpdGVtUHJvcHNbXCJcIi5jb25jYXQoZW50cnkuYXhpc1R5cGUsIFwiSWRcIildO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0ZWxsIHRoZSB1c2VyIGluIGRldiBtb2RlIHRoYXQgdGhlaXIgY29uZmlndXJhdGlvbiBpcyBpbmNvcnJlY3QgaWYgd2UgY2Fubm90IGZpbmQgYSBtYXRjaCBiZXR3ZWVuXG4gICAgICAgICAqIGF4aXNJZCBvbiB0aGUgY2hhcnQgYW5kIGF4aXNJZCBvbiB0aGUgYXhpcy4gekF4aXMgZG9lcyBub3QgZ2V0IHBhc3NlZCBpbiB0aGUgbWFwIGZvciBDb21wb3NlZENoYXJ0LFxuICAgICAgICAgKiBsZWF2ZSBpdCBvdXQgb2YgdGhlIGNoZWNrIGZvciBub3cuXG4gICAgICAgICAqL1xuICAgICAgICAhKGF4aXNNYXAgJiYgYXhpc01hcFtpZF0gfHwgZW50cnkuYXhpc1R5cGUgPT09ICd6QXhpcycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIlNwZWNpZnlpbmcgYShuKSBcIi5jb25jYXQoZW50cnkuYXhpc1R5cGUsIFwiSWQgcmVxdWlyZXMgYSBjb3JyZXNwb25kaW5nIFwiKS5jb25jYXQoZW50cnkuYXhpc1R5cGVcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSBzaG91bGQgc3RvcCByZWFkaW5nIGRhdGEgZnJvbSBSZWFjdEVsZW1lbnRzXG4gICAgICAgICwgXCJJZCBvbiB0aGUgdGFyZ2V0ZWQgZ3JhcGhpY2FsIGNvbXBvbmVudCBcIikuY29uY2F0KChfaXRlbSR0eXBlJGRpc3BsYXlOYW0gPSBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCB8fCAoX2l0ZW0kdHlwZSA9IGl0ZW0udHlwZSkgPT09IG51bGwgfHwgX2l0ZW0kdHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW0kdHlwZS5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2l0ZW0kdHlwZSRkaXNwbGF5TmFtICE9PSB2b2lkIDAgPyBfaXRlbSR0eXBlJGRpc3BsYXlOYW0gOiAnJykpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgICAvLyB0aGUgYXhpcyB3ZSBhcmUgY3VycmVudGx5IGZvcm1hdHRpbmdcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzTWFwW2lkXTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIGVudHJ5LmF4aXNUeXBlLCBheGlzKSwgXCJcIi5jb25jYXQoZW50cnkuYXhpc1R5cGUsIFwiVGlja3NcIiksIGdldFRpY2tzT2ZBeGlzKGF4aXMpKSk7XG4gICAgICB9LCBheGlzT2JqSW5pdGlhbFZhbHVlKTtcbiAgICAgIHZhciBjYXRlQXhpcyA9IGF4aXNPYmpbY2F0ZUF4aXNOYW1lXTtcbiAgICAgIHZhciBjYXRlVGlja3MgPSBheGlzT2JqW1wiXCIuY29uY2F0KGNhdGVBeGlzTmFtZSwgXCJUaWNrc1wiKV07XG4gICAgICB2YXIgc3RhY2tlZERhdGEgPSBzdGFja0dyb3VwcyAmJiBzdGFja0dyb3Vwc1tudW1lcmljQXhpc0lkXSAmJiBzdGFja0dyb3Vwc1tudW1lcmljQXhpc0lkXS5oYXNTdGFjayAmJiBnZXRTdGFja2VkRGF0YU9mSXRlbShpdGVtLCBzdGFja0dyb3Vwc1tudW1lcmljQXhpc0lkXS5zdGFja0dyb3Vwcyk7XG4gICAgICB2YXIgaXRlbUlzQmFyID0gZ2V0RGlzcGxheU5hbWUoaXRlbS50eXBlKS5pbmRleE9mKCdCYXInKSA+PSAwO1xuICAgICAgdmFyIGJhbmRTaXplID0gZ2V0QmFuZFNpemVPZkF4aXMoY2F0ZUF4aXMsIGNhdGVUaWNrcyk7XG4gICAgICB2YXIgYmFyUG9zaXRpb24gPSBbXTtcbiAgICAgIHZhciBzaXplTGlzdCA9IGhhc0JhciAmJiBnZXRCYXJTaXplTGlzdCh7XG4gICAgICAgIGJhclNpemU6IGJhclNpemUsXG4gICAgICAgIHN0YWNrR3JvdXBzOiBzdGFja0dyb3VwcyxcbiAgICAgICAgdG90YWxTaXplOiBnZXRDYXJ0ZXNpYW5BeGlzU2l6ZShheGlzT2JqLCBjYXRlQXhpc05hbWUpXG4gICAgICB9KTtcbiAgICAgIGlmIChpdGVtSXNCYXIpIHtcbiAgICAgICAgdmFyIF9yZWY3LCBfZ2V0QmFuZFNpemVPZkF4aXM7XG4gICAgICAgIC8vIElmIGl0IGlzIGJhciwgY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiBiYXJcbiAgICAgICAgdmFyIG1heEJhclNpemUgPSBpc05pbChjaGlsZE1heEJhclNpemUpID8gZ2xvYmFsTWF4QmFyU2l6ZSA6IGNoaWxkTWF4QmFyU2l6ZTtcbiAgICAgICAgdmFyIGJhckJhbmRTaXplID0gKF9yZWY3ID0gKF9nZXRCYW5kU2l6ZU9mQXhpcyA9IGdldEJhbmRTaXplT2ZBeGlzKGNhdGVBeGlzLCBjYXRlVGlja3MsIHRydWUpKSAhPT0gbnVsbCAmJiBfZ2V0QmFuZFNpemVPZkF4aXMgIT09IHZvaWQgMCA/IF9nZXRCYW5kU2l6ZU9mQXhpcyA6IG1heEJhclNpemUpICE9PSBudWxsICYmIF9yZWY3ICE9PSB2b2lkIDAgPyBfcmVmNyA6IDA7XG4gICAgICAgIGJhclBvc2l0aW9uID0gZ2V0QmFyUG9zaXRpb24oe1xuICAgICAgICAgIGJhckdhcDogYmFyR2FwLFxuICAgICAgICAgIGJhckNhdGVnb3J5R2FwOiBiYXJDYXRlZ29yeUdhcCxcbiAgICAgICAgICBiYW5kU2l6ZTogYmFyQmFuZFNpemUgIT09IGJhbmRTaXplID8gYmFyQmFuZFNpemUgOiBiYW5kU2l6ZSxcbiAgICAgICAgICBzaXplTGlzdDogc2l6ZUxpc3RbY2F0ZUF4aXNJZF0sXG4gICAgICAgICAgbWF4QmFyU2l6ZTogbWF4QmFyU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJhckJhbmRTaXplICE9PSBiYW5kU2l6ZSkge1xuICAgICAgICAgIGJhclBvc2l0aW9uID0gYmFyUG9zaXRpb24ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcyksIHt9LCB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcy5wb3NpdGlvbiksIHt9LCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3MucG9zaXRpb24ub2Zmc2V0IC0gYmFyQmFuZFNpemUgLyAyXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB3ZSBzaG91bGQgc3RvcCByZWFkaW5nIGRhdGEgZnJvbSBSZWFjdEVsZW1lbnRzXG4gICAgICB2YXIgY29tcG9zZWRGbiA9IGl0ZW0gJiYgaXRlbS50eXBlICYmIGl0ZW0udHlwZS5nZXRDb21wb3NlZERhdGE7XG4gICAgICBpZiAoY29tcG9zZWRGbikge1xuICAgICAgICBmb3JtYXR0ZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb21wb3NlZEZuKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc09iaiksIHt9LCB7XG4gICAgICAgICAgICBkaXNwbGF5ZWREYXRhOiBkaXNwbGF5ZWREYXRhLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgZGF0YUtleTogZGF0YUtleSxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBiYW5kU2l6ZTogYmFuZFNpemUsXG4gICAgICAgICAgICBiYXJQb3NpdGlvbjogYmFyUG9zaXRpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIHN0YWNrZWREYXRhOiBzdGFja2VkRGF0YSxcbiAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICAgICAgICB9KSkpLCB7fSwgX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAga2V5OiBpdGVtLmtleSB8fCBcIml0ZW0tXCIuY29uY2F0KGluZGV4KVxuICAgICAgICAgIH0sIG51bWVyaWNBeGlzTmFtZSwgYXhpc09ialtudW1lcmljQXhpc05hbWVdKSwgY2F0ZUF4aXNOYW1lLCBheGlzT2JqW2NhdGVBeGlzTmFtZV0pLCBcImFuaW1hdGlvbklkXCIsIHVwZGF0ZUlkKSksXG4gICAgICAgICAgY2hpbGRJbmRleDogcGFyc2VDaGlsZEluZGV4KGl0ZW0sIHByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3JtYXR0ZWRJdGVtcztcbiAgfTtcblxuICAvKipcbiAgICogVGhlIEF4aXNNYXBzIGFyZSBleHBlbnNpdmUgdG8gcmVuZGVyIG9uIGxhcmdlIGRhdGEgc2V0c1xuICAgKiBzbyBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIHN0b3JlIHRoZW0gaW4gc3RhdGUgYW5kIG9ubHkgdXBkYXRlIHRoZW0gd2hlbiBuZWNlc3NhcnlcbiAgICogdGhleSBhcmUgZGVwZW5kZW50IHVwb24gdGhlIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2ZcbiAgICogdGhlIGJydXNoIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBtZXRob2QgaXMgY2FsbGVkIF9hZnRlcl9cbiAgICogdGhlIHN0YXRlIGlzIHVwZGF0ZWQgd2l0aCBhbnkgbmV3IHN0YXJ0L2VuZCBpbmRpY2VzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAgICAgICAgICBUaGUgcHJvcHMgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHVwZGF0aW5nIHRoZSBheGlzbWFwc1xuICAgKiBkYXRhU3RhcnRJbmRleDogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBkYXRhIHNlcmllcyB3aGVuIGEgYnJ1c2ggaXMgYXBwbGllZFxuICAgKiBkYXRhRW5kSW5kZXg6IFRoZSBlbmQgaW5kZXggb2YgdGhlIGRhdGEgc2VyaWVzIHdoZW4gYSBicnVzaCBpcyBhcHBsaWVkXG4gICAqIHVwZGF0ZUlkOiBUaGUgdXBkYXRlIGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RhdGUgICAgICBQcmV2IHN0YXRlXG4gICAqIEByZXR1cm4ge09iamVjdH0gc3RhdGUgTmV3IHN0YXRlIHRvIHNldFxuICAgKi9cbiAgdmFyIHVwZGF0ZVN0YXRlT2ZBeGlzTWFwc09mZnNldEFuZFN0YWNrR3JvdXBzID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoX3JlZjgsIHByZXZTdGF0ZSkge1xuICAgIHZhciBwcm9wcyA9IF9yZWY4LnByb3BzLFxuICAgICAgZGF0YVN0YXJ0SW5kZXggPSBfcmVmOC5kYXRhU3RhcnRJbmRleCxcbiAgICAgIGRhdGFFbmRJbmRleCA9IF9yZWY4LmRhdGFFbmRJbmRleCxcbiAgICAgIHVwZGF0ZUlkID0gX3JlZjgudXBkYXRlSWQ7XG4gICAgaWYgKCF2YWxpZGF0ZVdpZHRoSGVpZ2h0KHtcbiAgICAgIHByb3BzOiBwcm9wc1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXG4gICAgICBzdGFja09mZnNldCA9IHByb3BzLnN0YWNrT2Zmc2V0LFxuICAgICAgZGF0YSA9IHByb3BzLmRhdGEsXG4gICAgICByZXZlcnNlU3RhY2tPcmRlciA9IHByb3BzLnJldmVyc2VTdGFja09yZGVyO1xuICAgIHZhciBfZ2V0QXhpc05hbWVCeUxheW91dDIgPSBnZXRBeGlzTmFtZUJ5TGF5b3V0KGxheW91dCksXG4gICAgICBudW1lcmljQXhpc05hbWUgPSBfZ2V0QXhpc05hbWVCeUxheW91dDIubnVtZXJpY0F4aXNOYW1lLFxuICAgICAgY2F0ZUF4aXNOYW1lID0gX2dldEF4aXNOYW1lQnlMYXlvdXQyLmNhdGVBeGlzTmFtZTtcbiAgICB2YXIgZ3JhcGhpY2FsSXRlbXMgPSBmaW5kQWxsQnlUeXBlKGNoaWxkcmVuLCBHcmFwaGljYWxDaGlsZCk7XG4gICAgdmFyIHN0YWNrR3JvdXBzID0gZ2V0U3RhY2tHcm91cHNCeUF4aXNJZChkYXRhLCBncmFwaGljYWxJdGVtcywgXCJcIi5jb25jYXQobnVtZXJpY0F4aXNOYW1lLCBcIklkXCIpLCBcIlwiLmNvbmNhdChjYXRlQXhpc05hbWUsIFwiSWRcIiksIHN0YWNrT2Zmc2V0LCByZXZlcnNlU3RhY2tPcmRlcik7XG4gICAgdmFyIGF4aXNPYmogPSBheGlzQ29tcG9uZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcbiAgICAgIHZhciBuYW1lID0gXCJcIi5jb25jYXQoZW50cnkuYXhpc1R5cGUsIFwiTWFwXCIpO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgZ2V0QXhpc01hcChwcm9wcywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSksIHt9LCB7XG4gICAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcbiAgICAgICAgc3RhY2tHcm91cHM6IGVudHJ5LmF4aXNUeXBlID09PSBudW1lcmljQXhpc05hbWUgJiYgc3RhY2tHcm91cHMsXG4gICAgICAgIGRhdGFTdGFydEluZGV4OiBkYXRhU3RhcnRJbmRleCxcbiAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICAgIH0pKSkpO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgb2Zmc2V0ID0gY2FsY3VsYXRlT2Zmc2V0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYXhpc09iaiksIHt9LCB7XG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBncmFwaGljYWxJdGVtczogZ3JhcGhpY2FsSXRlbXNcbiAgICB9KSwgcHJldlN0YXRlID09PSBudWxsIHx8IHByZXZTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlN0YXRlLmxlZ2VuZEJCb3gpO1xuICAgIE9iamVjdC5rZXlzKGF4aXNPYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYXhpc09ialtrZXldID0gZm9ybWF0QXhpc01hcChwcm9wcywgYXhpc09ialtrZXldLCBvZmZzZXQsIGtleS5yZXBsYWNlKCdNYXAnLCAnJyksIGNoYXJ0TmFtZSk7XG4gICAgfSk7XG4gICAgdmFyIGNhdGVBeGlzTWFwID0gYXhpc09ialtcIlwiLmNvbmNhdChjYXRlQXhpc05hbWUsIFwiTWFwXCIpXTtcbiAgICB2YXIgdGlja3NPYmogPSB0b29sdGlwVGlja3NHZW5lcmF0b3IoY2F0ZUF4aXNNYXApO1xuICAgIHZhciBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyA9IGdldEZvcm1hdEl0ZW1zKHByb3BzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXNPYmopLCB7fSwge1xuICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXG4gICAgICB1cGRhdGVJZDogdXBkYXRlSWQsXG4gICAgICBncmFwaGljYWxJdGVtczogZ3JhcGhpY2FsSXRlbXMsXG4gICAgICBzdGFja0dyb3Vwczogc3RhY2tHcm91cHMsXG4gICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH0pKTtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zOiBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyxcbiAgICAgIGdyYXBoaWNhbEl0ZW1zOiBncmFwaGljYWxJdGVtcyxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgc3RhY2tHcm91cHM6IHN0YWNrR3JvdXBzXG4gICAgfSwgdGlja3NPYmopLCBheGlzT2JqKTtcbiAgfTtcbiAgdmFyIENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIoX3Byb3BzKSB7XG4gICAgICB2YXIgX3Byb3BzJGlkLCBfcHJvcHMkdGhyb3R0bGVEZWxheTtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXRlZ29yaWNhbENoYXJ0V3JhcHBlcik7XG4gICAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIFtfcHJvcHNdKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJldmVudEVtaXR0ZXJTeW1ib2xcIiwgU3ltYm9sKCdyZWNoYXJ0c0V2ZW50RW1pdHRlcicpKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJhY2Nlc3NpYmlsaXR5TWFuYWdlclwiLCBuZXcgQWNjZXNzaWJpbGl0eU1hbmFnZXIoKSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTGVnZW5kQkJveFVwZGF0ZVwiLCBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGFTdGFydEluZGV4ID0gX3RoaXMkc3RhdGUuZGF0YVN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBkYXRhRW5kSW5kZXggPSBfdGhpcyRzdGF0ZS5kYXRhRW5kSW5kZXgsXG4gICAgICAgICAgICB1cGRhdGVJZCA9IF90aGlzJHN0YXRlLnVwZGF0ZUlkO1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgbGVnZW5kQkJveDogYm94XG4gICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xuICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXG4gICAgICAgICAgICB1cGRhdGVJZDogdXBkYXRlSWRcbiAgICAgICAgICB9LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgICAgIGxlZ2VuZEJCb3g6IGJveFxuICAgICAgICAgIH0pKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVSZWNlaXZlU3luY0V2ZW50XCIsIGZ1bmN0aW9uIChjSWQsIGRhdGEsIGVtaXR0ZXIpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnN5bmNJZCA9PT0gY0lkKSB7XG4gICAgICAgICAgaWYgKGVtaXR0ZXIgPT09IF90aGlzLmV2ZW50RW1pdHRlclN5bWJvbCAmJiB0eXBlb2YgX3RoaXMucHJvcHMuc3luY01ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5hcHBseVN5bmNFdmVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQnJ1c2hDaGFuZ2VcIiwgZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gX3JlZjkuc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleCA9IF9yZWY5LmVuZEluZGV4O1xuICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2hhbmdlcyBpZiB0aGUgZXh0ZW50cyBvZiB0aGUgYnJ1c2ggaGF2ZSBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICAgIGlmIChzdGFydEluZGV4ICE9PSBfdGhpcy5zdGF0ZS5kYXRhU3RhcnRJbmRleCB8fCBlbmRJbmRleCAhPT0gX3RoaXMuc3RhdGUuZGF0YUVuZEluZGV4KSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUlkID0gX3RoaXMuc3RhdGUudXBkYXRlSWQ7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBlbmRJbmRleFxuICAgICAgICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoe1xuICAgICAgICAgICAgICBwcm9wczogX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIGRhdGFTdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICBkYXRhRW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICB1cGRhdGVJZDogdXBkYXRlSWRcbiAgICAgICAgICAgIH0sIF90aGlzLnN0YXRlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMudHJpZ2dlclN5bmNFdmVudCh7XG4gICAgICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgIGRhdGFFbmRJbmRleDogZW5kSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIGVudGVyaW5nIGNoYXJ0XG4gICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGUgICAgICAgICAgICAgIEV2ZW50IG9iamVjdFxuICAgICAgICogQHJldHVybiB7TnVsbH0gICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZUVudGVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtb3VzZSA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgaWYgKG1vdXNlKSB7XG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1vdXNlKSwge30sIHtcbiAgICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9uZXh0U3RhdGUpO1xuICAgICAgICAgIF90aGlzLnRyaWdnZXJTeW5jRXZlbnQoX25leHRTdGF0ZSk7XG4gICAgICAgICAgdmFyIG9uTW91c2VFbnRlciA9IF90aGlzLnByb3BzLm9uTW91c2VFbnRlcjtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvbk1vdXNlRW50ZXIpKSB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIoX25leHRTdGF0ZSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0cmlnZ2VyZWRBZnRlck1vdXNlTW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbW91c2UgPSBfdGhpcy5nZXRNb3VzZUluZm8oZSk7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBtb3VzZSA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbW91c2UpLCB7fSwge1xuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogdHJ1ZVxuICAgICAgICB9KSA6IHtcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgIF90aGlzLnRyaWdnZXJTeW5jRXZlbnQobmV4dFN0YXRlKTtcbiAgICAgICAgdmFyIG9uTW91c2VNb3ZlID0gX3RoaXMucHJvcHMub25Nb3VzZU1vdmU7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uTW91c2VNb3ZlKSkge1xuICAgICAgICAgIG9uTW91c2VNb3ZlKG5leHRTdGF0ZSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaGFuZGxlciBvZiBtb3VzZSBlbnRlcmluZyBhIHNjYXR0ZXJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbCBUaGUgYWN0aXZlIHNjYXR0ZXJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbm8gcmV0dXJuXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVJdGVtTW91c2VFbnRlclwiLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBhY3RpdmVJdGVtOiBlbCxcbiAgICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IGVsLnRvb2x0aXBQYXlsb2FkLFxuICAgICAgICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogZWwudG9vbHRpcFBvc2l0aW9uIHx8IHtcbiAgICAgICAgICAgICAgeDogZWwuY3gsXG4gICAgICAgICAgICAgIHk6IGVsLmN5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGhhbmRsZXIgb2YgbW91c2UgbGVhdmluZyBhIHNjYXR0ZXJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbm8gcmV0dXJuXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVJdGVtTW91c2VMZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoYW5kbGVyIG9mIG1vdXNlIG1vdmluZyBpbiBjaGFydFxuICAgICAgICogQHBhcmFtICB7UmVhY3QuTW91c2VFdmVudH0gZSAgICAgICAgRXZlbnQgb2JqZWN0XG4gICAgICAgKiBAcmV0dXJuIHt2b2lkfSBubyByZXR1cm5cbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU1vdXNlTW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgX3RoaXMudGhyb3R0bGVUcmlnZ2VyZWRBZnRlck1vdXNlTW92ZShlKTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaGFuZGxlciBpZiBtb3VzZSBsZWF2aW5nIGNoYXJ0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBFdmVudCBvYmplY3RcbiAgICAgICAqIEByZXR1cm4ge051bGx9IG5vIHJldHVyblxuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlTW91c2VMZWF2ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpcy50aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlLmNhbmNlbCgpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcbiAgICAgICAgX3RoaXMudHJpZ2dlclN5bmNFdmVudChuZXh0U3RhdGUpO1xuICAgICAgICB2YXIgb25Nb3VzZUxlYXZlID0gX3RoaXMucHJvcHMub25Nb3VzZUxlYXZlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvbk1vdXNlTGVhdmUpKSB7XG4gICAgICAgICAgb25Nb3VzZUxlYXZlKG5leHRTdGF0ZSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU91dGVyRXZlbnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGdldFJlYWN0RXZlbnRCeVR5cGUoZSk7XG4gICAgICAgIHZhciBldmVudCA9IGdldChfdGhpcy5wcm9wcywgXCJcIi5jb25jYXQoZXZlbnROYW1lKSk7XG4gICAgICAgIGlmIChldmVudE5hbWUgJiYgaXNGdW5jdGlvbihldmVudCkpIHtcbiAgICAgICAgICB2YXIgX21vdXNlO1xuICAgICAgICAgIHZhciBtb3VzZTtcbiAgICAgICAgICBpZiAoLy4qdG91Y2guKi9pLnRlc3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgbW91c2UgPSBfdGhpcy5nZXRNb3VzZUluZm8oZS5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdXNlID0gX3RoaXMuZ2V0TW91c2VJbmZvKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudCgoX21vdXNlID0gbW91c2UpICE9PSBudWxsICYmIF9tb3VzZSAhPT0gdm9pZCAwID8gX21vdXNlIDoge30sIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVDbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbW91c2UgPSBfdGhpcy5nZXRNb3VzZUluZm8oZSk7XG4gICAgICAgIGlmIChtb3VzZSkge1xuICAgICAgICAgIHZhciBfbmV4dFN0YXRlMiA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbW91c2UpLCB7fSwge1xuICAgICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX25leHRTdGF0ZTIpO1xuICAgICAgICAgIF90aGlzLnRyaWdnZXJTeW5jRXZlbnQoX25leHRTdGF0ZTIpO1xuICAgICAgICAgIHZhciBvbkNsaWNrID0gX3RoaXMucHJvcHMub25DbGljaztcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvbkNsaWNrKSkge1xuICAgICAgICAgICAgb25DbGljayhfbmV4dFN0YXRlMiwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVNb3VzZURvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9uTW91c2VEb3duID0gX3RoaXMucHJvcHMub25Nb3VzZURvd247XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uTW91c2VEb3duKSkge1xuICAgICAgICAgIHZhciBfbmV4dFN0YXRlMyA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgICBvbk1vdXNlRG93bihfbmV4dFN0YXRlMywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZU1vdXNlVXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9uTW91c2VVcCA9IF90aGlzLnByb3BzLm9uTW91c2VVcDtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob25Nb3VzZVVwKSkge1xuICAgICAgICAgIHZhciBfbmV4dFN0YXRlNCA9IF90aGlzLmdldE1vdXNlSW5mbyhlKTtcbiAgICAgICAgICBvbk1vdXNlVXAoX25leHRTdGF0ZTQsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVUb3VjaE1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgIT0gbnVsbCAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfdGhpcy50aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlKGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVUb3VjaFN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzICE9IG51bGwgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3RoaXMuaGFuZGxlTW91c2VEb3duKGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYW5kbGVUb3VjaEVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAhPSBudWxsICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLmhhbmRsZU1vdXNlVXAoZS5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInRyaWdnZXJTeW5jRXZlbnRcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLnN5bmNJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnRDZW50ZXIuZW1pdChTWU5DX0VWRU5ULCBfdGhpcy5wcm9wcy5zeW5jSWQsIGRhdGEsIF90aGlzLmV2ZW50RW1pdHRlclN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFwcGx5U3luY0V2ZW50XCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzLmxheW91dCxcbiAgICAgICAgICBzeW5jTWV0aG9kID0gX3RoaXMkcHJvcHMuc3luY01ldGhvZDtcbiAgICAgICAgdmFyIHVwZGF0ZUlkID0gX3RoaXMuc3RhdGUudXBkYXRlSWQ7XG4gICAgICAgIHZhciBkYXRhU3RhcnRJbmRleCA9IGRhdGEuZGF0YVN0YXJ0SW5kZXgsXG4gICAgICAgICAgZGF0YUVuZEluZGV4ID0gZGF0YS5kYXRhRW5kSW5kZXg7XG4gICAgICAgIGlmIChkYXRhLmRhdGFTdGFydEluZGV4ICE9PSB1bmRlZmluZWQgfHwgZGF0YS5kYXRhRW5kSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgZGF0YVN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgICAgZGF0YUVuZEluZGV4OiBkYXRhRW5kSW5kZXhcbiAgICAgICAgICB9LCB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3Vwcyh7XG4gICAgICAgICAgICBwcm9wczogX3RoaXMucHJvcHMsXG4gICAgICAgICAgICBkYXRhU3RhcnRJbmRleDogZGF0YVN0YXJ0SW5kZXgsXG4gICAgICAgICAgICBkYXRhRW5kSW5kZXg6IGRhdGFFbmRJbmRleCxcbiAgICAgICAgICAgIHVwZGF0ZUlkOiB1cGRhdGVJZFxuICAgICAgICAgIH0sIF90aGlzLnN0YXRlKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aXZlVG9vbHRpcEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhcnRYID0gZGF0YS5jaGFydFgsXG4gICAgICAgICAgICBjaGFydFkgPSBkYXRhLmNoYXJ0WTtcbiAgICAgICAgICB2YXIgYWN0aXZlVG9vbHRpcEluZGV4ID0gZGF0YS5hY3RpdmVUb29sdGlwSW5kZXg7XG4gICAgICAgICAgdmFyIF90aGlzJHN0YXRlMiA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc3RhdGUyLm9mZnNldCxcbiAgICAgICAgICAgIHRvb2x0aXBUaWNrcyA9IF90aGlzJHN0YXRlMi50b29sdGlwVGlja3M7XG4gICAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBzeW5jTWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24uIElmIHRoZXJlIGlzIGFuIGFwcGxpY2F0aW9uIHNwZWNpZmljIGFsZ29yaXRobVxuICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4ID0gc3luY01ldGhvZCh0b29sdGlwVGlja3MsIGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3luY01ldGhvZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgLy8gU2V0IGFjdGl2ZVRvb2x0aXBJbmRleCB0byB0aGUgaW5kZXggd2l0aCB0aGUgc2FtZSB2YWx1ZSBhcyBkYXRhLmFjdGl2ZUxhYmVsXG4gICAgICAgICAgICAvLyBGb3IgbG9vcCBpbnN0ZWFkIG9mIGZpbmRJbmRleCBiZWNhdXNlIHRoZSBsYXR0ZXIgaXMgdmVyeSBzbG93IGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIGFjdGl2ZVRvb2x0aXBJbmRleCA9IC0xOyAvLyBpbiBjYXNlIHdlIGNhbm5vdCBmaW5kIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvb2x0aXBUaWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodG9vbHRpcFRpY2tzW2ldLnZhbHVlID09PSBkYXRhLmFjdGl2ZUxhYmVsKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmlld0JveCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb2Zmc2V0KSwge30sIHtcbiAgICAgICAgICAgIHg6IG9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgeTogb2Zmc2V0LnRvcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFdoZW4gYSBjYXRlZ29yaWNhbCBjaGFydCBpcyBjb21iaW5lZCB3aXRoIGFub3RoZXIgY2hhcnQsIHRoZSB2YWx1ZSBvZiBjaGFydFhcbiAgICAgICAgICAvLyBhbmQgY2hhcnRZIG1heSBiZXlvbmQgdGhlIGJvdW5kYXJpZXMuXG4gICAgICAgICAgdmFyIHZhbGlkYXRlQ2hhcnRYID0gTWF0aC5taW4oY2hhcnRYLCB2aWV3Qm94LnggKyB2aWV3Qm94LndpZHRoKTtcbiAgICAgICAgICB2YXIgdmFsaWRhdGVDaGFydFkgPSBNYXRoLm1pbihjaGFydFksIHZpZXdCb3gueSArIHZpZXdCb3guaGVpZ2h0KTtcbiAgICAgICAgICB2YXIgYWN0aXZlTGFiZWwgPSB0b29sdGlwVGlja3NbYWN0aXZlVG9vbHRpcEluZGV4XSAmJiB0b29sdGlwVGlja3NbYWN0aXZlVG9vbHRpcEluZGV4XS52YWx1ZTtcbiAgICAgICAgICB2YXIgYWN0aXZlUGF5bG9hZCA9IGdldFRvb2x0aXBDb250ZW50KF90aGlzLnN0YXRlLCBfdGhpcy5wcm9wcy5kYXRhLCBhY3RpdmVUb29sdGlwSW5kZXgpO1xuICAgICAgICAgIHZhciBhY3RpdmVDb29yZGluYXRlID0gdG9vbHRpcFRpY2tzW2FjdGl2ZVRvb2x0aXBJbmRleF0gPyB7XG4gICAgICAgICAgICB4OiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHRvb2x0aXBUaWNrc1thY3RpdmVUb29sdGlwSW5kZXhdLmNvb3JkaW5hdGUgOiB2YWxpZGF0ZUNoYXJ0WCxcbiAgICAgICAgICAgIHk6IGxheW91dCA9PT0gJ2hvcml6b250YWwnID8gdmFsaWRhdGVDaGFydFkgOiB0b29sdGlwVGlja3NbYWN0aXZlVG9vbHRpcEluZGV4XS5jb29yZGluYXRlXG4gICAgICAgICAgfSA6IG9yaWdpbkNvb3JkaW5hdGU7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkYXRhKSwge30sIHtcbiAgICAgICAgICAgIGFjdGl2ZUxhYmVsOiBhY3RpdmVMYWJlbCxcbiAgICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IGFjdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAgICBhY3RpdmVQYXlsb2FkOiBhY3RpdmVQYXlsb2FkLFxuICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4OiBhY3RpdmVUb29sdGlwSW5kZXhcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlckN1cnNvclwiLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX2VsZW1lbnQkcHJvcHMkYWN0aXZlO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUzID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlID0gX3RoaXMkc3RhdGUzLmlzVG9vbHRpcEFjdGl2ZSxcbiAgICAgICAgICBhY3RpdmVDb29yZGluYXRlID0gX3RoaXMkc3RhdGUzLmFjdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAgYWN0aXZlUGF5bG9hZCA9IF90aGlzJHN0YXRlMy5hY3RpdmVQYXlsb2FkLFxuICAgICAgICAgIG9mZnNldCA9IF90aGlzJHN0YXRlMy5vZmZzZXQsXG4gICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4ID0gX3RoaXMkc3RhdGUzLmFjdGl2ZVRvb2x0aXBJbmRleCxcbiAgICAgICAgICB0b29sdGlwQXhpc0JhbmRTaXplID0gX3RoaXMkc3RhdGUzLnRvb2x0aXBBeGlzQmFuZFNpemU7XG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRUeXBlID0gX3RoaXMuZ2V0VG9vbHRpcEV2ZW50VHlwZSgpO1xuICAgICAgICAvLyBUaGUgY3Vyc29yIGlzIGEgcGFydCBvZiB0aGUgVG9vbHRpcCwgYW5kIGl0IHNob3VsZCBiZSBzaG93biAoYnkgZGVmYXVsdCkgd2hlbiB0aGUgVG9vbHRpcCBpcyBhY3RpdmUuXG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IChfZWxlbWVudCRwcm9wcyRhY3RpdmUgPSBlbGVtZW50LnByb3BzLmFjdGl2ZSkgIT09IG51bGwgJiYgX2VsZW1lbnQkcHJvcHMkYWN0aXZlICE9PSB2b2lkIDAgPyBfZWxlbWVudCRwcm9wcyRhY3RpdmUgOiBpc1Rvb2x0aXBBY3RpdmU7XG4gICAgICAgIHZhciBsYXlvdXQgPSBfdGhpcy5wcm9wcy5sYXlvdXQ7XG4gICAgICAgIHZhciBrZXkgPSBlbGVtZW50LmtleSB8fCAnX3JlY2hhcnRzLWN1cnNvcic7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDdXJzb3IsIHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhY3RpdmVDb29yZGluYXRlOiBhY3RpdmVDb29yZGluYXRlLFxuICAgICAgICAgIGFjdGl2ZVBheWxvYWQ6IGFjdGl2ZVBheWxvYWQsXG4gICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4OiBhY3RpdmVUb29sdGlwSW5kZXgsXG4gICAgICAgICAgY2hhcnROYW1lOiBjaGFydE5hbWUsXG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgdG9vbHRpcEF4aXNCYW5kU2l6ZTogdG9vbHRpcEF4aXNCYW5kU2l6ZSxcbiAgICAgICAgICB0b29sdGlwRXZlbnRUeXBlOiB0b29sdGlwRXZlbnRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyUG9sYXJBeGlzXCIsIGZ1bmN0aW9uIChlbGVtZW50LCBkaXNwbGF5TmFtZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGF4aXNUeXBlID0gZ2V0KGVsZW1lbnQsICd0eXBlLmF4aXNUeXBlJyk7XG4gICAgICAgIHZhciBheGlzTWFwID0gZ2V0KF90aGlzLnN0YXRlLCBcIlwiLmNvbmNhdChheGlzVHlwZSwgXCJNYXBcIikpO1xuICAgICAgICB2YXIgZWxlbWVudERlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgIHZhciBlbGVtZW50UHJvcHMgPSBlbGVtZW50RGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnREZWZhdWx0UHJvcHMpLCBlbGVtZW50LnByb3BzKSA6IGVsZW1lbnQucHJvcHM7XG4gICAgICAgIHZhciBheGlzT3B0aW9uID0gYXhpc01hcCAmJiBheGlzTWFwW2VsZW1lbnRQcm9wc1tcIlwiLmNvbmNhdChheGlzVHlwZSwgXCJJZFwiKV1dO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2Nsb25lRWxlbWVudChlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGF4aXNPcHRpb24pLCB7fSwge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xzeChheGlzVHlwZSwgYXhpc09wdGlvbi5jbGFzc05hbWUpLFxuICAgICAgICAgIGtleTogZWxlbWVudC5rZXkgfHwgXCJcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiLVwiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgIHRpY2tzOiBnZXRUaWNrc09mQXhpcyhheGlzT3B0aW9uLCB0cnVlKVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJQb2xhckdyaWRcIiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICByYWRpYWxMaW5lcyA9IF9lbGVtZW50JHByb3BzLnJhZGlhbExpbmVzLFxuICAgICAgICAgIHBvbGFyQW5nbGVzID0gX2VsZW1lbnQkcHJvcHMucG9sYXJBbmdsZXMsXG4gICAgICAgICAgcG9sYXJSYWRpdXMgPSBfZWxlbWVudCRwcm9wcy5wb2xhclJhZGl1cztcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlNCA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIHJhZGl1c0F4aXNNYXAgPSBfdGhpcyRzdGF0ZTQucmFkaXVzQXhpc01hcCxcbiAgICAgICAgICBhbmdsZUF4aXNNYXAgPSBfdGhpcyRzdGF0ZTQuYW5nbGVBeGlzTWFwO1xuICAgICAgICB2YXIgcmFkaXVzQXhpcyA9IGdldEFueUVsZW1lbnRPZk9iamVjdChyYWRpdXNBeGlzTWFwKTtcbiAgICAgICAgdmFyIGFuZ2xlQXhpcyA9IGdldEFueUVsZW1lbnRPZk9iamVjdChhbmdsZUF4aXNNYXApO1xuICAgICAgICB2YXIgY3ggPSBhbmdsZUF4aXMuY3gsXG4gICAgICAgICAgY3kgPSBhbmdsZUF4aXMuY3ksXG4gICAgICAgICAgaW5uZXJSYWRpdXMgPSBhbmdsZUF4aXMuaW5uZXJSYWRpdXMsXG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSBhbmdsZUF4aXMub3V0ZXJSYWRpdXM7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICBwb2xhckFuZ2xlczogQXJyYXkuaXNBcnJheShwb2xhckFuZ2xlcykgPyBwb2xhckFuZ2xlcyA6IGdldFRpY2tzT2ZBeGlzKGFuZ2xlQXhpcywgdHJ1ZSkubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmNvb3JkaW5hdGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcG9sYXJSYWRpdXM6IEFycmF5LmlzQXJyYXkocG9sYXJSYWRpdXMpID8gcG9sYXJSYWRpdXMgOiBnZXRUaWNrc09mQXhpcyhyYWRpdXNBeGlzLCB0cnVlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuY29vcmRpbmF0ZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcbiAgICAgICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCAncG9sYXItZ3JpZCcsXG4gICAgICAgICAgcmFkaWFsTGluZXM6IHJhZGlhbExpbmVzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIERyYXcgbGVnZW5kXG4gICAgICAgKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9ICAgICAgICAgICAgVGhlIGluc3RhbmNlIG9mIExlZ2VuZFxuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyTGVnZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zID0gX3RoaXMuc3RhdGUuZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXM7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzMi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczIuaGVpZ2h0O1xuICAgICAgICB2YXIgbWFyZ2luID0gX3RoaXMucHJvcHMubWFyZ2luIHx8IHt9O1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSB3aWR0aCAtIChtYXJnaW4ubGVmdCB8fCAwKSAtIChtYXJnaW4ucmlnaHQgfHwgMCk7XG4gICAgICAgIHZhciBwcm9wcyA9IGdldExlZ2VuZFByb3BzKHtcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXM6IGZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLFxuICAgICAgICAgIGxlZ2VuZFdpZHRoOiBsZWdlbmRXaWR0aCxcbiAgICAgICAgICBsZWdlbmRDb250ZW50OiBsZWdlbmRDb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW0gPSBwcm9wcy5pdGVtLFxuICAgICAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KGl0ZW0sIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3RoZXJQcm9wcyksIHt9LCB7XG4gICAgICAgICAgY2hhcnRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgY2hhcnRIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICBvbkJCb3hVcGRhdGU6IF90aGlzLmhhbmRsZUxlZ2VuZEJCb3hVcGRhdGVcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIERyYXcgVG9vbHRpcFxuICAgICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSAgVGhlIGluc3RhbmNlIG9mIFRvb2x0aXBcbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlclRvb2x0aXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3Rvb2x0aXBJdGVtJHByb3BzJGFjO1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczMuY2hpbGRyZW4sXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eUxheWVyID0gX3RoaXMkcHJvcHMzLmFjY2Vzc2liaWxpdHlMYXllcjtcbiAgICAgICAgdmFyIHRvb2x0aXBJdGVtID0gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCBUb29sdGlwKTtcbiAgICAgICAgaWYgKCF0b29sdGlwSXRlbSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTUgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmUgPSBfdGhpcyRzdGF0ZTUuaXNUb29sdGlwQWN0aXZlLFxuICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGUgPSBfdGhpcyRzdGF0ZTUuYWN0aXZlQ29vcmRpbmF0ZSxcbiAgICAgICAgICBhY3RpdmVQYXlsb2FkID0gX3RoaXMkc3RhdGU1LmFjdGl2ZVBheWxvYWQsXG4gICAgICAgICAgYWN0aXZlTGFiZWwgPSBfdGhpcyRzdGF0ZTUuYWN0aXZlTGFiZWwsXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc3RhdGU1Lm9mZnNldDtcblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gc2V0IGlzQWN0aXZlIG9uIHRoZSBUb29sdGlwLFxuICAgICAgICAvLyBhbmQgd2UgcmVzcGVjdCB0aGUgdXNlciB0byBlbmFibGUgY3VzdG9taXNhdGlvbi5cbiAgICAgICAgLy8gVGhlIFRvb2x0aXAgaXMgYWN0aXZlIGlmIHRoZSB1c2VyIGhhcyBzZXQgaXNBY3RpdmUsIG9yIGlmIHRoZSB0b29sdGlwIGlzIGFjdGl2ZSBkdWUgdG8gYSBtb3VzZSBldmVudC5cbiAgICAgICAgdmFyIGlzQWN0aXZlID0gKF90b29sdGlwSXRlbSRwcm9wcyRhYyA9IHRvb2x0aXBJdGVtLnByb3BzLmFjdGl2ZSkgIT09IG51bGwgJiYgX3Rvb2x0aXBJdGVtJHByb3BzJGFjICE9PSB2b2lkIDAgPyBfdG9vbHRpcEl0ZW0kcHJvcHMkYWMgOiBpc1Rvb2x0aXBBY3RpdmU7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KHRvb2x0aXBJdGVtLCB7XG4gICAgICAgICAgdmlld0JveDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvZmZzZXQpLCB7fSwge1xuICAgICAgICAgICAgeDogb2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICB5OiBvZmZzZXQudG9wXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgICAgICBsYWJlbDogYWN0aXZlTGFiZWwsXG4gICAgICAgICAgcGF5bG9hZDogaXNBY3RpdmUgPyBhY3RpdmVQYXlsb2FkIDogW10sXG4gICAgICAgICAgY29vcmRpbmF0ZTogYWN0aXZlQ29vcmRpbmF0ZSxcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGF5ZXI6IGFjY2Vzc2liaWxpdHlMYXllclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlckJydXNoXCIsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczQgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBtYXJnaW4gPSBfdGhpcyRwcm9wczQubWFyZ2luLFxuICAgICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczQuZGF0YTtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlNiA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIG9mZnNldCA9IF90aGlzJHN0YXRlNi5vZmZzZXQsXG4gICAgICAgICAgZGF0YVN0YXJ0SW5kZXggPSBfdGhpcyRzdGF0ZTYuZGF0YVN0YXJ0SW5kZXgsXG4gICAgICAgICAgZGF0YUVuZEluZGV4ID0gX3RoaXMkc3RhdGU2LmRhdGFFbmRJbmRleCxcbiAgICAgICAgICB1cGRhdGVJZCA9IF90aGlzJHN0YXRlNi51cGRhdGVJZDtcblxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgYnJ1c2ggd2hlbiBjaGlsZHJlbiB1cGRhdGVcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICAgIGtleTogZWxlbWVudC5rZXkgfHwgJ19yZWNoYXJ0cy1icnVzaCcsXG4gICAgICAgICAgb25DaGFuZ2U6IGNvbWJpbmVFdmVudEhhbmRsZXJzKF90aGlzLmhhbmRsZUJydXNoQ2hhbmdlLCBlbGVtZW50LnByb3BzLm9uQ2hhbmdlKSxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHg6IGlzTnVtYmVyKGVsZW1lbnQucHJvcHMueCkgPyBlbGVtZW50LnByb3BzLnggOiBvZmZzZXQubGVmdCxcbiAgICAgICAgICB5OiBpc051bWJlcihlbGVtZW50LnByb3BzLnkpID8gZWxlbWVudC5wcm9wcy55IDogb2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQgKyBvZmZzZXQuYnJ1c2hCb3R0b20gLSAobWFyZ2luLmJvdHRvbSB8fCAwKSxcbiAgICAgICAgICB3aWR0aDogaXNOdW1iZXIoZWxlbWVudC5wcm9wcy53aWR0aCkgPyBlbGVtZW50LnByb3BzLndpZHRoIDogb2Zmc2V0LndpZHRoLFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IGRhdGFTdGFydEluZGV4LFxuICAgICAgICAgIGVuZEluZGV4OiBkYXRhRW5kSW5kZXgsXG4gICAgICAgICAgdXBkYXRlSWQ6IFwiYnJ1c2gtXCIuY29uY2F0KHVwZGF0ZUlkKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlclJlZmVyZW5jZUVsZW1lbnRcIiwgZnVuY3Rpb24gKGVsZW1lbnQsIGRpc3BsYXlOYW1lLCBpbmRleCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMyID0gX3RoaXMsXG4gICAgICAgICAgY2xpcFBhdGhJZCA9IF90aGlzMi5jbGlwUGF0aElkO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGU3ID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgeEF4aXNNYXAgPSBfdGhpcyRzdGF0ZTcueEF4aXNNYXAsXG4gICAgICAgICAgeUF4aXNNYXAgPSBfdGhpcyRzdGF0ZTcueUF4aXNNYXAsXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc3RhdGU3Lm9mZnNldDtcbiAgICAgICAgdmFyIGVsZW1lbnREZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzIHx8IHt9O1xuICAgICAgICB2YXIgX2VsZW1lbnQkcHJvcHMyID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICBfZWxlbWVudCRwcm9wczIkeEF4aXMgPSBfZWxlbWVudCRwcm9wczIueEF4aXNJZCxcbiAgICAgICAgICB4QXhpc0lkID0gX2VsZW1lbnQkcHJvcHMyJHhBeGlzID09PSB2b2lkIDAgPyBlbGVtZW50RGVmYXVsdFByb3BzLnhBeGlzSWQgOiBfZWxlbWVudCRwcm9wczIkeEF4aXMsXG4gICAgICAgICAgX2VsZW1lbnQkcHJvcHMyJHlBeGlzID0gX2VsZW1lbnQkcHJvcHMyLnlBeGlzSWQsXG4gICAgICAgICAgeUF4aXNJZCA9IF9lbGVtZW50JHByb3BzMiR5QXhpcyA9PT0gdm9pZCAwID8gZWxlbWVudERlZmF1bHRQcm9wcy55QXhpc0lkIDogX2VsZW1lbnQkcHJvcHMyJHlBeGlzO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2Nsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSB8fCBcIlwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCItXCIpLmNvbmNhdChpbmRleCksXG4gICAgICAgICAgeEF4aXM6IHhBeGlzTWFwW3hBeGlzSWRdLFxuICAgICAgICAgIHlBeGlzOiB5QXhpc01hcFt5QXhpc0lkXSxcbiAgICAgICAgICB2aWV3Qm94OiB7XG4gICAgICAgICAgICB4OiBvZmZzZXQubGVmdCxcbiAgICAgICAgICAgIHk6IG9mZnNldC50b3AsXG4gICAgICAgICAgICB3aWR0aDogb2Zmc2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvZmZzZXQuaGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGlwUGF0aElkOiBjbGlwUGF0aElkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyQWN0aXZlUG9pbnRzXCIsIGZ1bmN0aW9uIChfcmVmMTApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfcmVmMTAuaXRlbSxcbiAgICAgICAgICBhY3RpdmVQb2ludCA9IF9yZWYxMC5hY3RpdmVQb2ludCxcbiAgICAgICAgICBiYXNlUG9pbnQgPSBfcmVmMTAuYmFzZVBvaW50LFxuICAgICAgICAgIGNoaWxkSW5kZXggPSBfcmVmMTAuY2hpbGRJbmRleCxcbiAgICAgICAgICBpc1JhbmdlID0gX3JlZjEwLmlzUmFuZ2U7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgLy8gaXRlbSBpcyBub3QgYSBSZWFjdCBFbGVtZW50IHNvIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZSBkZWZhdWx0UHJvcHMuXG4gICAgICAgIHZhciBrZXkgPSBpdGVtLnByb3BzLmtleTtcbiAgICAgICAgdmFyIGl0ZW1JdGVtUHJvcHMgPSBpdGVtLml0ZW0udHlwZS5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5pdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5pdGVtLnByb3BzKSA6IGl0ZW0uaXRlbS5wcm9wcztcbiAgICAgICAgdmFyIGFjdGl2ZURvdCA9IGl0ZW1JdGVtUHJvcHMuYWN0aXZlRG90LFxuICAgICAgICAgIGRhdGFLZXkgPSBpdGVtSXRlbVByb3BzLmRhdGFLZXk7XG4gICAgICAgIHZhciBkb3RQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgICAgZGF0YUtleTogZGF0YUtleSxcbiAgICAgICAgICBjeDogYWN0aXZlUG9pbnQueCxcbiAgICAgICAgICBjeTogYWN0aXZlUG9pbnQueSxcbiAgICAgICAgICByOiA0LFxuICAgICAgICAgIGZpbGw6IGdldE1haW5Db2xvck9mR3JhcGhpY0l0ZW0oaXRlbS5pdGVtKSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICBzdHJva2U6ICcjZmZmJyxcbiAgICAgICAgICBwYXlsb2FkOiBhY3RpdmVQb2ludC5wYXlsb2FkLFxuICAgICAgICAgIHZhbHVlOiBhY3RpdmVQb2ludC52YWx1ZVxuICAgICAgICB9LCBmaWx0ZXJQcm9wcyhhY3RpdmVEb3QsIGZhbHNlKSksIGFkYXB0RXZlbnRIYW5kbGVycyhhY3RpdmVEb3QpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIucmVuZGVyQWN0aXZlRG90KGFjdGl2ZURvdCwgZG90UHJvcHMsIFwiXCIuY29uY2F0KGtleSwgXCItYWN0aXZlUG9pbnQtXCIpLmNvbmNhdChjaGlsZEluZGV4KSkpO1xuICAgICAgICBpZiAoYmFzZVBvaW50KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIucmVuZGVyQWN0aXZlRG90KGFjdGl2ZURvdCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkb3RQcm9wcyksIHt9LCB7XG4gICAgICAgICAgICBjeDogYmFzZVBvaW50LngsXG4gICAgICAgICAgICBjeTogYmFzZVBvaW50LnlcbiAgICAgICAgICB9KSwgXCJcIi5jb25jYXQoa2V5LCBcIi1iYXNlUG9pbnQtXCIpLmNvbmNhdChjaGlsZEluZGV4KSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmFuZ2UpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyR3JhcGhpY0NoaWxkXCIsIGZ1bmN0aW9uIChlbGVtZW50LCBkaXNwbGF5TmFtZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfdGhpcy5maWx0ZXJGb3JtYXRJdGVtKGVsZW1lbnQsIGRpc3BsYXlOYW1lLCBpbmRleCk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRUeXBlID0gX3RoaXMuZ2V0VG9vbHRpcEV2ZW50VHlwZSgpO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGU4ID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlID0gX3RoaXMkc3RhdGU4LmlzVG9vbHRpcEFjdGl2ZSxcbiAgICAgICAgICB0b29sdGlwQXhpcyA9IF90aGlzJHN0YXRlOC50b29sdGlwQXhpcyxcbiAgICAgICAgICBhY3RpdmVUb29sdGlwSW5kZXggPSBfdGhpcyRzdGF0ZTguYWN0aXZlVG9vbHRpcEluZGV4LFxuICAgICAgICAgIGFjdGl2ZUxhYmVsID0gX3RoaXMkc3RhdGU4LmFjdGl2ZUxhYmVsO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIHRvb2x0aXBJdGVtID0gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCBUb29sdGlwKTtcbiAgICAgICAgLy8gaXRlbSBpcyBub3QgYSBSZWFjdCBFbGVtZW50IHNvIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZSBkZWZhdWx0UHJvcHNcbiAgICAgICAgdmFyIF9pdGVtJHByb3BzID0gaXRlbS5wcm9wcyxcbiAgICAgICAgICBwb2ludHMgPSBfaXRlbSRwcm9wcy5wb2ludHMsXG4gICAgICAgICAgaXNSYW5nZSA9IF9pdGVtJHByb3BzLmlzUmFuZ2UsXG4gICAgICAgICAgYmFzZUxpbmUgPSBfaXRlbSRwcm9wcy5iYXNlTGluZTtcbiAgICAgICAgdmFyIGl0ZW1JdGVtUHJvcHMgPSBpdGVtLml0ZW0udHlwZS5kZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5pdGVtLnR5cGUuZGVmYXVsdFByb3BzKSwgaXRlbS5pdGVtLnByb3BzKSA6IGl0ZW0uaXRlbS5wcm9wcztcbiAgICAgICAgdmFyIGFjdGl2ZURvdCA9IGl0ZW1JdGVtUHJvcHMuYWN0aXZlRG90LFxuICAgICAgICAgIGhpZGUgPSBpdGVtSXRlbVByb3BzLmhpZGUsXG4gICAgICAgICAgYWN0aXZlQmFyID0gaXRlbUl0ZW1Qcm9wcy5hY3RpdmVCYXIsXG4gICAgICAgICAgYWN0aXZlU2hhcGUgPSBpdGVtSXRlbVByb3BzLmFjdGl2ZVNoYXBlO1xuICAgICAgICB2YXIgaGFzQWN0aXZlID0gQm9vbGVhbighaGlkZSAmJiBpc1Rvb2x0aXBBY3RpdmUgJiYgdG9vbHRpcEl0ZW0gJiYgKGFjdGl2ZURvdCB8fCBhY3RpdmVCYXIgfHwgYWN0aXZlU2hhcGUpKTtcbiAgICAgICAgdmFyIGl0ZW1FdmVudHMgPSB7fTtcbiAgICAgICAgaWYgKHRvb2x0aXBFdmVudFR5cGUgIT09ICdheGlzJyAmJiB0b29sdGlwSXRlbSAmJiB0b29sdGlwSXRlbS5wcm9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgaXRlbUV2ZW50cyA9IHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IGNvbWJpbmVFdmVudEhhbmRsZXJzKF90aGlzLmhhbmRsZUl0ZW1Nb3VzZUVudGVyLCBlbGVtZW50LnByb3BzLm9uQ2xpY2spXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0b29sdGlwRXZlbnRUeXBlICE9PSAnYXhpcycpIHtcbiAgICAgICAgICBpdGVtRXZlbnRzID0ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiBjb21iaW5lRXZlbnRIYW5kbGVycyhfdGhpcy5oYW5kbGVJdGVtTW91c2VMZWF2ZSwgZWxlbWVudC5wcm9wcy5vbk1vdXNlTGVhdmUpLFxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiBjb21iaW5lRXZlbnRIYW5kbGVycyhfdGhpcy5oYW5kbGVJdGVtTW91c2VFbnRlciwgZWxlbWVudC5wcm9wcy5vbk1vdXNlRW50ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JhcGhpY2FsSXRlbSA9IC8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQoZWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpdGVtLnByb3BzKSwgaXRlbUV2ZW50cykpO1xuICAgICAgICBmdW5jdGlvbiBmaW5kV2l0aFBheWxvYWQoZW50cnkpIHtcbiAgICAgICAgICAvLyBUT0RPIG5lZWRzIHRvIHZlcmlmeSBkYXRhS2V5IGlzIEZ1bmN0aW9uXG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB0b29sdGlwQXhpcy5kYXRhS2V5ID09PSAnZnVuY3Rpb24nID8gdG9vbHRpcEF4aXMuZGF0YUtleShlbnRyeS5wYXlsb2FkKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0FjdGl2ZSkge1xuICAgICAgICAgIGlmIChhY3RpdmVUb29sdGlwSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVBvaW50LCBiYXNlUG9pbnQ7XG4gICAgICAgICAgICBpZiAodG9vbHRpcEF4aXMuZGF0YUtleSAmJiAhdG9vbHRpcEF4aXMuYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgLy8gbnVtYmVyIHRyYW5zZm9ybSB0byBzdHJpbmdcbiAgICAgICAgICAgICAgdmFyIHNwZWNpZmllZEtleSA9IHR5cGVvZiB0b29sdGlwQXhpcy5kYXRhS2V5ID09PSAnZnVuY3Rpb24nID8gZmluZFdpdGhQYXlsb2FkIDogJ3BheWxvYWQuJy5jb25jYXQodG9vbHRpcEF4aXMuZGF0YUtleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgYWN0aXZlUG9pbnQgPSBmaW5kRW50cnlJbkFycmF5KHBvaW50cywgc3BlY2lmaWVkS2V5LCBhY3RpdmVMYWJlbCk7XG4gICAgICAgICAgICAgIGJhc2VQb2ludCA9IGlzUmFuZ2UgJiYgYmFzZUxpbmUgJiYgZmluZEVudHJ5SW5BcnJheShiYXNlTGluZSwgc3BlY2lmaWVkS2V5LCBhY3RpdmVMYWJlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY3RpdmVQb2ludCA9IHBvaW50cyA9PT0gbnVsbCB8fCBwb2ludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50c1thY3RpdmVUb29sdGlwSW5kZXhdO1xuICAgICAgICAgICAgICBiYXNlUG9pbnQgPSBpc1JhbmdlICYmIGJhc2VMaW5lICYmIGJhc2VMaW5lW2FjdGl2ZVRvb2x0aXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aXZlU2hhcGUgfHwgYWN0aXZlQmFyKSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVJbmRleCA9IGVsZW1lbnQucHJvcHMuYWN0aXZlSW5kZXggIT09IHVuZGVmaW5lZCA/IGVsZW1lbnQucHJvcHMuYWN0aXZlSW5kZXggOiBhY3RpdmVUb29sdGlwSW5kZXg7XG4gICAgICAgICAgICAgIHJldHVybiBbLyojX19QVVJFX18qL2Nsb25lRWxlbWVudChlbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5wcm9wcyksIGl0ZW1FdmVudHMpLCB7fSwge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiBhY3RpdmVJbmRleFxuICAgICAgICAgICAgICB9KSksIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05pbChhY3RpdmVQb2ludCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtncmFwaGljYWxJdGVtXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLnJlbmRlckFjdGl2ZVBvaW50cyh7XG4gICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICBhY3RpdmVQb2ludDogYWN0aXZlUG9pbnQsXG4gICAgICAgICAgICAgICAgYmFzZVBvaW50OiBiYXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogYWN0aXZlVG9vbHRpcEluZGV4LFxuICAgICAgICAgICAgICAgIGlzUmFuZ2U6IGlzUmFuZ2VcbiAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF90aGlzJGdldEl0ZW1CeVhZO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBoaXQgdGhpcyBibG9jayBpZiBjb25zdW1lciB1c2VzIGEgVG9vbHRpcCB3aXRob3V0IFhBeGlzIGFuZC9vciBZQXhpcy5cbiAgICAgICAgICAgICAqIEluIHdoaWNoIGNhc2UsIHRoaXMuc3RhdGUuYWN0aXZlVG9vbHRpcEluZGV4IG5ldmVyIGdldHMgc2V0XG4gICAgICAgICAgICAgKiBiZWNhdXNlIHRoZSBtb3VzZSBldmVudHMgdGhhdCB0cmlnZ2VyIHRoYXQgdmFsdWUgZ2V0dGluZyBzZXQgbmV2ZXIgZ2V0IHRyaWdnZWQgd2l0aG91dCB0aGUgYXhpcyBjb21wb25lbnRzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFuIGV4YW1wbGUgdXNhZ2UgY2FzZSBpcyBhIEZ1bm5lbENoYXJ0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBfcmVmMTEgPSAoX3RoaXMkZ2V0SXRlbUJ5WFkgPSBfdGhpcy5nZXRJdGVtQnlYWShfdGhpcy5zdGF0ZS5hY3RpdmVDb29yZGluYXRlKSkgIT09IG51bGwgJiYgX3RoaXMkZ2V0SXRlbUJ5WFkgIT09IHZvaWQgMCA/IF90aGlzJGdldEl0ZW1CeVhZIDoge1xuICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IGdyYXBoaWNhbEl0ZW1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgX3JlZjExJGdyYXBoaWNhbEl0ZW0gPSBfcmVmMTEuZ3JhcGhpY2FsSXRlbSxcbiAgICAgICAgICAgICAgX3JlZjExJGdyYXBoaWNhbEl0ZW0kID0gX3JlZjExJGdyYXBoaWNhbEl0ZW0uaXRlbSxcbiAgICAgICAgICAgICAgeHlJdGVtID0gX3JlZjExJGdyYXBoaWNhbEl0ZW0kID09PSB2b2lkIDAgPyBlbGVtZW50IDogX3JlZjExJGdyYXBoaWNhbEl0ZW0kLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4ID0gX3JlZjExJGdyYXBoaWNhbEl0ZW0uY2hpbGRJbmRleDtcbiAgICAgICAgICAgIHZhciBlbGVtZW50UHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbS5wcm9wcyksIGl0ZW1FdmVudHMpLCB7fSwge1xuICAgICAgICAgICAgICBhY3RpdmVJbmRleDogY2hpbGRJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gWy8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQoeHlJdGVtLCBlbGVtZW50UHJvcHMpLCBudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gW2dyYXBoaWNhbEl0ZW0sIG51bGwsIG51bGxdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZ3JhcGhpY2FsSXRlbSwgbnVsbF07XG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJDdXN0b21pemVkXCIsIGZ1bmN0aW9uIChlbGVtZW50LCBkaXNwbGF5TmFtZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQoZWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBrZXk6IFwicmVjaGFydHMtY3VzdG9taXplZC1cIi5jb25jYXQoaW5kZXgpXG4gICAgICAgIH0sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpKTtcbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlck1hcFwiLCB7XG4gICAgICAgIENhcnRlc2lhbkdyaWQ6IHtcbiAgICAgICAgICBoYW5kbGVyOiByZW5kZXJBc0lzLFxuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgUmVmZXJlbmNlQXJlYToge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclJlZmVyZW5jZUVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgUmVmZXJlbmNlTGluZToge1xuICAgICAgICAgIGhhbmRsZXI6IHJlbmRlckFzSXNcbiAgICAgICAgfSxcbiAgICAgICAgUmVmZXJlbmNlRG90OiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyUmVmZXJlbmNlRWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICBYQXhpczoge1xuICAgICAgICAgIGhhbmRsZXI6IHJlbmRlckFzSXNcbiAgICAgICAgfSxcbiAgICAgICAgWUF4aXM6IHtcbiAgICAgICAgICBoYW5kbGVyOiByZW5kZXJBc0lzXG4gICAgICAgIH0sXG4gICAgICAgIEJydXNoOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyQnJ1c2gsXG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBCYXI6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcbiAgICAgICAgfSxcbiAgICAgICAgTGluZToge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBBcmVhOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIFJhZGFyOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIFJhZGlhbEJhcjoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBTY2F0dGVyOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyR3JhcGhpY0NoaWxkXG4gICAgICAgIH0sXG4gICAgICAgIFBpZToge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckdyYXBoaWNDaGlsZFxuICAgICAgICB9LFxuICAgICAgICBGdW5uZWw6IHtcbiAgICAgICAgICBoYW5kbGVyOiBfdGhpcy5yZW5kZXJHcmFwaGljQ2hpbGRcbiAgICAgICAgfSxcbiAgICAgICAgVG9vbHRpcDoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlckN1cnNvcixcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFBvbGFyR3JpZDoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclBvbGFyR3JpZCxcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFBvbGFyQW5nbGVBeGlzOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyUG9sYXJBeGlzXG4gICAgICAgIH0sXG4gICAgICAgIFBvbGFyUmFkaXVzQXhpczoge1xuICAgICAgICAgIGhhbmRsZXI6IF90aGlzLnJlbmRlclBvbGFyQXhpc1xuICAgICAgICB9LFxuICAgICAgICBDdXN0b21pemVkOiB7XG4gICAgICAgICAgaGFuZGxlcjogX3RoaXMucmVuZGVyQ3VzdG9taXplZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmNsaXBQYXRoSWQgPSBcIlwiLmNvbmNhdCgoX3Byb3BzJGlkID0gX3Byb3BzLmlkKSAhPT0gbnVsbCAmJiBfcHJvcHMkaWQgIT09IHZvaWQgMCA/IF9wcm9wcyRpZCA6IHVuaXF1ZUlkKCdyZWNoYXJ0cycpLCBcIi1jbGlwXCIpO1xuXG4gICAgICAvLyB0cmlnZ2VyIDYwZnBzXG4gICAgICBfdGhpcy50aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlID0gdGhyb3R0bGUoX3RoaXMudHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUsIChfcHJvcHMkdGhyb3R0bGVEZWxheSA9IF9wcm9wcy50aHJvdHRsZURlbGF5KSAhPT0gbnVsbCAmJiBfcHJvcHMkdGhyb3R0bGVEZWxheSAhPT0gdm9pZCAwID8gX3Byb3BzJHRocm90dGxlRGVsYXkgOiAxMDAwIC8gNjApO1xuICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzKENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBfQ29tcG9uZW50KTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBbe1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyRtYXJnaW4kbGUsIF90aGlzJHByb3BzJG1hcmdpbiR0bztcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICBsZWZ0OiAoX3RoaXMkcHJvcHMkbWFyZ2luJGxlID0gdGhpcy5wcm9wcy5tYXJnaW4ubGVmdCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbWFyZ2luJGxlICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRtYXJnaW4kbGUgOiAwLFxuICAgICAgICAgICAgdG9wOiAoX3RoaXMkcHJvcHMkbWFyZ2luJHRvID0gdGhpcy5wcm9wcy5tYXJnaW4udG9wKSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRtYXJnaW4kdG8gIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJG1hcmdpbiR0byA6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvb3JkaW5hdGVMaXN0OiB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrcyxcbiAgICAgICAgICBtb3VzZUhhbmRsZXJDYWxsYmFjazogdGhpcy50cmlnZ2VyZWRBZnRlck1vdXNlTW92ZSxcbiAgICAgICAgICBsYXlvdXQ6IHRoaXMucHJvcHMubGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BsYXlEZWZhdWx0VG9vbHRpcCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkaXNwbGF5RGVmYXVsdFRvb2x0aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwbGF5RGVmYXVsdFRvb2x0aXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM1LmNoaWxkcmVuLFxuICAgICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wczUuZGF0YSxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0LFxuICAgICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzNS5sYXlvdXQ7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbSA9IGZpbmRDaGlsZEJ5VHlwZShjaGlsZHJlbiwgVG9vbHRpcCk7XG4gICAgICAgIC8vIElmIHRoZSBjaGFydCBkb2Vzbid0IGluY2x1ZGUgYSA8VG9vbHRpcCAvPiBlbGVtZW50LCB0aGVyZSdzIG5vIHRvb2x0aXAgdG8gZGlzcGxheVxuICAgICAgICBpZiAoIXRvb2x0aXBFbGVtKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0SW5kZXggPSB0b29sdGlwRWxlbS5wcm9wcy5kZWZhdWx0SW5kZXg7XG5cbiAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHJ1bnRpbWUgZXJyb3JzXG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdEluZGV4ICE9PSAnbnVtYmVyJyB8fCBkZWZhdWx0SW5kZXggPCAwIHx8IGRlZmF1bHRJbmRleCA+IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZUxhYmVsID0gdGhpcy5zdGF0ZS50b29sdGlwVGlja3NbZGVmYXVsdEluZGV4XSAmJiB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrc1tkZWZhdWx0SW5kZXhdLnZhbHVlO1xuICAgICAgICB2YXIgYWN0aXZlUGF5bG9hZCA9IGdldFRvb2x0aXBDb250ZW50KHRoaXMuc3RhdGUsIGRhdGEsIGRlZmF1bHRJbmRleCwgYWN0aXZlTGFiZWwpO1xuICAgICAgICB2YXIgaW5kZXBlbmRlbnRBeGlzQ29vcmQgPSB0aGlzLnN0YXRlLnRvb2x0aXBUaWNrc1tkZWZhdWx0SW5kZXhdLmNvb3JkaW5hdGU7XG4gICAgICAgIHZhciBkZXBlbmRlbnRBeGlzQ29vcmQgPSAodGhpcy5zdGF0ZS5vZmZzZXQudG9wICsgaGVpZ2h0KSAvIDI7XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgdmFyIGFjdGl2ZUNvb3JkaW5hdGUgPSBpc0hvcml6b250YWwgPyB7XG4gICAgICAgICAgeDogaW5kZXBlbmRlbnRBeGlzQ29vcmQsXG4gICAgICAgICAgeTogZGVwZW5kZW50QXhpc0Nvb3JkXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgeTogaW5kZXBlbmRlbnRBeGlzQ29vcmQsXG4gICAgICAgICAgeDogZGVwZW5kZW50QXhpc0Nvb3JkXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVW5saWtlIG90aGVyIGNoYXJ0IHR5cGVzLCBzY2F0dGVyIHBsb3QncyB0b29sdGlwIHBvc2l0aW9ucyByZWx5IG9uIGJvdGggWCBhbmQgWSBjb29yZGluYXRlcy4gT25seSB0aGUgc2NhdHRlciBwbG90XG4gICAgICAgIC8vIGVsZW1lbnQga25vd3MgaXRzIG93biBZIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgc2NhdHRlciBwbG90LCB3ZSdsbCB3YW50IHRvIGdyYWIgdGhhdCBlbGVtZW50IGZvciBhbiBpbnRlcnJvZ2F0aW9uLlxuICAgICAgICB2YXIgc2NhdHRlclBsb3RFbGVtZW50ID0gdGhpcy5zdGF0ZS5mb3JtYXR0ZWRHcmFwaGljYWxJdGVtcy5maW5kKGZ1bmN0aW9uIChfcmVmMTIpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IF9yZWYxMi5pdGVtO1xuICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUubmFtZSA9PT0gJ1NjYXR0ZXInO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNjYXR0ZXJQbG90RWxlbWVudCkge1xuICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjdGl2ZUNvb3JkaW5hdGUpLCBzY2F0dGVyUGxvdEVsZW1lbnQucHJvcHMucG9pbnRzW2RlZmF1bHRJbmRleF0udG9vbHRpcFBvc2l0aW9uKTtcbiAgICAgICAgICBhY3RpdmVQYXlsb2FkID0gc2NhdHRlclBsb3RFbGVtZW50LnByb3BzLnBvaW50c1tkZWZhdWx0SW5kZXhdLnRvb2x0aXBQYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgYWN0aXZlVG9vbHRpcEluZGV4OiBkZWZhdWx0SW5kZXgsXG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGFjdGl2ZUxhYmVsOiBhY3RpdmVMYWJlbCxcbiAgICAgICAgICBhY3RpdmVQYXlsb2FkOiBhY3RpdmVQYXlsb2FkLFxuICAgICAgICAgIGFjdGl2ZUNvb3JkaW5hdGU6IGFjdGl2ZUNvb3JkaW5hdGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcih0b29sdGlwRWxlbSk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYW55b25lIHdobyBrZXlib2FyZC1vbmx5IHVzZXJzIHdobyB0YWIgdG8gdGhlIGNoYXJ0IHdpbGwgc3RhcnQgdGhlaXJcbiAgICAgICAgLy8gY3Vyc29ycyBhdCBkZWZhdWx0SW5kZXhcbiAgICAgICAgdGhpcy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5zZXRJbmRleChkZWZhdWx0SW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5TGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS50b29sdGlwVGlja3MgIT09IHByZXZTdGF0ZS50b29sdGlwVGlja3MpIHtcbiAgICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgICAgY29vcmRpbmF0ZUxpc3Q6IHRoaXMuc3RhdGUudG9vbHRpcFRpY2tzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMubGF5b3V0ICE9PSBwcmV2UHJvcHMubGF5b3V0KSB7XG4gICAgICAgICAgdGhpcy5hY2Nlc3NpYmlsaXR5TWFuYWdlci5zZXREZXRhaWxzKHtcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5wcm9wcy5sYXlvdXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5tYXJnaW4gIT09IHByZXZQcm9wcy5tYXJnaW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMkbWFyZ2luJGxlMiwgX3RoaXMkcHJvcHMkbWFyZ2luJHRvMjtcbiAgICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLnNldERldGFpbHMoe1xuICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgIGxlZnQ6IChfdGhpcyRwcm9wcyRtYXJnaW4kbGUyID0gdGhpcy5wcm9wcy5tYXJnaW4ubGVmdCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbWFyZ2luJGxlMiAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkbWFyZ2luJGxlMiA6IDAsXG4gICAgICAgICAgICAgIHRvcDogKF90aGlzJHByb3BzJG1hcmdpbiR0bzIgPSB0aGlzLnByb3BzLm1hcmdpbi50b3ApICE9PSBudWxsICYmIF90aGlzJHByb3BzJG1hcmdpbiR0bzIgIT09IHZvaWQgMCA/IF90aGlzJHByb3BzJG1hcmdpbiR0bzIgOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGhpbmcgaGFzIHRvIGJlIHJldHVybmVkIGZvciBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIFRvb2x0aXAgdXBkYXRlZC4gSWYgc28sIHJlLWNoZWNrIGRlZmF1bHQgdG9vbHRpcCBwb3NpdGlvblxuICAgICAgICBpZiAoIWlzQ2hpbGRyZW5FcXVhbChbZmluZENoaWxkQnlUeXBlKHByZXZQcm9wcy5jaGlsZHJlbiwgVG9vbHRpcCldLCBbZmluZENoaWxkQnlUeXBlKHRoaXMucHJvcHMuY2hpbGRyZW4sIFRvb2x0aXApXSkpIHtcbiAgICAgICAgICB0aGlzLmRpc3BsYXlEZWZhdWx0VG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy50aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRUb29sdGlwRXZlbnRUeXBlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbHRpcEV2ZW50VHlwZSgpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBJdGVtID0gZmluZENoaWxkQnlUeXBlKHRoaXMucHJvcHMuY2hpbGRyZW4sIFRvb2x0aXApO1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW0gJiYgdHlwZW9mIHRvb2x0aXBJdGVtLnByb3BzLnNoYXJlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IHRvb2x0aXBJdGVtLnByb3BzLnNoYXJlZCA/ICdheGlzJyA6ICdpdGVtJztcbiAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcy5pbmRleE9mKGV2ZW50VHlwZSkgPj0gMCA/IGV2ZW50VHlwZSA6IGRlZmF1bHRUb29sdGlwRXZlbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIGluZm9ybWF0aW9uIG9mIG1vdXNlIGluIGNoYXJ0LCByZXR1cm4gbnVsbCB3aGVuIHRoZSBtb3VzZSBpcyBub3QgaW4gdGhlIGNoYXJ0XG4gICAgICAgKiBAcGFyYW0gIHtNb3VzZVBvaW50ZXJ9IGV2ZW50ICAgIFRoZSBldmVudCBvYmplY3RcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgTW91c2UgZGF0YVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE1vdXNlSW5mb1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vdXNlSW5mbyhldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBjb250YWluZXJPZmZzZXQgPSBnZXRPZmZzZXQoYm91bmRpbmdSZWN0KTtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgY2hhcnRYOiBNYXRoLnJvdW5kKGV2ZW50LnBhZ2VYIC0gY29udGFpbmVyT2Zmc2V0LmxlZnQpLFxuICAgICAgICAgIGNoYXJ0WTogTWF0aC5yb3VuZChldmVudC5wYWdlWSAtIGNvbnRhaW5lck9mZnNldC50b3ApXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzY2FsZSA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgICAgICAgdmFyIHJhbmdlT2JqID0gdGhpcy5pblJhbmdlKGUuY2hhcnRYLCBlLmNoYXJ0WSwgc2NhbGUpO1xuICAgICAgICBpZiAoIXJhbmdlT2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzJHN0YXRlOSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgeEF4aXNNYXAgPSBfdGhpcyRzdGF0ZTkueEF4aXNNYXAsXG4gICAgICAgICAgeUF4aXNNYXAgPSBfdGhpcyRzdGF0ZTkueUF4aXNNYXA7XG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRUeXBlID0gdGhpcy5nZXRUb29sdGlwRXZlbnRUeXBlKCk7XG4gICAgICAgIGlmICh0b29sdGlwRXZlbnRUeXBlICE9PSAnYXhpcycgJiYgeEF4aXNNYXAgJiYgeUF4aXNNYXApIHtcbiAgICAgICAgICB2YXIgeFNjYWxlID0gZ2V0QW55RWxlbWVudE9mT2JqZWN0KHhBeGlzTWFwKS5zY2FsZTtcbiAgICAgICAgICB2YXIgeVNjYWxlID0gZ2V0QW55RWxlbWVudE9mT2JqZWN0KHlBeGlzTWFwKS5zY2FsZTtcbiAgICAgICAgICB2YXIgeFZhbHVlID0geFNjYWxlICYmIHhTY2FsZS5pbnZlcnQgPyB4U2NhbGUuaW52ZXJ0KGUuY2hhcnRYKSA6IG51bGw7XG4gICAgICAgICAgdmFyIHlWYWx1ZSA9IHlTY2FsZSAmJiB5U2NhbGUuaW52ZXJ0ID8geVNjYWxlLmludmVydChlLmNoYXJ0WSkgOiBudWxsO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGUpLCB7fSwge1xuICAgICAgICAgICAgeFZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICB5VmFsdWU6IHlWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b29sVGlwRGF0YSA9IGdldFRvb2x0aXBEYXRhKHRoaXMuc3RhdGUsIHRoaXMucHJvcHMuZGF0YSwgdGhpcy5wcm9wcy5sYXlvdXQsIHJhbmdlT2JqKTtcbiAgICAgICAgaWYgKHRvb2xUaXBEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZSksIHRvb2xUaXBEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5SYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluUmFuZ2UoeCwgeSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLnByb3BzLmxheW91dDtcbiAgICAgICAgdmFyIHNjYWxlZFggPSB4IC8gc2NhbGUsXG4gICAgICAgICAgc2NhbGVkWSA9IHkgLyBzY2FsZTtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnN0YXRlLm9mZnNldDtcbiAgICAgICAgICB2YXIgaXNJblJhbmdlID0gc2NhbGVkWCA+PSBvZmZzZXQubGVmdCAmJiBzY2FsZWRYIDw9IG9mZnNldC5sZWZ0ICsgb2Zmc2V0LndpZHRoICYmIHNjYWxlZFkgPj0gb2Zmc2V0LnRvcCAmJiBzY2FsZWRZIDw9IG9mZnNldC50b3AgKyBvZmZzZXQuaGVpZ2h0O1xuICAgICAgICAgIHJldHVybiBpc0luUmFuZ2UgPyB7XG4gICAgICAgICAgICB4OiBzY2FsZWRYLFxuICAgICAgICAgICAgeTogc2NhbGVkWVxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyRzdGF0ZTEwID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBhbmdsZUF4aXNNYXAgPSBfdGhpcyRzdGF0ZTEwLmFuZ2xlQXhpc01hcCxcbiAgICAgICAgICByYWRpdXNBeGlzTWFwID0gX3RoaXMkc3RhdGUxMC5yYWRpdXNBeGlzTWFwO1xuICAgICAgICBpZiAoYW5nbGVBeGlzTWFwICYmIHJhZGl1c0F4aXNNYXApIHtcbiAgICAgICAgICB2YXIgYW5nbGVBeGlzID0gZ2V0QW55RWxlbWVudE9mT2JqZWN0KGFuZ2xlQXhpc01hcCk7XG4gICAgICAgICAgcmV0dXJuIGluUmFuZ2VPZlNlY3Rvcih7XG4gICAgICAgICAgICB4OiBzY2FsZWRYLFxuICAgICAgICAgICAgeTogc2NhbGVkWVxuICAgICAgICAgIH0sIGFuZ2xlQXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhcnNlRXZlbnRzT2ZXcmFwcGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VFdmVudHNPZldyYXBwZXIoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRUeXBlID0gdGhpcy5nZXRUb29sdGlwRXZlbnRUeXBlKCk7XG4gICAgICAgIHZhciB0b29sdGlwSXRlbSA9IGZpbmRDaGlsZEJ5VHlwZShjaGlsZHJlbiwgVG9vbHRpcCk7XG4gICAgICAgIHZhciB0b29sdGlwRXZlbnRzID0ge307XG4gICAgICAgIGlmICh0b29sdGlwSXRlbSAmJiB0b29sdGlwRXZlbnRUeXBlID09PSAnYXhpcycpIHtcbiAgICAgICAgICBpZiAodG9vbHRpcEl0ZW0ucHJvcHMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdG9vbHRpcEV2ZW50cyA9IHtcbiAgICAgICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGlja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9vbHRpcEV2ZW50cyA9IHtcbiAgICAgICAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLmhhbmRsZU1vdXNlRW50ZXIsXG4gICAgICAgICAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcbiAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhhbmRsZU1vdXNlTGVhdmUsXG4gICAgICAgICAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLmhhbmRsZVRvdWNoTW92ZSxcbiAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXG4gICAgICAgICAgICAgIG9uVG91Y2hFbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhZGFwdEV2ZW50SGFuZGxlcnMgZXhwZWN0cyBET00gRXZlbnQgYnV0IGdlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCB3b3JrcyB3aXRoIFJlYWN0IFVJRXZlbnRzXG4gICAgICAgIHZhciBvdXRlckV2ZW50cyA9IGFkYXB0RXZlbnRIYW5kbGVycyh0aGlzLnByb3BzLCB0aGlzLmhhbmRsZU91dGVyRXZlbnQpO1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvdXRlckV2ZW50cyksIHRvb2x0aXBFdmVudHMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVyKCkge1xuICAgICAgICBldmVudENlbnRlci5vbihTWU5DX0VWRU5ULCB0aGlzLmhhbmRsZVJlY2VpdmVTeW5jRXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICBldmVudENlbnRlci5yZW1vdmVMaXN0ZW5lcihTWU5DX0VWRU5ULCB0aGlzLmhhbmRsZVJlY2VpdmVTeW5jRXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaWx0ZXJGb3JtYXRJdGVtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyRm9ybWF0SXRlbShpdGVtLCBkaXNwbGF5TmFtZSwgY2hpbGRJbmRleCkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgPSB0aGlzLnN0YXRlLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtc1tpXTtcbiAgICAgICAgICBpZiAoZW50cnkuaXRlbSA9PT0gaXRlbSB8fCBlbnRyeS5wcm9wcy5rZXkgPT09IGl0ZW0ua2V5IHx8IGRpc3BsYXlOYW1lID09PSBnZXREaXNwbGF5TmFtZShlbnRyeS5pdGVtLnR5cGUpICYmIGNoaWxkSW5kZXggPT09IGVudHJ5LmNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlckNsaXBQYXRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2xpcFBhdGgoKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gdGhpcy5jbGlwUGF0aElkO1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUkb2Zmc2V0ID0gdGhpcy5zdGF0ZS5vZmZzZXQsXG4gICAgICAgICAgbGVmdCA9IF90aGlzJHN0YXRlJG9mZnNldC5sZWZ0LFxuICAgICAgICAgIHRvcCA9IF90aGlzJHN0YXRlJG9mZnNldC50b3AsXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkc3RhdGUkb2Zmc2V0LmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHN0YXRlJG9mZnNldC53aWR0aDtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIsIHtcbiAgICAgICAgICBpZDogY2xpcFBhdGhJZFxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgeTogdG9wLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYU2NhbGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WFNjYWxlcygpIHtcbiAgICAgICAgdmFyIHhBeGlzTWFwID0gdGhpcy5zdGF0ZS54QXhpc01hcDtcbiAgICAgICAgcmV0dXJuIHhBeGlzTWFwID8gT2JqZWN0LmVudHJpZXMoeEF4aXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzLCBfcmVmMTMpIHtcbiAgICAgICAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgICAgICAgIGF4aXNJZCA9IF9yZWYxNFswXSxcbiAgICAgICAgICAgIGF4aXNQcm9wcyA9IF9yZWYxNFsxXTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIGF4aXNQcm9wcy5zY2FsZSkpO1xuICAgICAgICB9LCB7fSkgOiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRZU2NhbGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WVNjYWxlcygpIHtcbiAgICAgICAgdmFyIHlBeGlzTWFwID0gdGhpcy5zdGF0ZS55QXhpc01hcDtcbiAgICAgICAgcmV0dXJuIHlBeGlzTWFwID8gT2JqZWN0LmVudHJpZXMoeUF4aXNNYXApLnJlZHVjZShmdW5jdGlvbiAocmVzLCBfcmVmMTUpIHtcbiAgICAgICAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAyKSxcbiAgICAgICAgICAgIGF4aXNJZCA9IF9yZWYxNlswXSxcbiAgICAgICAgICAgIGF4aXNQcm9wcyA9IF9yZWYxNlsxXTtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBheGlzSWQsIGF4aXNQcm9wcy5zY2FsZSkpO1xuICAgICAgICB9LCB7fSkgOiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRYU2NhbGVCeUF4aXNJZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFhTY2FsZUJ5QXhpc0lkKGF4aXNJZCkge1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUkeEF4aXNNYXA7XG4gICAgICAgIHJldHVybiAoX3RoaXMkc3RhdGUkeEF4aXNNYXAgPSB0aGlzLnN0YXRlLnhBeGlzTWFwKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSR4QXhpc01hcCA9PT0gdm9pZCAwIHx8IChfdGhpcyRzdGF0ZSR4QXhpc01hcCA9IF90aGlzJHN0YXRlJHhBeGlzTWFwW2F4aXNJZF0pID09PSBudWxsIHx8IF90aGlzJHN0YXRlJHhBeGlzTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSR4QXhpc01hcC5zY2FsZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0WVNjYWxlQnlBeGlzSWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRZU2NhbGVCeUF4aXNJZChheGlzSWQpIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlJHlBeGlzTWFwO1xuICAgICAgICByZXR1cm4gKF90aGlzJHN0YXRlJHlBeGlzTWFwID0gdGhpcy5zdGF0ZS55QXhpc01hcCkgPT09IG51bGwgfHwgX3RoaXMkc3RhdGUkeUF4aXNNYXAgPT09IHZvaWQgMCB8fCAoX3RoaXMkc3RhdGUkeUF4aXNNYXAgPSBfdGhpcyRzdGF0ZSR5QXhpc01hcFtheGlzSWRdKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSR5QXhpc01hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkc3RhdGUkeUF4aXNNYXAuc2NhbGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEl0ZW1CeVhZXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbUJ5WFkoY2hhcnRYWSkge1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUxMSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMgPSBfdGhpcyRzdGF0ZTExLmZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zLFxuICAgICAgICAgIGFjdGl2ZUl0ZW0gPSBfdGhpcyRzdGF0ZTExLmFjdGl2ZUl0ZW07XG4gICAgICAgIGlmIChmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcyAmJiBmb3JtYXR0ZWRHcmFwaGljYWxJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncmFwaGljYWxJdGVtID0gZm9ybWF0dGVkR3JhcGhpY2FsSXRlbXNbaV07XG4gICAgICAgICAgICAvLyBncmFwaGljYWxJdGVtIGlzIG5vdCBhIFJlYWN0IEVsZW1lbnQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlIGRlZmF1bHRQcm9wc1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZ3JhcGhpY2FsSXRlbS5wcm9wcyxcbiAgICAgICAgICAgICAgaXRlbSA9IGdyYXBoaWNhbEl0ZW0uaXRlbTtcbiAgICAgICAgICAgIHZhciBpdGVtUHJvcHMgPSBpdGVtLnR5cGUuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGl0ZW0udHlwZS5kZWZhdWx0UHJvcHMpLCBpdGVtLnByb3BzKSA6IGl0ZW0ucHJvcHM7XG4gICAgICAgICAgICB2YXIgaXRlbURpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoaXRlbS50eXBlKTtcbiAgICAgICAgICAgIGlmIChpdGVtRGlzcGxheU5hbWUgPT09ICdCYXInKSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVCYXJJdGVtID0gKHByb3BzLmRhdGEgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzSW5SZWN0YW5nbGUoY2hhcnRYWSwgZW50cnkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJhckl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZ3JhcGhpY2FsSXRlbTogZ3JhcGhpY2FsSXRlbSxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGFjdGl2ZUJhckl0ZW1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1EaXNwbGF5TmFtZSA9PT0gJ1JhZGlhbEJhcicpIHtcbiAgICAgICAgICAgICAgdmFyIF9hY3RpdmVCYXJJdGVtID0gKHByb3BzLmRhdGEgfHwgW10pLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluUmFuZ2VPZlNlY3RvcihjaGFydFhZLCBlbnRyeSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoX2FjdGl2ZUJhckl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZ3JhcGhpY2FsSXRlbTogZ3JhcGhpY2FsSXRlbSxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IF9hY3RpdmVCYXJJdGVtXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bm5lbChncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSB8fCBpc1BpZShncmFwaGljYWxJdGVtLCBhY3RpdmVJdGVtKSB8fCBpc1NjYXR0ZXIoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkpIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gZ2V0QWN0aXZlU2hhcGVJbmRleEZvclRvb2x0aXAoe1xuICAgICAgICAgICAgICAgIGdyYXBoaWNhbEl0ZW06IGdyYXBoaWNhbEl0ZW0sXG4gICAgICAgICAgICAgICAgYWN0aXZlVG9vbHRpcEl0ZW06IGFjdGl2ZUl0ZW0sXG4gICAgICAgICAgICAgICAgaXRlbURhdGE6IGl0ZW1Qcm9wcy5kYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgY2hpbGRJbmRleCA9IGl0ZW1Qcm9wcy5hY3RpdmVJbmRleCA9PT0gdW5kZWZpbmVkID8gYWN0aXZlSW5kZXggOiBpdGVtUHJvcHMuYWN0aXZlSW5kZXg7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY2FsSXRlbTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBncmFwaGljYWxJdGVtKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBpc1NjYXR0ZXIoZ3JhcGhpY2FsSXRlbSwgYWN0aXZlSXRlbSkgPyBpdGVtUHJvcHMuZGF0YVthY3RpdmVJbmRleF0gOiBncmFwaGljYWxJdGVtLnByb3BzLmRhdGFbYWN0aXZlSW5kZXhdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgICBpZiAoIXZhbGlkYXRlV2lkdGhIZWlnaHQodGhpcykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzNi5jaGlsZHJlbixcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczYuY2xhc3NOYW1lLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM2LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNi5oZWlnaHQsXG4gICAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wczYuc3R5bGUsXG4gICAgICAgICAgY29tcGFjdCA9IF90aGlzJHByb3BzNi5jb21wYWN0LFxuICAgICAgICAgIHRpdGxlID0gX3RoaXMkcHJvcHM2LnRpdGxlLFxuICAgICAgICAgIGRlc2MgPSBfdGhpcyRwcm9wczYuZGVzYyxcbiAgICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHM2LCBfZXhjbHVkZWQyKTtcbiAgICAgICAgdmFyIGF0dHJzID0gZmlsdGVyUHJvcHMob3RoZXJzLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gVGhlIFwiY29tcGFjdFwiIG1vZGUgaXMgbWFpbmx5IHVzZWQgYXMgdGhlIHBhbm9yYW1hIHdpdGhpbiBCcnVzaFxuICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGFydExheW91dENvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQsXG4gICAgICAgICAgICBjbGlwUGF0aElkOiB0aGlzLmNsaXBQYXRoSWRcbiAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdXJmYWNlLCBfZXh0ZW5kcyh7fSwgYXR0cnMsIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgZGVzYzogZGVzY1xuICAgICAgICAgIH0pLCB0aGlzLnJlbmRlckNsaXBQYXRoKCksIHJlbmRlckJ5T3JkZXIoY2hpbGRyZW4sIHRoaXMucmVuZGVyTWFwKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlMYXllcikge1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyR0YWJJbmRleCwgX3RoaXMkcHJvcHMkcm9sZTtcbiAgICAgICAgICAvLyBTZXQgdGFiSW5kZXggdG8gMCBieSBkZWZhdWx0IChjYW4gYmUgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgYXR0cnMudGFiSW5kZXggPSAoX3RoaXMkcHJvcHMkdGFiSW5kZXggPSB0aGlzLnByb3BzLnRhYkluZGV4KSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyR0YWJJbmRleCAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkdGFiSW5kZXggOiAwO1xuICAgICAgICAgIC8vIFNldCByb2xlIHRvIGltZyBieSBkZWZhdWx0IChjYW4gYmUgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgYXR0cnMucm9sZSA9IChfdGhpcyRwcm9wcyRyb2xlID0gdGhpcy5wcm9wcy5yb2xlKSAhPT0gbnVsbCAmJiBfdGhpcyRwcm9wcyRyb2xlICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRyb2xlIDogJ2FwcGxpY2F0aW9uJztcbiAgICAgICAgICBhdHRycy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMzLmFjY2Vzc2liaWxpdHlNYW5hZ2VyLmtleWJvYXJkRXZlbnQoZSk7XG4gICAgICAgICAgICAvLyAnb25LZXlEb3duJyBpcyBub3QgY3VycmVudGx5IGEgc3VwcG9ydGVkIHByb3AgdGhhdCBjYW4gYmUgcGFzc2VkIHRocm91Z2hcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYWRkZWQsIHRoaXMgc2hvdWxkIGJlIGFkZGVkOiB0aGlzLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF0dHJzLm9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYWNjZXNzaWJpbGl0eU1hbmFnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIC8vICdvbkZvY3VzJyBpcyBub3QgY3VycmVudGx5IGEgc3VwcG9ydGVkIHByb3AgdGhhdCBjYW4gYmUgcGFzc2VkIHRocm91Z2hcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYWRkZWQsIHRoZSBmb2N1cyBldmVudCBzaG91bGQgYmUgZm9yd2FyZGVkIHRvIHRoZSBwcm9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5wYXJzZUV2ZW50c09mV3JhcHBlcigpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuY2xpcFBhdGhJZFxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KCdyZWNoYXJ0cy13cmFwcGVyJywgY2xhc3NOYW1lKSxcbiAgICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICB9LCBzdHlsZSlcbiAgICAgICAgfSwgZXZlbnRzLCB7XG4gICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICAgICAgX3RoaXMzLmNvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICBkZXNjOiBkZXNjLFxuICAgICAgICAgIHN0eWxlOiBGVUxMX1dJRFRIX0FORF9IRUlHSFRcbiAgICAgICAgfSksIHRoaXMucmVuZGVyQ2xpcFBhdGgoKSwgcmVuZGVyQnlPcmRlcihjaGlsZHJlbiwgdGhpcy5yZW5kZXJNYXApKSwgdGhpcy5yZW5kZXJMZWdlbmQoKSwgdGhpcy5yZW5kZXJUb29sdGlwKCkpKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oQ29tcG9uZW50KTtcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcImRpc3BsYXlOYW1lXCIsIGNoYXJ0TmFtZSk7XG4gIC8vIHRvZG8gam9pbiBzcGVjaWZpYyBjaGFydCBwcm9wVHlwZXNcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcImRlZmF1bHRQcm9wc1wiLCBfb2JqZWN0U3ByZWFkKHtcbiAgICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcbiAgICBzdGFja09mZnNldDogJ25vbmUnLFxuICAgIGJhckNhdGVnb3J5R2FwOiAnMTAlJyxcbiAgICBiYXJHYXA6IDQsXG4gICAgbWFyZ2luOiB7XG4gICAgICB0b3A6IDUsXG4gICAgICByaWdodDogNSxcbiAgICAgIGJvdHRvbTogNSxcbiAgICAgIGxlZnQ6IDVcbiAgICB9LFxuICAgIHJldmVyc2VTdGFja09yZGVyOiBmYWxzZSxcbiAgICBzeW5jTWV0aG9kOiAnaW5kZXgnXG4gIH0sIGRlZmF1bHRQcm9wcykpO1xuICBfZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsIGZ1bmN0aW9uIChuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHZhciBkYXRhS2V5ID0gbmV4dFByb3BzLmRhdGFLZXksXG4gICAgICBkYXRhID0gbmV4dFByb3BzLmRhdGEsXG4gICAgICBjaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgIHdpZHRoID0gbmV4dFByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gbmV4dFByb3BzLmhlaWdodCxcbiAgICAgIGxheW91dCA9IG5leHRQcm9wcy5sYXlvdXQsXG4gICAgICBzdGFja09mZnNldCA9IG5leHRQcm9wcy5zdGFja09mZnNldCxcbiAgICAgIG1hcmdpbiA9IG5leHRQcm9wcy5tYXJnaW47XG4gICAgdmFyIGRhdGFTdGFydEluZGV4ID0gcHJldlN0YXRlLmRhdGFTdGFydEluZGV4LFxuICAgICAgZGF0YUVuZEluZGV4ID0gcHJldlN0YXRlLmRhdGFFbmRJbmRleDtcbiAgICBpZiAocHJldlN0YXRlLnVwZGF0ZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkZWZhdWx0U3RhdGUgPSBjcmVhdGVEZWZhdWx0U3RhdGUobmV4dFByb3BzKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFN0YXRlKSwge30sIHtcbiAgICAgICAgdXBkYXRlSWQ6IDBcbiAgICAgIH0sIHVwZGF0ZVN0YXRlT2ZBeGlzTWFwc09mZnNldEFuZFN0YWNrR3JvdXBzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHByb3BzOiBuZXh0UHJvcHNcbiAgICAgIH0sIGRlZmF1bHRTdGF0ZSksIHt9LCB7XG4gICAgICAgIHVwZGF0ZUlkOiAwXG4gICAgICB9KSwgcHJldlN0YXRlKSksIHt9LCB7XG4gICAgICAgIHByZXZEYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgICBwcmV2RGF0YTogZGF0YSxcbiAgICAgICAgcHJldldpZHRoOiB3aWR0aCxcbiAgICAgICAgcHJldkhlaWdodDogaGVpZ2h0LFxuICAgICAgICBwcmV2TGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIHByZXZTdGFja09mZnNldDogc3RhY2tPZmZzZXQsXG4gICAgICAgIHByZXZNYXJnaW46IG1hcmdpbixcbiAgICAgICAgcHJldkNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkYXRhS2V5ICE9PSBwcmV2U3RhdGUucHJldkRhdGFLZXkgfHwgZGF0YSAhPT0gcHJldlN0YXRlLnByZXZEYXRhIHx8IHdpZHRoICE9PSBwcmV2U3RhdGUucHJldldpZHRoIHx8IGhlaWdodCAhPT0gcHJldlN0YXRlLnByZXZIZWlnaHQgfHwgbGF5b3V0ICE9PSBwcmV2U3RhdGUucHJldkxheW91dCB8fCBzdGFja09mZnNldCAhPT0gcHJldlN0YXRlLnByZXZTdGFja09mZnNldCB8fCAhc2hhbGxvd0VxdWFsKG1hcmdpbiwgcHJldlN0YXRlLnByZXZNYXJnaW4pKSB7XG4gICAgICB2YXIgX2RlZmF1bHRTdGF0ZSA9IGNyZWF0ZURlZmF1bHRTdGF0ZShuZXh0UHJvcHMpO1xuXG4gICAgICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcmVjaGFydHMvcmVjaGFydHMvaXNzdWVzLzIxNDNcbiAgICAgIHZhciBrZWVwRnJvbVByZXZTdGF0ZSA9IHtcbiAgICAgICAgLy8gKGNoYXJ0WCwgY2hhcnRZKSBhcmUgKDAsMCkgaW4gZGVmYXVsdCBzdGF0ZSwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgbGFzdCBtb3VzZSBwb3NpdGlvbiB0byBhdm9pZFxuICAgICAgICAvLyBhbnkgZmxpY2tlcmluZ1xuICAgICAgICBjaGFydFg6IHByZXZTdGF0ZS5jaGFydFgsXG4gICAgICAgIGNoYXJ0WTogcHJldlN0YXRlLmNoYXJ0WSxcbiAgICAgICAgLy8gVGhlIHRvb2x0aXAgc2hvdWxkIHN0YXkgYWN0aXZlIHdoZW4gaXQgd2FzIGFjdGl2ZSBpbiB0aGUgcHJldmlvdXMgcmVuZGVyLiBJZiB0aGlzIGlzIG5vdFxuICAgICAgICAvLyB0aGUgY2FzZSwgdGhlIHRvb2x0aXAgZGlzYXBwZWFycyBhbmQgaW1tZWRpYXRlbHkgcmUtYXBwZWFycywgY2F1c2luZyBhIGZsaWNrZXJpbmcgZWZmZWN0XG4gICAgICAgIGlzVG9vbHRpcEFjdGl2ZTogcHJldlN0YXRlLmlzVG9vbHRpcEFjdGl2ZVxuICAgICAgfTtcbiAgICAgIHZhciB1cGRhdGVzVG9TdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZ2V0VG9vbHRpcERhdGEocHJldlN0YXRlLCBkYXRhLCBsYXlvdXQpKSwge30sIHtcbiAgICAgICAgdXBkYXRlSWQ6IHByZXZTdGF0ZS51cGRhdGVJZCArIDFcbiAgICAgIH0pO1xuICAgICAgdmFyIG5ld1N0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9kZWZhdWx0U3RhdGUpLCBrZWVwRnJvbVByZXZTdGF0ZSksIHVwZGF0ZXNUb1N0YXRlKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbmV3U3RhdGUpLCB1cGRhdGVTdGF0ZU9mQXhpc01hcHNPZmZzZXRBbmRTdGFja0dyb3Vwcyhfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgcHJvcHM6IG5leHRQcm9wc1xuICAgICAgfSwgbmV3U3RhdGUpLCBwcmV2U3RhdGUpKSwge30sIHtcbiAgICAgICAgcHJldkRhdGFLZXk6IGRhdGFLZXksXG4gICAgICAgIHByZXZEYXRhOiBkYXRhLFxuICAgICAgICBwcmV2V2lkdGg6IHdpZHRoLFxuICAgICAgICBwcmV2SGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHByZXZMYXlvdXQ6IGxheW91dCxcbiAgICAgICAgcHJldlN0YWNrT2Zmc2V0OiBzdGFja09mZnNldCxcbiAgICAgICAgcHJldk1hcmdpbjogbWFyZ2luLFxuICAgICAgICBwcmV2Q2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0NoaWxkcmVuRXF1YWwoY2hpbGRyZW4sIHByZXZTdGF0ZS5wcmV2Q2hpbGRyZW4pKSB7XG4gICAgICB2YXIgX2JydXNoJHByb3BzJHN0YXJ0SW5kLCBfYnJ1c2gkcHJvcHMsIF9icnVzaCRwcm9wcyRlbmRJbmRleCwgX2JydXNoJHByb3BzMjtcbiAgICAgIC8vIHNwZWNpZmljYWxseSBjaGVjayBmb3IgQnJ1c2ggLSBpZiBpdCBleGlzdHMgYW5kIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4ZXMgYXJlIGRpZmZlcmVudCwgcmUtcmVuZGVyIHdpdGggdGhlIG5ldyBvbmVzXG4gICAgICB2YXIgYnJ1c2ggPSBmaW5kQ2hpbGRCeVR5cGUoY2hpbGRyZW4sIEJydXNoKTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYnJ1c2ggPyAoX2JydXNoJHByb3BzJHN0YXJ0SW5kID0gKF9icnVzaCRwcm9wcyA9IGJydXNoLnByb3BzKSA9PT0gbnVsbCB8fCBfYnJ1c2gkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9icnVzaCRwcm9wcy5zdGFydEluZGV4KSAhPT0gbnVsbCAmJiBfYnJ1c2gkcHJvcHMkc3RhcnRJbmQgIT09IHZvaWQgMCA/IF9icnVzaCRwcm9wcyRzdGFydEluZCA6IGRhdGFTdGFydEluZGV4IDogZGF0YVN0YXJ0SW5kZXg7XG4gICAgICB2YXIgZW5kSW5kZXggPSBicnVzaCA/IChfYnJ1c2gkcHJvcHMkZW5kSW5kZXggPSAoX2JydXNoJHByb3BzMiA9IGJydXNoLnByb3BzKSA9PT0gbnVsbCB8fCBfYnJ1c2gkcHJvcHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYnJ1c2gkcHJvcHMyLmVuZEluZGV4KSAhPT0gbnVsbCAmJiBfYnJ1c2gkcHJvcHMkZW5kSW5kZXggIT09IHZvaWQgMCA/IF9icnVzaCRwcm9wcyRlbmRJbmRleCA6IGRhdGFFbmRJbmRleCA6IGRhdGFFbmRJbmRleDtcbiAgICAgIHZhciBoYXNEaWZmZXJlbnRTdGFydE9yRW5kSW5kZXggPSBzdGFydEluZGV4ICE9PSBkYXRhU3RhcnRJbmRleCB8fCBlbmRJbmRleCAhPT0gZGF0YUVuZEluZGV4O1xuXG4gICAgICAvLyB1cGRhdGUgY29uZmlndXJhdGlvbiBpbiBjaGlsZHJlblxuICAgICAgdmFyIGhhc0dsb2JhbERhdGEgPSAhaXNOaWwoZGF0YSk7XG4gICAgICB2YXIgbmV3VXBkYXRlSWQgPSBoYXNHbG9iYWxEYXRhICYmICFoYXNEaWZmZXJlbnRTdGFydE9yRW5kSW5kZXggPyBwcmV2U3RhdGUudXBkYXRlSWQgOiBwcmV2U3RhdGUudXBkYXRlSWQgKyAxO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHVwZGF0ZUlkOiBuZXdVcGRhdGVJZFxuICAgICAgfSwgdXBkYXRlU3RhdGVPZkF4aXNNYXBzT2Zmc2V0QW5kU3RhY2tHcm91cHMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgcHJvcHM6IG5leHRQcm9wc1xuICAgICAgfSwgcHJldlN0YXRlKSwge30sIHtcbiAgICAgICAgdXBkYXRlSWQ6IG5ld1VwZGF0ZUlkLFxuICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgZGF0YUVuZEluZGV4OiBlbmRJbmRleFxuICAgICAgfSksIHByZXZTdGF0ZSkpLCB7fSwge1xuICAgICAgICBwcmV2Q2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBkYXRhU3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgZGF0YUVuZEluZGV4OiBlbmRJbmRleFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgX2RlZmluZVByb3BlcnR5KENhdGVnb3JpY2FsQ2hhcnRXcmFwcGVyLCBcInJlbmRlckFjdGl2ZURvdFwiLCBmdW5jdGlvbiAob3B0aW9uLCBwcm9wcywga2V5KSB7XG4gICAgdmFyIGRvdDtcbiAgICBpZiAoIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChvcHRpb24pKSB7XG4gICAgICBkb3QgPSAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KG9wdGlvbiwgcHJvcHMpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvcHRpb24pKSB7XG4gICAgICBkb3QgPSBvcHRpb24ocHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3QgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEb3QsIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExheWVyLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtYWN0aXZlLWRvdFwiLFxuICAgICAga2V5OiBrZXlcbiAgICB9LCBkb3QpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIENhdGVnb3JpY2FsQ2hhcnQocHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIsIHByb3BzKTtcbiAgfTtcbn07Il0sIm5hbWVzIjpbIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJyIiwibCIsInQiLCJlIiwibiIsInUiLCJhIiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NhbGxTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwicCIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJpdGVyIiwibGVuIiwiYXJyMiIsIm93bktleXMiLCJrZXlzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIm9iaiIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsImlzTmlsIiwiaXNGdW5jdGlvbiIsInJhbmdlIiwiZ2V0Iiwic29ydEJ5IiwidGhyb3R0bGUiLCJjbHN4IiwiaW52YXJpYW50IiwiU3VyZmFjZSIsIkxheWVyIiwiVG9vbHRpcCIsIkxlZ2VuZCIsIkRvdCIsImlzSW5SZWN0YW5nbGUiLCJmaWx0ZXJQcm9wcyIsImZpbmRBbGxCeVR5cGUiLCJmaW5kQ2hpbGRCeVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImdldFJlYWN0RXZlbnRCeVR5cGUiLCJpc0NoaWxkcmVuRXF1YWwiLCJwYXJzZUNoaWxkSW5kZXgiLCJyZW5kZXJCeU9yZGVyIiwidmFsaWRhdGVXaWR0aEhlaWdodCIsIkJydXNoIiwiZ2V0T2Zmc2V0IiwiZmluZEVudHJ5SW5BcnJheSIsImdldEFueUVsZW1lbnRPZk9iamVjdCIsImhhc0R1cGxpY2F0ZSIsImlzTnVtYmVyIiwidW5pcXVlSWQiLCJhcHBlbmRPZmZzZXRPZkxlZ2VuZCIsImNhbGN1bGF0ZUFjdGl2ZVRpY2tJbmRleCIsImNvbWJpbmVFdmVudEhhbmRsZXJzIiwiZ2V0QmFuZFNpemVPZkF4aXMiLCJnZXRCYXJQb3NpdGlvbiIsImdldEJhclNpemVMaXN0IiwiZ2V0RG9tYWluT2ZEYXRhQnlLZXkiLCJnZXREb21haW5PZkl0ZW1zV2l0aFNhbWVBeGlzIiwiZ2V0RG9tYWluT2ZTdGFja0dyb3VwcyIsImdldExlZ2VuZFByb3BzIiwiZ2V0TWFpbkNvbG9yT2ZHcmFwaGljSXRlbSIsImdldFN0YWNrZWREYXRhT2ZJdGVtIiwiZ2V0U3RhY2tHcm91cHNCeUF4aXNJZCIsImdldFRpY2tzT2ZBeGlzIiwiZ2V0VG9vbHRpcEl0ZW0iLCJpc0NhdGVnb3JpY2FsQXhpcyIsInBhcnNlRG9tYWluT2ZDYXRlZ29yeUF4aXMiLCJwYXJzZUVycm9yQmFyc09mQXhpcyIsInBhcnNlU3BlY2lmaWVkRG9tYWluIiwiZGV0ZWN0UmVmZXJlbmNlRWxlbWVudHNEb21haW4iLCJpblJhbmdlT2ZTZWN0b3IiLCJwb2xhclRvQ2FydGVzaWFuIiwic2hhbGxvd0VxdWFsIiwiZXZlbnRDZW50ZXIiLCJTWU5DX0VWRU5UIiwiYWRhcHRFdmVudEhhbmRsZXJzIiwiQWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJpc0RvbWFpblNwZWNpZmllZEJ5VXNlciIsImdldEFjdGl2ZVNoYXBlSW5kZXhGb3JUb29sdGlwIiwiaXNGdW5uZWwiLCJpc1BpZSIsImlzU2NhdHRlciIsIkN1cnNvciIsIkNoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyIiwiT1JJRU5UX01BUCIsInhBeGlzIiwieUF4aXMiLCJGVUxMX1dJRFRIX0FORF9IRUlHSFQiLCJ3aWR0aCIsImhlaWdodCIsIm9yaWdpbkNvb3JkaW5hdGUiLCJ4IiwieSIsInJlbmRlckFzSXMiLCJlbGVtZW50IiwiY2FsY3VsYXRlVG9vbHRpcFBvcyIsInJhbmdlT2JqIiwibGF5b3V0IiwiYW5nbGUiLCJyYWRpdXMiLCJnZXRBY3RpdmVDb29yZGluYXRlIiwidG9vbHRpcFRpY2tzIiwiYWN0aXZlSW5kZXgiLCJlbnRyeSIsImZpbmQiLCJ0aWNrIiwiaW5kZXgiLCJjb29yZGluYXRlIiwiX2FuZ2xlIiwiX3JhZGl1cyIsImN4IiwiY3kiLCJnZXREaXNwbGF5ZWREYXRhIiwiZGF0YSIsIl9yZWYiLCJncmFwaGljYWxJdGVtcyIsImRhdGFTdGFydEluZGV4IiwiZGF0YUVuZEluZGV4IiwiaXRlbXNEYXRhIiwicmVkdWNlIiwicmVzdWx0IiwiY2hpbGQiLCJpdGVtRGF0YSIsImNvbmNhdCIsImdldERlZmF1bHREb21haW5CeUF4aXNUeXBlIiwiYXhpc1R5cGUiLCJ1bmRlZmluZWQiLCJnZXRUb29sdGlwQ29udGVudCIsInN0YXRlIiwiY2hhcnREYXRhIiwiYWN0aXZlTGFiZWwiLCJ0b29sdGlwQXhpcyIsImRpc3BsYXllZERhdGEiLCJfY2hpbGQkcHJvcHMkZGF0YSIsInBheWxvYWQiLCJkYXRhS2V5IiwiYWxsb3dEdXBsaWNhdGVkQ2F0ZWdvcnkiLCJlbnRyaWVzIiwiZ2V0VG9vbHRpcERhdGEiLCJyYW5nZURhdGEiLCJjaGFydFgiLCJjaGFydFkiLCJwb3MiLCJ0aWNrcyIsIm9yZGVyZWRUb29sdGlwVGlja3MiLCJheGlzIiwiYWN0aXZlUGF5bG9hZCIsImFjdGl2ZUNvb3JkaW5hdGUiLCJhY3RpdmVUb29sdGlwSW5kZXgiLCJnZXRBeGlzTWFwQnlBeGVzIiwiX3JlZjIiLCJheGVzIiwiYXhpc0lkS2V5Iiwic3RhY2tHcm91cHMiLCJjaGlsZHJlbiIsInN0YWNrT2Zmc2V0IiwiaXNDYXRlZ29yaWNhbCIsIl9jaGlsZFByb3BzJGRvbWFpbjIiLCJjaGlsZFByb3BzIiwidHlwZSIsImRlZmF1bHRQcm9wcyIsImFsbG93RGF0YU92ZXJmbG93Iiwic2NhbGUiLCJpbmNsdWRlSGlkZGVuIiwiYXhpc0lkIiwiaXRlbSIsIl9kZWZhdWx0UHJvcHMiLCJpdGVtQXhpc0lkIiwiZG9tYWluIiwiZHVwbGljYXRlRG9tYWluIiwiY2F0ZWdvcmljYWxEb21haW4iLCJkZWZhdWx0RG9tYWluIiwiX2NoaWxkUHJvcHMkZG9tYWluIiwiY2hpbGREb21haW4iLCJkdXBsaWNhdGUiLCJmaW5hbERvbWFpbiIsImVycm9yQmFyc0RvbWFpbiIsIl9kZWZhdWx0UHJvcHMyIiwiX2RlZmF1bHRQcm9wczMiLCJpdGVtSGlkZSIsImhpZGUiLCJoYXNTdGFjayIsImF4aXNEb21haW4iLCJpc0RvbWFpblZhbGlkIiwiZXZlcnkiLCJvcmlnaW5hbERvbWFpbiIsImdldEF4aXNNYXBCeUl0ZW1zIiwiX3JlZjMiLCJBeGlzIiwiX2RlZmF1bHRQcm9wczQiLCJfZGVmYXVsdFByb3BzNSIsIm9yaWVudGF0aW9uIiwiZ2V0QXhpc01hcCIsIl9yZWY0IiwiX3JlZjQkYXhpc1R5cGUiLCJBeGlzQ29tcCIsImF4aXNNYXAiLCJ0b29sdGlwVGlja3NHZW5lcmF0b3IiLCJ0b29sdGlwQXhpc0JhbmRTaXplIiwiY3JlYXRlRGVmYXVsdFN0YXRlIiwiZGVmYXVsdFNob3dUb29sdGlwIiwiYnJ1c2hJdGVtIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiaXNUb29sdGlwQWN0aXZlIiwiaGFzR3JhcGhpY2FsQmFySXRlbSIsInNvbWUiLCJnZXRBeGlzTmFtZUJ5TGF5b3V0IiwibnVtZXJpY0F4aXNOYW1lIiwiY2F0ZUF4aXNOYW1lIiwiY2FsY3VsYXRlT2Zmc2V0IiwiX3JlZjUiLCJwcmV2TGVnZW5kQkJveCIsIl9yZWY1JHhBeGlzTWFwIiwieEF4aXNNYXAiLCJfcmVmNSR5QXhpc01hcCIsInlBeGlzTWFwIiwibWFyZ2luIiwibGVnZW5kSXRlbSIsIm9mZnNldEgiLCJpZCIsIm1pcnJvciIsImxlZnQiLCJyaWdodCIsIm9mZnNldFYiLCJ0b3AiLCJib3R0b20iLCJvZmZzZXQiLCJicnVzaEJvdHRvbSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiTWF0aCIsIm1heCIsImdldENhcnRlc2lhbkF4aXNTaXplIiwiYXhpc09iaiIsImF4aXNOYW1lIiwiZ2VuZXJhdGVDYXRlZ29yaWNhbENoYXJ0IiwiX3JlZjYiLCJjaGFydE5hbWUiLCJHcmFwaGljYWxDaGlsZCIsIl9yZWY2JGRlZmF1bHRUb29sdGlwRSIsImRlZmF1bHRUb29sdGlwRXZlbnRUeXBlIiwiX3JlZjYkdmFsaWRhdGVUb29sdGlwIiwidmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlcyIsImF4aXNDb21wb25lbnRzIiwibGVnZW5kQ29udGVudCIsImZvcm1hdEF4aXNNYXAiLCJnZXRGb3JtYXRJdGVtcyIsImN1cnJlbnRTdGF0ZSIsInVwZGF0ZUlkIiwiYmFyU2l6ZSIsImJhckdhcCIsImJhckNhdGVnb3J5R2FwIiwiZ2xvYmFsTWF4QmFyU2l6ZSIsIm1heEJhclNpemUiLCJfZ2V0QXhpc05hbWVCeUxheW91dCIsImhhc0JhciIsImZvcm1hdHRlZEl0ZW1zIiwiaXRlbVByb3BzIiwiY2hpbGRNYXhCYXJTaXplIiwibnVtZXJpY0F4aXNJZCIsImNhdGVBeGlzSWQiLCJheGlzT2JqSW5pdGlhbFZhbHVlIiwiX2l0ZW0kdHlwZSRkaXNwbGF5TmFtIiwiX2l0ZW0kdHlwZSIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsImNhdGVBeGlzIiwiY2F0ZVRpY2tzIiwic3RhY2tlZERhdGEiLCJpdGVtSXNCYXIiLCJiYW5kU2l6ZSIsImJhclBvc2l0aW9uIiwic2l6ZUxpc3QiLCJ0b3RhbFNpemUiLCJfcmVmNyIsIl9nZXRCYW5kU2l6ZU9mQXhpcyIsImJhckJhbmRTaXplIiwibWFwIiwicG9zaXRpb24iLCJjb21wb3NlZEZuIiwiZ2V0Q29tcG9zZWREYXRhIiwiY2hpbGRJbmRleCIsInVwZGF0ZVN0YXRlT2ZBeGlzTWFwc09mZnNldEFuZFN0YWNrR3JvdXBzIiwiX3JlZjgiLCJwcmV2U3RhdGUiLCJyZXZlcnNlU3RhY2tPcmRlciIsIl9nZXRBeGlzTmFtZUJ5TGF5b3V0MiIsImxlZ2VuZEJCb3giLCJyZXBsYWNlIiwiY2F0ZUF4aXNNYXAiLCJ0aWNrc09iaiIsImZvcm1hdHRlZEdyYXBoaWNhbEl0ZW1zIiwiQ2F0ZWdvcmljYWxDaGFydFdyYXBwZXIiLCJfQ29tcG9uZW50IiwiX3Byb3BzIiwiX3Byb3BzJGlkIiwiX3Byb3BzJHRocm90dGxlRGVsYXkiLCJfdGhpcyIsImJveCIsIl90aGlzJHN0YXRlIiwic2V0U3RhdGUiLCJjSWQiLCJlbWl0dGVyIiwic3luY0lkIiwiZXZlbnRFbWl0dGVyU3ltYm9sIiwic3luY01ldGhvZCIsImFwcGx5U3luY0V2ZW50IiwiX3JlZjkiLCJ0cmlnZ2VyU3luY0V2ZW50IiwibW91c2UiLCJnZXRNb3VzZUluZm8iLCJfbmV4dFN0YXRlIiwib25Nb3VzZUVudGVyIiwibmV4dFN0YXRlIiwib25Nb3VzZU1vdmUiLCJlbCIsImFjdGl2ZUl0ZW0iLCJ0b29sdGlwUGF5bG9hZCIsInRvb2x0aXBQb3NpdGlvbiIsInBlcnNpc3QiLCJ0aHJvdHRsZVRyaWdnZXJlZEFmdGVyTW91c2VNb3ZlIiwiY2FuY2VsIiwib25Nb3VzZUxlYXZlIiwiZXZlbnROYW1lIiwiZXZlbnQiLCJfbW91c2UiLCJjaGFuZ2VkVG91Y2hlcyIsIl9uZXh0U3RhdGUyIiwib25DbGljayIsIm9uTW91c2VEb3duIiwiX25leHRTdGF0ZTMiLCJvbk1vdXNlVXAiLCJfbmV4dFN0YXRlNCIsImhhbmRsZU1vdXNlRG93biIsImhhbmRsZU1vdXNlVXAiLCJlbWl0IiwiX3RoaXMkcHJvcHMiLCJfdGhpcyRzdGF0ZTIiLCJ2aWV3Qm94IiwidmFsaWRhdGVDaGFydFgiLCJtaW4iLCJ2YWxpZGF0ZUNoYXJ0WSIsIl9lbGVtZW50JHByb3BzJGFjdGl2ZSIsIl90aGlzJHN0YXRlMyIsInRvb2x0aXBFdmVudFR5cGUiLCJnZXRUb29sdGlwRXZlbnRUeXBlIiwiaXNBY3RpdmUiLCJhY3RpdmUiLCJjcmVhdGVFbGVtZW50IiwiZWxlbWVudERlZmF1bHRQcm9wcyIsImVsZW1lbnRQcm9wcyIsImF4aXNPcHRpb24iLCJjbGFzc05hbWUiLCJfZWxlbWVudCRwcm9wcyIsInJhZGlhbExpbmVzIiwicG9sYXJBbmdsZXMiLCJwb2xhclJhZGl1cyIsIl90aGlzJHN0YXRlNCIsInJhZGl1c0F4aXNNYXAiLCJhbmdsZUF4aXNNYXAiLCJyYWRpdXNBeGlzIiwiYW5nbGVBeGlzIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsIl90aGlzJHByb3BzMiIsImxlZ2VuZFdpZHRoIiwib3RoZXJQcm9wcyIsImNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsIm9uQkJveFVwZGF0ZSIsImhhbmRsZUxlZ2VuZEJCb3hVcGRhdGUiLCJfdG9vbHRpcEl0ZW0kcHJvcHMkYWMiLCJfdGhpcyRwcm9wczMiLCJhY2Nlc3NpYmlsaXR5TGF5ZXIiLCJ0b29sdGlwSXRlbSIsIl90aGlzJHN0YXRlNSIsImxhYmVsIiwiX3RoaXMkcHJvcHM0IiwiX3RoaXMkc3RhdGU2Iiwib25DaGFuZ2UiLCJoYW5kbGVCcnVzaENoYW5nZSIsIl90aGlzMiIsImNsaXBQYXRoSWQiLCJfdGhpcyRzdGF0ZTciLCJfZWxlbWVudCRwcm9wczIiLCJfZWxlbWVudCRwcm9wczIkeEF4aXMiLCJ4QXhpc0lkIiwiX2VsZW1lbnQkcHJvcHMyJHlBeGlzIiwieUF4aXNJZCIsIl9yZWYxMCIsImFjdGl2ZVBvaW50IiwiYmFzZVBvaW50IiwiaXNSYW5nZSIsIml0ZW1JdGVtUHJvcHMiLCJhY3RpdmVEb3QiLCJkb3RQcm9wcyIsImZpbGwiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsInJlbmRlckFjdGl2ZURvdCIsImZpbHRlckZvcm1hdEl0ZW0iLCJfdGhpcyRzdGF0ZTgiLCJfaXRlbSRwcm9wcyIsInBvaW50cyIsImJhc2VMaW5lIiwiYWN0aXZlQmFyIiwiYWN0aXZlU2hhcGUiLCJoYXNBY3RpdmUiLCJpdGVtRXZlbnRzIiwidHJpZ2dlciIsImhhbmRsZUl0ZW1Nb3VzZUVudGVyIiwiaGFuZGxlSXRlbU1vdXNlTGVhdmUiLCJncmFwaGljYWxJdGVtIiwiZmluZFdpdGhQYXlsb2FkIiwic3BlY2lmaWVkS2V5IiwicmVuZGVyQWN0aXZlUG9pbnRzIiwiX3RoaXMkZ2V0SXRlbUJ5WFkiLCJfcmVmMTEiLCJnZXRJdGVtQnlYWSIsIl9yZWYxMSRncmFwaGljYWxJdGVtIiwiX3JlZjExJGdyYXBoaWNhbEl0ZW0kIiwieHlJdGVtIiwiQ2FydGVzaWFuR3JpZCIsImhhbmRsZXIiLCJvbmNlIiwiUmVmZXJlbmNlQXJlYSIsInJlbmRlclJlZmVyZW5jZUVsZW1lbnQiLCJSZWZlcmVuY2VMaW5lIiwiUmVmZXJlbmNlRG90IiwiWEF4aXMiLCJZQXhpcyIsInJlbmRlckJydXNoIiwiQmFyIiwicmVuZGVyR3JhcGhpY0NoaWxkIiwiTGluZSIsIkFyZWEiLCJSYWRhciIsIlJhZGlhbEJhciIsIlNjYXR0ZXIiLCJQaWUiLCJGdW5uZWwiLCJyZW5kZXJDdXJzb3IiLCJQb2xhckdyaWQiLCJyZW5kZXJQb2xhckdyaWQiLCJQb2xhckFuZ2xlQXhpcyIsInJlbmRlclBvbGFyQXhpcyIsIlBvbGFyUmFkaXVzQXhpcyIsIkN1c3RvbWl6ZWQiLCJyZW5kZXJDdXN0b21pemVkIiwidHJpZ2dlcmVkQWZ0ZXJNb3VzZU1vdmUiLCJ0aHJvdHRsZURlbGF5IiwiY29tcG9uZW50RGlkTW91bnQiLCJfdGhpcyRwcm9wcyRtYXJnaW4kbGUiLCJfdGhpcyRwcm9wcyRtYXJnaW4kdG8iLCJhZGRMaXN0ZW5lciIsImFjY2Vzc2liaWxpdHlNYW5hZ2VyIiwic2V0RGV0YWlscyIsImNvbnRhaW5lciIsImNvb3JkaW5hdGVMaXN0IiwibW91c2VIYW5kbGVyQ2FsbGJhY2siLCJkaXNwbGF5RGVmYXVsdFRvb2x0aXAiLCJfdGhpcyRwcm9wczUiLCJ0b29sdGlwRWxlbSIsImRlZmF1bHRJbmRleCIsImluZGVwZW5kZW50QXhpc0Nvb3JkIiwiZGVwZW5kZW50QXhpc0Nvb3JkIiwiaXNIb3Jpem9udGFsIiwic2NhdHRlclBsb3RFbGVtZW50IiwiX3JlZjEyIiwic2V0SW5kZXgiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInByZXZQcm9wcyIsIl90aGlzJHByb3BzJG1hcmdpbiRsZTIiLCJfdGhpcyRwcm9wcyRtYXJnaW4kdG8yIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVMaXN0ZW5lciIsInNoYXJlZCIsImV2ZW50VHlwZSIsImJvdW5kaW5nUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvbnRhaW5lck9mZnNldCIsInJvdW5kIiwicGFnZVgiLCJwYWdlWSIsImluUmFuZ2UiLCJfdGhpcyRzdGF0ZTkiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4VmFsdWUiLCJpbnZlcnQiLCJ5VmFsdWUiLCJ0b29sVGlwRGF0YSIsInNjYWxlZFgiLCJzY2FsZWRZIiwiaXNJblJhbmdlIiwiX3RoaXMkc3RhdGUxMCIsInBhcnNlRXZlbnRzT2ZXcmFwcGVyIiwidG9vbHRpcEV2ZW50cyIsImhhbmRsZUNsaWNrIiwiaGFuZGxlTW91c2VFbnRlciIsImhhbmRsZU1vdXNlTW92ZSIsImhhbmRsZU1vdXNlTGVhdmUiLCJvblRvdWNoTW92ZSIsImhhbmRsZVRvdWNoTW92ZSIsIm9uVG91Y2hTdGFydCIsImhhbmRsZVRvdWNoU3RhcnQiLCJvblRvdWNoRW5kIiwiaGFuZGxlVG91Y2hFbmQiLCJvdXRlckV2ZW50cyIsImhhbmRsZU91dGVyRXZlbnQiLCJvbiIsImhhbmRsZVJlY2VpdmVTeW5jRXZlbnQiLCJyZW5kZXJDbGlwUGF0aCIsIl90aGlzJHN0YXRlJG9mZnNldCIsImdldFhTY2FsZXMiLCJyZXMiLCJfcmVmMTMiLCJfcmVmMTQiLCJheGlzUHJvcHMiLCJnZXRZU2NhbGVzIiwiX3JlZjE1IiwiX3JlZjE2IiwiZ2V0WFNjYWxlQnlBeGlzSWQiLCJfdGhpcyRzdGF0ZSR4QXhpc01hcCIsImdldFlTY2FsZUJ5QXhpc0lkIiwiX3RoaXMkc3RhdGUkeUF4aXNNYXAiLCJjaGFydFhZIiwiX3RoaXMkc3RhdGUxMSIsIml0ZW1EaXNwbGF5TmFtZSIsImFjdGl2ZUJhckl0ZW0iLCJfYWN0aXZlQmFySXRlbSIsImFjdGl2ZVRvb2x0aXBJdGVtIiwicmVuZGVyIiwiX3RoaXMzIiwiX3RoaXMkcHJvcHM2Iiwic3R5bGUiLCJjb21wYWN0IiwidGl0bGUiLCJkZXNjIiwib3RoZXJzIiwiYXR0cnMiLCJyZW5kZXJNYXAiLCJfdGhpcyRwcm9wcyR0YWJJbmRleCIsIl90aGlzJHByb3BzJHJvbGUiLCJ0YWJJbmRleCIsInJvbGUiLCJvbktleURvd24iLCJrZXlib2FyZEV2ZW50Iiwib25Gb2N1cyIsImZvY3VzIiwiZXZlbnRzIiwiY3Vyc29yIiwicmVmIiwibm9kZSIsInJlbmRlckxlZ2VuZCIsInJlbmRlclRvb2x0aXAiLCJuZXh0UHJvcHMiLCJkZWZhdWx0U3RhdGUiLCJwcmV2RGF0YUtleSIsInByZXZEYXRhIiwicHJldldpZHRoIiwicHJldkhlaWdodCIsInByZXZMYXlvdXQiLCJwcmV2U3RhY2tPZmZzZXQiLCJwcmV2TWFyZ2luIiwicHJldkNoaWxkcmVuIiwiX2RlZmF1bHRTdGF0ZSIsImtlZXBGcm9tUHJldlN0YXRlIiwidXBkYXRlc1RvU3RhdGUiLCJuZXdTdGF0ZSIsIl9icnVzaCRwcm9wcyRzdGFydEluZCIsIl9icnVzaCRwcm9wcyIsIl9icnVzaCRwcm9wcyRlbmRJbmRleCIsIl9icnVzaCRwcm9wczIiLCJicnVzaCIsImhhc0RpZmZlcmVudFN0YXJ0T3JFbmRJbmRleCIsImhhc0dsb2JhbERhdGEiLCJuZXdVcGRhdGVJZCIsIm9wdGlvbiIsImRvdCIsIkNhdGVnb3JpY2FsQ2hhcnQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/recharts/es6/chart/generateCategoricalChart.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/recharts/es6/context/chartLayoutContext.js":
/*!*****************************************************************!*\
  !*** ./node_modules/recharts/es6/context/chartLayoutContext.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChartHeightContext: () => (/* binding */ ChartHeightContext),\n/* harmony export */   ChartLayoutContextProvider: () => (/* binding */ ChartLayoutContextProvider),\n/* harmony export */   ChartWidthContext: () => (/* binding */ ChartWidthContext),\n/* harmony export */   ClipPathIdContext: () => (/* binding */ ClipPathIdContext),\n/* harmony export */   OffsetContext: () => (/* binding */ OffsetContext),\n/* harmony export */   ViewBoxContext: () => (/* binding */ ViewBoxContext),\n/* harmony export */   XAxisContext: () => (/* binding */ XAxisContext),\n/* harmony export */   YAxisContext: () => (/* binding */ YAxisContext),\n/* harmony export */   useArbitraryXAxis: () => (/* binding */ useArbitraryXAxis),\n/* harmony export */   useArbitraryYAxis: () => (/* binding */ useArbitraryYAxis),\n/* harmony export */   useChartHeight: () => (/* binding */ useChartHeight),\n/* harmony export */   useChartWidth: () => (/* binding */ useChartWidth),\n/* harmony export */   useClipPathId: () => (/* binding */ useClipPathId),\n/* harmony export */   useOffset: () => (/* binding */ useOffset),\n/* harmony export */   useViewBox: () => (/* binding */ useViewBox),\n/* harmony export */   useXAxisOrThrow: () => (/* binding */ useXAxisOrThrow),\n/* harmony export */   useYAxisOrThrow: () => (/* binding */ useYAxisOrThrow),\n/* harmony export */   useYAxisWithFiniteDomainOrRandom: () => (/* binding */ useYAxisWithFiniteDomainOrRandom)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/find */ \"(app-pages-browser)/./node_modules/lodash/find.js\");\n/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_find__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_every__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/every */ \"(app-pages-browser)/./node_modules/lodash/every.js\");\n/* harmony import */ var lodash_every__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_every__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _util_calculateViewBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/calculateViewBox */ \"(app-pages-browser)/./node_modules/recharts/es6/util/calculateViewBox.js\");\n/* harmony import */ var _util_DataUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/DataUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/DataUtils.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$();\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\n\n\n\n\n\n\nvar XAxisContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nvar YAxisContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nvar ViewBoxContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nvar OffsetContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar ClipPathIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nvar ChartHeightContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(0);\nvar ChartWidthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(0);\n/**\n * Will add all the properties required to render all individual Recharts components into a React Context.\n *\n * If you want to read these properties, see the collection of hooks exported from this file.\n *\n * @param {object} props CategoricalChartState, plus children\n * @returns {ReactElement} React Context Provider\n */ var ChartLayoutContextProvider = function ChartLayoutContextProvider(props) {\n    var _props$state = props.state, xAxisMap = _props$state.xAxisMap, yAxisMap = _props$state.yAxisMap, offset = _props$state.offset, clipPathId = props.clipPathId, children = props.children, width = props.width, height = props.height;\n    /**\n   * Perhaps we should compute this property when reading? Let's see what is more often used\n   */ var viewBox = (0,_util_calculateViewBox__WEBPACK_IMPORTED_MODULE_4__.calculateViewBox)(offset);\n    /*\n   * This pretends to be a single context but actually is split into multiple smaller ones.\n   * Why?\n   * Because one React Context only allows to set one value.\n   * But we need to set multiple values.\n   * If we do that with one context, then we force re-render on components that might not even be interested\n   * in the part of the state that has changed.\n   *\n   * By splitting into smaller contexts, we allow each components to be optimized and only re-render when its dependencies change.\n   *\n   * To actually achieve the optimal re-render, it is necessary to use React.memo().\n   * See the test file for details.\n   */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(XAxisContext.Provider, {\n        value: xAxisMap\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(YAxisContext.Provider, {\n        value: yAxisMap\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(OffsetContext.Provider, {\n        value: offset\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ViewBoxContext.Provider, {\n        value: viewBox\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClipPathIdContext.Provider, {\n        value: clipPathId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChartHeightContext.Provider, {\n        value: height\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ChartWidthContext.Provider, {\n        value: width\n    }, children)))))));\n};\n_c = ChartLayoutContextProvider;\nvar useClipPathId = function useClipPathId() {\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClipPathIdContext);\n};\n_s(useClipPathId, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction getKeysForDebug(object) {\n    var keys = Object.keys(object);\n    if (keys.length === 0) {\n        return 'There are no available ids.';\n    }\n    return \"Available ids are: \".concat(keys, \".\");\n}\n/**\n * This either finds and returns Axis by the specified ID, or throws an exception if an axis with this ID does not exist.\n *\n * @param xAxisId identifier of the axis - it's either autogenerated ('0'), or passed via `id` prop as <XAxis id='foo' />\n * @returns axis configuration object\n * @throws Error if no axis with this ID exists\n */ var useXAxisOrThrow = function useXAxisOrThrow(xAxisId) {\n    _s1();\n    var xAxisMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(XAxisContext);\n    !(xAxisMap != null) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?') : 0 : void 0;\n    var xAxis = xAxisMap[xAxisId];\n    !(xAxis != null) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, \"Could not find xAxis by id \\\"\".concat(xAxisId, \"\\\" [\").concat(_typeof(xAxisId), \"]. \").concat(getKeysForDebug(xAxisMap))) : 0 : void 0;\n    return xAxis;\n};\n_s1(useXAxisOrThrow, \"uLqL/ErIGfpjQswv0rkuA1tqKvM=\");\n/**\n * This will find an arbitrary first XAxis. If there's exactly one it always returns that one\n * - but if there are multiple then it can return any of those.\n *\n * If you want specific XAxis out of multiple then prefer using useXAxisOrThrow\n *\n * @returns X axisOptions, or undefined - if there are no X axes\n */ var useArbitraryXAxis = function useArbitraryXAxis() {\n    _s2();\n    var xAxisMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(XAxisContext);\n    return (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_5__.getAnyElementOfObject)(xAxisMap);\n};\n_s2(useArbitraryXAxis, \"uLqL/ErIGfpjQswv0rkuA1tqKvM=\");\n/**\n * This will find an arbitrary first YAxis. If there's exactly one it always returns that one\n * - but if there are multiple then it can return any of those.\n *\n * If you want specific YAxis out of multiple then prefer using useXAxisOrThrow\n *\n * @returns Y axisOptions, or undefined - if there are no Y axes\n */ var useArbitraryYAxis = function useArbitraryYAxis() {\n    _s3();\n    var yAxisMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(YAxisContext);\n    return (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_5__.getAnyElementOfObject)(yAxisMap);\n};\n_s3(useArbitraryYAxis, \"fEz0zjR2HC0oI+VnSgrL41V0dqs=\");\n/**\n * This hooks will:\n * 1st attempt to find an YAxis that has all elements in its domain finite\n * If no such axis exists, it will return an arbitrary YAxis\n * if there are no Y axes then it returns undefined\n *\n * @returns Either Y axisOptions, or undefined if there are no Y axes\n */ var useYAxisWithFiniteDomainOrRandom = function useYAxisWithFiniteDomainOrRandom() {\n    _s4();\n    var yAxisMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(YAxisContext);\n    var yAxisWithFiniteDomain = lodash_find__WEBPACK_IMPORTED_MODULE_2___default()(yAxisMap, function(axis) {\n        return lodash_every__WEBPACK_IMPORTED_MODULE_3___default()(axis.domain, Number.isFinite);\n    });\n    return yAxisWithFiniteDomain || (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_5__.getAnyElementOfObject)(yAxisMap);\n};\n_s4(useYAxisWithFiniteDomainOrRandom, \"fEz0zjR2HC0oI+VnSgrL41V0dqs=\");\n/**\n * This either finds and returns Axis by the specified ID, or throws an exception if an axis with this ID does not exist.\n *\n * @param yAxisId identifier of the axis - it's either autogenerated ('0'), or passed via `id` prop as <YAxis id='foo' />\n * @returns axis configuration object\n * @throws Error if no axis with this ID exists\n */ var useYAxisOrThrow = function useYAxisOrThrow(yAxisId) {\n    _s5();\n    var yAxisMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(YAxisContext);\n    !(yAxisMap != null) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?') : 0 : void 0;\n    var yAxis = yAxisMap[yAxisId];\n    !(yAxis != null) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, \"Could not find yAxis by id \\\"\".concat(yAxisId, \"\\\" [\").concat(_typeof(yAxisId), \"]. \").concat(getKeysForDebug(yAxisMap))) : 0 : void 0;\n    return yAxis;\n};\n_s5(useYAxisOrThrow, \"fEz0zjR2HC0oI+VnSgrL41V0dqs=\");\nvar useViewBox = function useViewBox() {\n    _s6();\n    var viewBox = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ViewBoxContext);\n    return viewBox;\n};\n_s6(useViewBox, \"ziC+uI9Lej31e/ji5Zldp1x/AlI=\");\nvar useOffset = function useOffset() {\n    _s7();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OffsetContext);\n};\n_s7(useOffset, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar useChartWidth = function useChartWidth() {\n    _s8();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ChartWidthContext);\n};\n_s8(useChartWidth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar useChartHeight = function useChartHeight() {\n    _s9();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ChartHeightContext);\n};\n_s9(useChartHeight, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"ChartLayoutContextProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvY29udGV4dC9jaGFydExheW91dENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUNwUTtBQUNsQjtBQUNSO0FBQ0U7QUFDMkI7QUFDRjtBQUNuRCxJQUFJYSxlQUFlLFdBQVcsR0FBRVAsb0RBQWFBLENBQUNRLFdBQVc7QUFDekQsSUFBSUMsZUFBZSxXQUFXLEdBQUVULG9EQUFhQSxDQUFDUSxXQUFXO0FBQ3pELElBQUlFLGlCQUFpQixXQUFXLEdBQUVWLG9EQUFhQSxDQUFDUSxXQUFXO0FBQzNELElBQUlHLGdCQUFnQixXQUFXLEdBQUVYLG9EQUFhQSxDQUFDLENBQUMsR0FBRztBQUNuRCxJQUFJWSxvQkFBb0IsV0FBVyxHQUFFWixvREFBYUEsQ0FBQ1EsV0FBVztBQUM5RCxJQUFJSyxxQkFBcUIsV0FBVyxHQUFFYixvREFBYUEsQ0FBQyxHQUFHO0FBQ3ZELElBQUljLG9CQUFvQixXQUFXLEdBQUVkLG9EQUFhQSxDQUFDLEdBQUc7QUFFN0Q7Ozs7Ozs7Q0FPQyxHQUNNLElBQUllLDZCQUE2QixTQUFTQSwyQkFBMkJDLEtBQUs7SUFDL0UsSUFBSUMsZUFBZUQsTUFBTUUsS0FBSyxFQUM1QkMsV0FBV0YsYUFBYUUsUUFBUSxFQUNoQ0MsV0FBV0gsYUFBYUcsUUFBUSxFQUNoQ0MsU0FBU0os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QSxnQkFBZ0JDLE9BQU87O0lBQzNELElBQUk5QixXQUFXbkIsaURBQVVBLENBQUNRO0lBQzFCLENBQUVXLENBQUFBLFlBQVksSUFBRyxJQUFLbUIsS0FBcUMsR0FBR3JDLDBEQUFTQSxDQUFDLE9BQU8seUdBQXlHQSxDQUFnQixHQUFHLEtBQUs7SUFDaE4sSUFBSWlELFFBQVEvQixRQUFRLENBQUM4QixRQUFRO0lBQzdCLENBQUVDLENBQUFBLFNBQVMsSUFBRyxJQUFLWixLQUFxQyxHQUFHckMsMERBQVNBLENBQUMsT0FBTyxnQ0FBZ0NrQyxNQUFNLENBQUNjLFNBQVMsUUFBUWQsTUFBTSxDQUFDM0MsUUFBUXlELFVBQVUsT0FBT2QsTUFBTSxDQUFDTCxnQkFBZ0JYLGNBQWNsQixDQUFnQixHQUFHLEtBQUs7SUFDak8sT0FBT2lEO0FBQ1QsRUFBRTtJQU5TRjtBQU9KLElBQUlHLGFBQWEsU0FBU0E7O0lBQy9CLElBQUkxQixVQUFVekIsaURBQVVBLENBQUNTO0lBQ3pCLE9BQU9nQjtBQUNULEVBQUU7SUFIUzBCO0FBSUosSUFBSUMsWUFBWSxTQUFTQTs7SUFDOUIsT0FBT3BELGlEQUFVQSxDQUFDVTtBQUNwQixFQUFFO0lBRlMwQztBQUdKLElBQUlDLGdCQUFnQixTQUFTQTs7SUFDbEMsT0FBT3JELGlEQUFVQSxDQUFDYTtBQUNwQixFQUFFO0lBRlN3QztBQUdKLElBQUlDLGlCQUFpQixTQUFTQTs7SUFDbkMsT0FBT3RELGlEQUFVQSxDQUFDWTtBQUNwQixFQUFFO0lBRlMwQyIsInNvdXJjZXMiOlsiL1VzZXJzL2pvYW9zYW50b3MvV2Vic3Rvcm1Qcm9qZWN0cy93ZGMtd2ViLXBhbmVsL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvY29udGV4dC9jaGFydExheW91dENvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcbmltcG9ydCBmaW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCBldmVyeSBmcm9tICdsb2Rhc2gvZXZlcnknO1xuaW1wb3J0IHsgY2FsY3VsYXRlVmlld0JveCB9IGZyb20gJy4uL3V0aWwvY2FsY3VsYXRlVmlld0JveCc7XG5pbXBvcnQgeyBnZXRBbnlFbGVtZW50T2ZPYmplY3QgfSBmcm9tICcuLi91dGlsL0RhdGFVdGlscyc7XG5leHBvcnQgdmFyIFhBeGlzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5leHBvcnQgdmFyIFlBeGlzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5leHBvcnQgdmFyIFZpZXdCb3hDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmV4cG9ydCB2YXIgT2Zmc2V0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHt9KTtcbmV4cG9ydCB2YXIgQ2xpcFBhdGhJZENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuZXhwb3J0IHZhciBDaGFydEhlaWdodENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCgwKTtcbmV4cG9ydCB2YXIgQ2hhcnRXaWR0aENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCgwKTtcblxuLyoqXG4gKiBXaWxsIGFkZCBhbGwgdGhlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gcmVuZGVyIGFsbCBpbmRpdmlkdWFsIFJlY2hhcnRzIGNvbXBvbmVudHMgaW50byBhIFJlYWN0IENvbnRleHQuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gcmVhZCB0aGVzZSBwcm9wZXJ0aWVzLCBzZWUgdGhlIGNvbGxlY3Rpb24gb2YgaG9va3MgZXhwb3J0ZWQgZnJvbSB0aGlzIGZpbGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIENhdGVnb3JpY2FsQ2hhcnRTdGF0ZSwgcGx1cyBjaGlsZHJlblxuICogQHJldHVybnMge1JlYWN0RWxlbWVudH0gUmVhY3QgQ29udGV4dCBQcm92aWRlclxuICovXG5leHBvcnQgdmFyIENoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24gQ2hhcnRMYXlvdXRDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRzdGF0ZSA9IHByb3BzLnN0YXRlLFxuICAgIHhBeGlzTWFwID0gX3Byb3BzJHN0YXRlLnhBeGlzTWFwLFxuICAgIHlBeGlzTWFwID0gX3Byb3BzJHN0YXRlLnlBeGlzTWFwLFxuICAgIG9mZnNldCA9IF9wcm9wcyRzdGF0ZS5vZmZzZXQsXG4gICAgY2xpcFBhdGhJZCA9IHByb3BzLmNsaXBQYXRoSWQsXG4gICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgIGhlaWdodCA9IHByb3BzLmhlaWdodDtcblxuICAvKipcbiAgICogUGVyaGFwcyB3ZSBzaG91bGQgY29tcHV0ZSB0aGlzIHByb3BlcnR5IHdoZW4gcmVhZGluZz8gTGV0J3Mgc2VlIHdoYXQgaXMgbW9yZSBvZnRlbiB1c2VkXG4gICAqL1xuICB2YXIgdmlld0JveCA9IGNhbGN1bGF0ZVZpZXdCb3gob2Zmc2V0KTtcblxuICAvKlxuICAgKiBUaGlzIHByZXRlbmRzIHRvIGJlIGEgc2luZ2xlIGNvbnRleHQgYnV0IGFjdHVhbGx5IGlzIHNwbGl0IGludG8gbXVsdGlwbGUgc21hbGxlciBvbmVzLlxuICAgKiBXaHk/XG4gICAqIEJlY2F1c2Ugb25lIFJlYWN0IENvbnRleHQgb25seSBhbGxvd3MgdG8gc2V0IG9uZSB2YWx1ZS5cbiAgICogQnV0IHdlIG5lZWQgdG8gc2V0IG11bHRpcGxlIHZhbHVlcy5cbiAgICogSWYgd2UgZG8gdGhhdCB3aXRoIG9uZSBjb250ZXh0LCB0aGVuIHdlIGZvcmNlIHJlLXJlbmRlciBvbiBjb21wb25lbnRzIHRoYXQgbWlnaHQgbm90IGV2ZW4gYmUgaW50ZXJlc3RlZFxuICAgKiBpbiB0aGUgcGFydCBvZiB0aGUgc3RhdGUgdGhhdCBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQnkgc3BsaXR0aW5nIGludG8gc21hbGxlciBjb250ZXh0cywgd2UgYWxsb3cgZWFjaCBjb21wb25lbnRzIHRvIGJlIG9wdGltaXplZCBhbmQgb25seSByZS1yZW5kZXIgd2hlbiBpdHMgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICpcbiAgICogVG8gYWN0dWFsbHkgYWNoaWV2ZSB0aGUgb3B0aW1hbCByZS1yZW5kZXIsIGl0IGlzIG5lY2Vzc2FyeSB0byB1c2UgUmVhY3QubWVtbygpLlxuICAgKiBTZWUgdGhlIHRlc3QgZmlsZSBmb3IgZGV0YWlscy5cbiAgICovXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChYQXhpc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogeEF4aXNNYXBcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWUF4aXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHlBeGlzTWFwXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE9mZnNldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogb2Zmc2V0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpZXdCb3hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZpZXdCb3hcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xpcFBhdGhJZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY2xpcFBhdGhJZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGFydEhlaWdodENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaGVpZ2h0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoYXJ0V2lkdGhDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHdpZHRoXG4gIH0sIGNoaWxkcmVuKSkpKSkpKTtcbn07XG5leHBvcnQgdmFyIHVzZUNsaXBQYXRoSWQgPSBmdW5jdGlvbiB1c2VDbGlwUGF0aElkKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChDbGlwUGF0aElkQ29udGV4dCk7XG59O1xuZnVuY3Rpb24gZ2V0S2V5c0ZvckRlYnVnKG9iamVjdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnVGhlcmUgYXJlIG5vIGF2YWlsYWJsZSBpZHMuJztcbiAgfVxuICByZXR1cm4gXCJBdmFpbGFibGUgaWRzIGFyZTogXCIuY29uY2F0KGtleXMsIFwiLlwiKTtcbn1cblxuLyoqXG4gKiBUaGlzIGVpdGhlciBmaW5kcyBhbmQgcmV0dXJucyBBeGlzIGJ5IHRoZSBzcGVjaWZpZWQgSUQsIG9yIHRocm93cyBhbiBleGNlcHRpb24gaWYgYW4gYXhpcyB3aXRoIHRoaXMgSUQgZG9lcyBub3QgZXhpc3QuXG4gKlxuICogQHBhcmFtIHhBeGlzSWQgaWRlbnRpZmllciBvZiB0aGUgYXhpcyAtIGl0J3MgZWl0aGVyIGF1dG9nZW5lcmF0ZWQgKCcwJyksIG9yIHBhc3NlZCB2aWEgYGlkYCBwcm9wIGFzIDxYQXhpcyBpZD0nZm9vJyAvPlxuICogQHJldHVybnMgYXhpcyBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQHRocm93cyBFcnJvciBpZiBubyBheGlzIHdpdGggdGhpcyBJRCBleGlzdHNcbiAqL1xuZXhwb3J0IHZhciB1c2VYQXhpc09yVGhyb3cgPSBmdW5jdGlvbiB1c2VYQXhpc09yVGhyb3coeEF4aXNJZCkge1xuICB2YXIgeEF4aXNNYXAgPSB1c2VDb250ZXh0KFhBeGlzQ29udGV4dCk7XG4gICEoeEF4aXNNYXAgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBSZWNoYXJ0cyBjb250ZXh0OyBhcmUgeW91IHN1cmUgdGhpcyBpcyByZW5kZXJlZCBpbnNpZGUgYSBSZWNoYXJ0cyB3cmFwcGVyIGNvbXBvbmVudD8nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciB4QXhpcyA9IHhBeGlzTWFwW3hBeGlzSWRdO1xuICAhKHhBeGlzICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNvdWxkIG5vdCBmaW5kIHhBeGlzIGJ5IGlkIFxcXCJcIi5jb25jYXQoeEF4aXNJZCwgXCJcXFwiIFtcIikuY29uY2F0KF90eXBlb2YoeEF4aXNJZCksIFwiXS4gXCIpLmNvbmNhdChnZXRLZXlzRm9yRGVidWcoeEF4aXNNYXApKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4geEF4aXM7XG59O1xuXG4vKipcbiAqIFRoaXMgd2lsbCBmaW5kIGFuIGFyYml0cmFyeSBmaXJzdCBYQXhpcy4gSWYgdGhlcmUncyBleGFjdGx5IG9uZSBpdCBhbHdheXMgcmV0dXJucyB0aGF0IG9uZVxuICogLSBidXQgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHRoZW4gaXQgY2FuIHJldHVybiBhbnkgb2YgdGhvc2UuXG4gKlxuICogSWYgeW91IHdhbnQgc3BlY2lmaWMgWEF4aXMgb3V0IG9mIG11bHRpcGxlIHRoZW4gcHJlZmVyIHVzaW5nIHVzZVhBeGlzT3JUaHJvd1xuICpcbiAqIEByZXR1cm5zIFggYXhpc09wdGlvbnMsIG9yIHVuZGVmaW5lZCAtIGlmIHRoZXJlIGFyZSBubyBYIGF4ZXNcbiAqL1xuZXhwb3J0IHZhciB1c2VBcmJpdHJhcnlYQXhpcyA9IGZ1bmN0aW9uIHVzZUFyYml0cmFyeVhBeGlzKCkge1xuICB2YXIgeEF4aXNNYXAgPSB1c2VDb250ZXh0KFhBeGlzQ29udGV4dCk7XG4gIHJldHVybiBnZXRBbnlFbGVtZW50T2ZPYmplY3QoeEF4aXNNYXApO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgZmluZCBhbiBhcmJpdHJhcnkgZmlyc3QgWUF4aXMuIElmIHRoZXJlJ3MgZXhhY3RseSBvbmUgaXQgYWx3YXlzIHJldHVybnMgdGhhdCBvbmVcbiAqIC0gYnV0IGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB0aGVuIGl0IGNhbiByZXR1cm4gYW55IG9mIHRob3NlLlxuICpcbiAqIElmIHlvdSB3YW50IHNwZWNpZmljIFlBeGlzIG91dCBvZiBtdWx0aXBsZSB0aGVuIHByZWZlciB1c2luZyB1c2VYQXhpc09yVGhyb3dcbiAqXG4gKiBAcmV0dXJucyBZIGF4aXNPcHRpb25zLCBvciB1bmRlZmluZWQgLSBpZiB0aGVyZSBhcmUgbm8gWSBheGVzXG4gKi9cbmV4cG9ydCB2YXIgdXNlQXJiaXRyYXJ5WUF4aXMgPSBmdW5jdGlvbiB1c2VBcmJpdHJhcnlZQXhpcygpIHtcbiAgdmFyIHlBeGlzTWFwID0gdXNlQ29udGV4dChZQXhpc0NvbnRleHQpO1xuICByZXR1cm4gZ2V0QW55RWxlbWVudE9mT2JqZWN0KHlBeGlzTWFwKTtcbn07XG5cbi8qKlxuICogVGhpcyBob29rcyB3aWxsOlxuICogMXN0IGF0dGVtcHQgdG8gZmluZCBhbiBZQXhpcyB0aGF0IGhhcyBhbGwgZWxlbWVudHMgaW4gaXRzIGRvbWFpbiBmaW5pdGVcbiAqIElmIG5vIHN1Y2ggYXhpcyBleGlzdHMsIGl0IHdpbGwgcmV0dXJuIGFuIGFyYml0cmFyeSBZQXhpc1xuICogaWYgdGhlcmUgYXJlIG5vIFkgYXhlcyB0aGVuIGl0IHJldHVybnMgdW5kZWZpbmVkXG4gKlxuICogQHJldHVybnMgRWl0aGVyIFkgYXhpc09wdGlvbnMsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gWSBheGVzXG4gKi9cbmV4cG9ydCB2YXIgdXNlWUF4aXNXaXRoRmluaXRlRG9tYWluT3JSYW5kb20gPSBmdW5jdGlvbiB1c2VZQXhpc1dpdGhGaW5pdGVEb21haW5PclJhbmRvbSgpIHtcbiAgdmFyIHlBeGlzTWFwID0gdXNlQ29udGV4dChZQXhpc0NvbnRleHQpO1xuICB2YXIgeUF4aXNXaXRoRmluaXRlRG9tYWluID0gZmluZCh5QXhpc01hcCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICByZXR1cm4gZXZlcnkoYXhpcy5kb21haW4sIE51bWJlci5pc0Zpbml0ZSk7XG4gIH0pO1xuICByZXR1cm4geUF4aXNXaXRoRmluaXRlRG9tYWluIHx8IGdldEFueUVsZW1lbnRPZk9iamVjdCh5QXhpc01hcCk7XG59O1xuXG4vKipcbiAqIFRoaXMgZWl0aGVyIGZpbmRzIGFuZCByZXR1cm5zIEF4aXMgYnkgdGhlIHNwZWNpZmllZCBJRCwgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBhbiBheGlzIHdpdGggdGhpcyBJRCBkb2VzIG5vdCBleGlzdC5cbiAqXG4gKiBAcGFyYW0geUF4aXNJZCBpZGVudGlmaWVyIG9mIHRoZSBheGlzIC0gaXQncyBlaXRoZXIgYXV0b2dlbmVyYXRlZCAoJzAnKSwgb3IgcGFzc2VkIHZpYSBgaWRgIHByb3AgYXMgPFlBeGlzIGlkPSdmb28nIC8+XG4gKiBAcmV0dXJucyBheGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAdGhyb3dzIEVycm9yIGlmIG5vIGF4aXMgd2l0aCB0aGlzIElEIGV4aXN0c1xuICovXG5leHBvcnQgdmFyIHVzZVlBeGlzT3JUaHJvdyA9IGZ1bmN0aW9uIHVzZVlBeGlzT3JUaHJvdyh5QXhpc0lkKSB7XG4gIHZhciB5QXhpc01hcCA9IHVzZUNvbnRleHQoWUF4aXNDb250ZXh0KTtcbiAgISh5QXhpc01hcCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIFJlY2hhcnRzIGNvbnRleHQ7IGFyZSB5b3Ugc3VyZSB0aGlzIGlzIHJlbmRlcmVkIGluc2lkZSBhIFJlY2hhcnRzIHdyYXBwZXIgY29tcG9uZW50PycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIHlBeGlzID0geUF4aXNNYXBbeUF4aXNJZF07XG4gICEoeUF4aXMgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ291bGQgbm90IGZpbmQgeUF4aXMgYnkgaWQgXFxcIlwiLmNvbmNhdCh5QXhpc0lkLCBcIlxcXCIgW1wiKS5jb25jYXQoX3R5cGVvZih5QXhpc0lkKSwgXCJdLiBcIikuY29uY2F0KGdldEtleXNGb3JEZWJ1Zyh5QXhpc01hcCkpKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB5QXhpcztcbn07XG5leHBvcnQgdmFyIHVzZVZpZXdCb3ggPSBmdW5jdGlvbiB1c2VWaWV3Qm94KCkge1xuICB2YXIgdmlld0JveCA9IHVzZUNvbnRleHQoVmlld0JveENvbnRleHQpO1xuICByZXR1cm4gdmlld0JveDtcbn07XG5leHBvcnQgdmFyIHVzZU9mZnNldCA9IGZ1bmN0aW9uIHVzZU9mZnNldCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoT2Zmc2V0Q29udGV4dCk7XG59O1xuZXhwb3J0IHZhciB1c2VDaGFydFdpZHRoID0gZnVuY3Rpb24gdXNlQ2hhcnRXaWR0aCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoQ2hhcnRXaWR0aENvbnRleHQpO1xufTtcbmV4cG9ydCB2YXIgdXNlQ2hhcnRIZWlnaHQgPSBmdW5jdGlvbiB1c2VDaGFydEhlaWdodCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoQ2hhcnRIZWlnaHRDb250ZXh0KTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJpbnZhcmlhbnQiLCJmaW5kIiwiZXZlcnkiLCJjYWxjdWxhdGVWaWV3Qm94IiwiZ2V0QW55RWxlbWVudE9mT2JqZWN0IiwiWEF4aXNDb250ZXh0IiwidW5kZWZpbmVkIiwiWUF4aXNDb250ZXh0IiwiVmlld0JveENvbnRleHQiLCJPZmZzZXRDb250ZXh0IiwiQ2xpcFBhdGhJZENvbnRleHQiLCJDaGFydEhlaWdodENvbnRleHQiLCJDaGFydFdpZHRoQ29udGV4dCIsIkNoYXJ0TGF5b3V0Q29udGV4dFByb3ZpZGVyIiwicHJvcHMiLCJfcHJvcHMkc3RhdGUiLCJzdGF0ZSIsInhBeGlzTWFwIiwieUF4aXNNYXAiLCJvZmZzZXQiLCJjbGlwUGF0aElkIiwiY2hpbGRyZW4iLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUNsaXBQYXRoSWQiLCJnZXRLZXlzRm9yRGVidWciLCJvYmplY3QiLCJrZXlzIiwiT2JqZWN0IiwibGVuZ3RoIiwiY29uY2F0IiwidXNlWEF4aXNPclRocm93IiwieEF4aXNJZCIsInByb2Nlc3MiLCJ4QXhpcyIsInVzZUFyYml0cmFyeVhBeGlzIiwidXNlQXJiaXRyYXJ5WUF4aXMiLCJ1c2VZQXhpc1dpdGhGaW5pdGVEb21haW5PclJhbmRvbSIsInlBeGlzV2l0aEZpbml0ZURvbWFpbiIsImF4aXMiLCJkb21haW4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInVzZVlBeGlzT3JUaHJvdyIsInlBeGlzSWQiLCJ5QXhpcyIsInVzZVZpZXdCb3giLCJ1c2VPZmZzZXQiLCJ1c2VDaGFydFdpZHRoIiwidXNlQ2hhcnRIZWlnaHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/recharts/es6/context/chartLayoutContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/recharts/es6/util/BarUtils.js":
/*!****************************************************!*\
  !*** ./node_modules/recharts/es6/util/BarUtils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarRectangle: () => (/* binding */ BarRectangle),\n/* harmony export */   minPointSizeCallback: () => (/* binding */ minPointSizeCallback)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(app-pages-browser)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ActiveShapeUtils */ \"(app-pages-browser)/./node_modules/recharts/es6/util/ActiveShapeUtils.js\");\nvar _excluded = [\n    \"x\",\n    \"y\"\n];\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\n\n\n// Rectangle props is expecting x, y, height, width as numbers, name as a string, and radius as a custom type\n// When props are being spread in from a user defined component in Bar,\n// the prop types of an SVGElement have these typed as something else.\n// This function will return the passed in props\n// along with x, y, height as numbers, name as a string, and radius as number | [number, number, number, number]\nfunction typeguardBarRectangleProps(_ref, props) {\n    var xProp = _ref.x, yProp = _ref.y, option = _objectWithoutProperties(_ref, _excluded);\n    var xValue = \"\".concat(xProp);\n    var x = parseInt(xValue, 10);\n    var yValue = \"\".concat(yProp);\n    var y = parseInt(yValue, 10);\n    var heightValue = \"\".concat(props.height || option.height);\n    var height = parseInt(heightValue, 10);\n    var widthValue = \"\".concat(props.width || option.width);\n    var width = parseInt(widthValue, 10);\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, props), option), x ? {\n        x: x\n    } : {}), y ? {\n        y: y\n    } : {}), {}, {\n        height: height,\n        width: width,\n        name: props.name,\n        radius: props.radius\n    });\n}\nfunction BarRectangle(props) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ActiveShapeUtils__WEBPACK_IMPORTED_MODULE_2__.Shape, _extends({\n        shapeType: \"rectangle\",\n        propTransformer: typeguardBarRectangleProps,\n        activeClassName: \"recharts-active-bar\"\n    }, props));\n}\n_c = BarRectangle;\n/**\n * Safely gets minPointSize from from the minPointSize prop if it is a function\n * @param minPointSize minPointSize as passed to the Bar component\n * @param defaultValue default minPointSize\n * @returns minPointSize\n */ var minPointSizeCallback = function minPointSizeCallback(minPointSize) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return function(value, index) {\n        if (typeof minPointSize === 'number') return minPointSize;\n        var isValueNumber = typeof value === 'number';\n        if (isValueNumber) {\n            return minPointSize(value, index);\n        }\n        !isValueNumber ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, \"minPointSize callback function received a value with type of \".concat(_typeof(value), \". Currently only numbers are supported.\")) : 0 : void 0;\n        return defaultValue;\n    };\n};\nvar _c;\n$RefreshReg$(_c, \"BarRectangle\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvdXRpbC9CYXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZO0lBQUM7SUFBSztDQUFJO0FBQzFCLFNBQVNDLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSztJQUFhQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlQLE9BQU9GLFNBQVMsQ0FBQ1csY0FBYyxDQUFDQyxJQUFJLENBQUNILFFBQVFDLE1BQU07b0JBQUVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQUU7WUFBRTtRQUFFO1FBQUUsT0FBT0w7SUFBUTtJQUFHLE9BQU9KLFNBQVNZLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQVk7QUFDbFYsU0FBU08sUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSWYsT0FBT2dCLElBQUksQ0FBQ0g7SUFBSSxJQUFJYixPQUFPaUIscUJBQXFCLEVBQUU7UUFBRSxJQUFJdkIsSUFBSU0sT0FBT2lCLHFCQUFxQixDQUFDSjtR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QUFHO1FBQ1hPLFFBQVFBO1FBQ1JFLE9BQU9BO1FBQ1BDLE1BQU1kLE1BQU1jLElBQUk7UUFDaEJDLFFBQVFmLE1BQU1lLE1BQU07SUFDdEI7QUFDRjtBQUNPLFNBQVNDLGFBQWFoQixLQUFLO0lBQ2hDLE9BQU8sV0FBVyxHQUFFTCwwREFBbUIsQ0FBQ0Usb0RBQUtBLEVBQUUvQyxTQUFTO1FBQ3REb0UsV0FBVztRQUNYQyxpQkFBaUJyQjtRQUNqQnNCLGlCQUFpQjtJQUNuQixHQUFHcEI7QUFDTDtLQU5nQmdCO0FBT2hCOzs7OztDQUtDLEdBQ00sSUFBSUssdUJBQXVCLFNBQVNBLHFCQUFxQkMsWUFBWTtJQUMxRSxJQUFJQyxlQUFlbkUsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtvRSxZQUFZcEUsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUN2RixPQUFPLFNBQVV3QixLQUFLLEVBQUU2QyxLQUFLO1FBQzNCLElBQUksT0FBT0gsaUJBQWlCLFVBQVUsT0FBT0E7UUFDN0MsSUFBSUksZ0JBQWdCLE9BQU85QyxVQUFVO1FBQ3JDLElBQUk4QyxlQUFlO1lBQ2pCLE9BQU9KLGFBQWExQyxPQUFPNkM7UUFDN0I7UUFDQSxDQUFDQyxnQkFBZ0JDLEtBQXFDLEdBQUcvQiwwREFBU0EsQ0FBQyxPQUFPLGdFQUFnRVcsTUFBTSxDQUFDL0QsUUFBUW9DLFFBQVEsOENBQThDZ0IsQ0FBZ0IsR0FBRyxLQUFLO1FBQ3ZPLE9BQU8yQjtJQUNUO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvYW9zYW50b3MvV2Vic3Rvcm1Qcm9qZWN0cy93ZGMtd2ViLXBhbmVsL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvdXRpbC9CYXJVdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2V4Y2x1ZGVkID0gW1wieFwiLCBcInlcIl07XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuL0FjdGl2ZVNoYXBlVXRpbHMnO1xuXG4vLyBSZWN0YW5nbGUgcHJvcHMgaXMgZXhwZWN0aW5nIHgsIHksIGhlaWdodCwgd2lkdGggYXMgbnVtYmVycywgbmFtZSBhcyBhIHN0cmluZywgYW5kIHJhZGl1cyBhcyBhIGN1c3RvbSB0eXBlXG4vLyBXaGVuIHByb3BzIGFyZSBiZWluZyBzcHJlYWQgaW4gZnJvbSBhIHVzZXIgZGVmaW5lZCBjb21wb25lbnQgaW4gQmFyLFxuLy8gdGhlIHByb3AgdHlwZXMgb2YgYW4gU1ZHRWxlbWVudCBoYXZlIHRoZXNlIHR5cGVkIGFzIHNvbWV0aGluZyBlbHNlLlxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcGFzc2VkIGluIHByb3BzXG4vLyBhbG9uZyB3aXRoIHgsIHksIGhlaWdodCBhcyBudW1iZXJzLCBuYW1lIGFzIGEgc3RyaW5nLCBhbmQgcmFkaXVzIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG5mdW5jdGlvbiB0eXBlZ3VhcmRCYXJSZWN0YW5nbGVQcm9wcyhfcmVmLCBwcm9wcykge1xuICB2YXIgeFByb3AgPSBfcmVmLngsXG4gICAgeVByb3AgPSBfcmVmLnksXG4gICAgb3B0aW9uID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gIHZhciB4VmFsdWUgPSBcIlwiLmNvbmNhdCh4UHJvcCk7XG4gIHZhciB4ID0gcGFyc2VJbnQoeFZhbHVlLCAxMCk7XG4gIHZhciB5VmFsdWUgPSBcIlwiLmNvbmNhdCh5UHJvcCk7XG4gIHZhciB5ID0gcGFyc2VJbnQoeVZhbHVlLCAxMCk7XG4gIHZhciBoZWlnaHRWYWx1ZSA9IFwiXCIuY29uY2F0KHByb3BzLmhlaWdodCB8fCBvcHRpb24uaGVpZ2h0KTtcbiAgdmFyIGhlaWdodCA9IHBhcnNlSW50KGhlaWdodFZhbHVlLCAxMCk7XG4gIHZhciB3aWR0aFZhbHVlID0gXCJcIi5jb25jYXQocHJvcHMud2lkdGggfHwgb3B0aW9uLndpZHRoKTtcbiAgdmFyIHdpZHRoID0gcGFyc2VJbnQod2lkdGhWYWx1ZSwgMTApO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIG9wdGlvbiksIHggPyB7XG4gICAgeDogeFxuICB9IDoge30pLCB5ID8ge1xuICAgIHk6IHlcbiAgfSA6IHt9KSwge30sIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgbmFtZTogcHJvcHMubmFtZSxcbiAgICByYWRpdXM6IHByb3BzLnJhZGl1c1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBCYXJSZWN0YW5nbGUocHJvcHMpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNoYXBlLCBfZXh0ZW5kcyh7XG4gICAgc2hhcGVUeXBlOiBcInJlY3RhbmdsZVwiLFxuICAgIHByb3BUcmFuc2Zvcm1lcjogdHlwZWd1YXJkQmFyUmVjdGFuZ2xlUHJvcHMsXG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBcInJlY2hhcnRzLWFjdGl2ZS1iYXJcIlxuICB9LCBwcm9wcykpO1xufVxuLyoqXG4gKiBTYWZlbHkgZ2V0cyBtaW5Qb2ludFNpemUgZnJvbSBmcm9tIHRoZSBtaW5Qb2ludFNpemUgcHJvcCBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWluUG9pbnRTaXplIG1pblBvaW50U2l6ZSBhcyBwYXNzZWQgdG8gdGhlIEJhciBjb21wb25lbnRcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgZGVmYXVsdCBtaW5Qb2ludFNpemVcbiAqIEByZXR1cm5zIG1pblBvaW50U2l6ZVxuICovXG5leHBvcnQgdmFyIG1pblBvaW50U2l6ZUNhbGxiYWNrID0gZnVuY3Rpb24gbWluUG9pbnRTaXplQ2FsbGJhY2sobWluUG9pbnRTaXplKSB7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBtaW5Qb2ludFNpemUgPT09ICdudW1iZXInKSByZXR1cm4gbWluUG9pbnRTaXplO1xuICAgIHZhciBpc1ZhbHVlTnVtYmVyID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICBpZiAoaXNWYWx1ZU51bWJlcikge1xuICAgICAgcmV0dXJuIG1pblBvaW50U2l6ZSh2YWx1ZSwgaW5kZXgpO1xuICAgIH1cbiAgICAhaXNWYWx1ZU51bWJlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJtaW5Qb2ludFNpemUgY2FsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZWQgYSB2YWx1ZSB3aXRoIHR5cGUgb2YgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpLCBcIi4gQ3VycmVudGx5IG9ubHkgbnVtYmVycyBhcmUgc3VwcG9ydGVkLlwiKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH07XG59OyJdLCJuYW1lcyI6WyJfZXhjbHVkZWQiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwidmFsdWUiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIlJlYWN0IiwiaW52YXJpYW50IiwiU2hhcGUiLCJ0eXBlZ3VhcmRCYXJSZWN0YW5nbGVQcm9wcyIsIl9yZWYiLCJwcm9wcyIsInhQcm9wIiwieCIsInlQcm9wIiwieSIsIm9wdGlvbiIsInhWYWx1ZSIsImNvbmNhdCIsInBhcnNlSW50IiwieVZhbHVlIiwiaGVpZ2h0VmFsdWUiLCJoZWlnaHQiLCJ3aWR0aFZhbHVlIiwid2lkdGgiLCJuYW1lIiwicmFkaXVzIiwiQmFyUmVjdGFuZ2xlIiwiY3JlYXRlRWxlbWVudCIsInNoYXBlVHlwZSIsInByb3BUcmFuc2Zvcm1lciIsImFjdGl2ZUNsYXNzTmFtZSIsIm1pblBvaW50U2l6ZUNhbGxiYWNrIiwibWluUG9pbnRTaXplIiwiZGVmYXVsdFZhbHVlIiwidW5kZWZpbmVkIiwiaW5kZXgiLCJpc1ZhbHVlTnVtYmVyIiwicHJvY2VzcyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/recharts/es6/util/BarUtils.js\n"));

/***/ })

});